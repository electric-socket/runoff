> Member ACKERMAN
| PROGRAM ACKERMANN(OUTPUT) ;
| CONST NLIM = 6 ;   MLIM = 6 ;   (* LIMITS OF FUNCTION DOMAIN *)
| TYPE  SHRTINT = 0..20 ;
| VAR   N, M : SHRTINT ;
| 
| FUNCTION ACK(N, M : INTEGER ): INTEGER ;
|    BEGIN
|    IF M = 0 THEN ACK := N+1
|    ELSE
|       IF N = 0 THEN  ACK := ACK(1, M-1)
|       ELSE   ACK := ACK( ACK(N-1,M) ,  M-1) ;
|    END (*ACK*) ;
| 
| BEGIN
| WRITE(OUTPUT, '      ') ;
| FOR N := 0 TO NLIM DO WRITE(OUTPUT, '   ', N:4, '    ') ;
| WRITELN(OUTPUT) ;   WRITELN(OUTPUT) ;
| FOR M := 0 TO MLIM DO
|    BEGIN    WRITELN(OUTPUT) ;   WRITE(M:5, ')') ;
|    FOR N := 0 TO NLIM DO  WRITE( ACK(N,M):12 ) ;
|    WRITELN( OUTPUT)
|    END ;
| END .
> Member COMPARE
|    (*$D-                     *)
| 
| (*   COMPARE - COMPARE TWO TEXT FILES AND REPORT THEIR DIFFERENCES
|      COPYRIGHT (C) 1977,1978
|      JAMES F. MINER
|      SOCIAL SCIENCE RESEARCH FACILITIES CENTER
|      UNIVERSITY OF MINNESOTA
| 
|      GENERAL PERMISSION TO USE IN A NON PROFIT MANNER.
| 
|      COMPARE IS USED TO DISPLAY ON OUTPUT THE DIFFERENCES BETWEEN
|      TWO SIMILAR TEXTS (FILEA AND FILEB). NOTABLE CHARACTERISTICS ARE
| 
|      - COMPARE IS LINE ORIENTED. THE SMALLEST UNIT OF COMPARISON
|        IS THE TEXT LINE (IGNORING TRAILING BLANKS). THE PRESENT
|        IMPLEMENTATION HAS A FIXED MAXIMUM LINE LENGTH.
| 
| 
|      - BY MANIPULATING A PROGRAM PARAMETER, THE USER CAN AFFECT
|        COMPARES SENSITIVITY TO THE "LOCALITY" OF DIFFERENCES.
|        MORE SPECIFICALLY THIS PARAMETER MINLINESFORMATCH, SPECIFIES
|        THE NUMBER OF CONSECUTIVE LINES ON EACH FILE WHICH MUST MATCH
|        IN ORDER THAT THEY BE CONSIDERED AS TERMINATING THE CURRENT
|        MISMATCH. A LARGE VALUE FOR MINLINESFORMATCH TENDS TO PRODUCE
|        FEWER BUT LARGER MISMATCHES THAN DOES A SMALLER VALUE. THE VALUE
|        SIX APPEARS TO GIVE GOOD RESULTS ON PASCAL SOURCE FILES BUT MAY
|        BE INAPPROPIATE FOR OTHER APPLICATIONS.
| 
|        IF COMPARE IS TO BE USED AS A GENERAL UTILITY PROGRAM, THEN
|        MINLINESFORMATCH SHOULD BE A PARAMETER. IT IS DECLARED AS
|        A CONSTANT FOR THE SAKE OF PORTABILITY.
| 
|      - COMPARE EMPLOYS A SIMPLE BACKTRACKING SEARCH ALGORITHM TO
|        ISOLATE MISMATCHES FROM THEIR SURROUNDING MATCHES. THIS
|        REQUIRES (HEAP) STORAGE ROUGHLY PROPORTIONAL TO THE SIZE
|        OF THE LARGEST MISMATCH, AND TIME ROUGHLY PROPORTIONAL
|        TO THE SQUARE OF THE SIZE OF EACH MISMATCH FOR EACH MISMATCH.
|        FOR THIS REASON IT MAY NOT BE FEASIBLE TO USE COMPARE ON FILES
|        WITH VERY LONG MISMATCHES.
| 
|      - TO THE BEST OF THE AUTHORS KNOWLEDGE, COMPARE UTILIZES ONLY
|        STANDARD COMPARE.
| 
|      - COMPARE WAS IMPLEMENTED AT UNL IN AUGUST 1978 BY CURT HILL.
|        MODIFICATIONS REQUIRED TO FORCE COMPATIBILITY WITH STANFORD
|        PASCAL WERE:
|         ADDITION OF EMPTY PARENS FOR PARAMATERLESS WRITELN CALLS I.E.
|         FROM < WRITELN; > TO < WRITELN(); >
|         DELETION OF PACK CALLS (ALL CHARS ARE PACKED)
|         ADDITION OF A PAGE PROCEDURE AND TEXT DECLARATION WHICH
|         ARE ABSENT FROM THIS COMPILER.
|         IMPLEMENTATION OF SQUARE BRACKETS AS (/ /)
|         LIMITING MAXIMUM LINELENGTH TO 80
|         DELETION OF NONSTANDARD FILES FROM PROGRAM HEAD.
|         ADDITION OF FILLER TO ENSURE BOUNDARY ALLIGNMENT OF STREAM
|          SUPPRESSION OF THE PRINTING OF THE SENTINEL
| 
|                                                              *)
| 
| 
| PROGRAM COMPARE(OUTPUT);
| 
|   CONST
|     VERSION = '1.2P (78/03/01)';
|     LINELENGTH =134;  (* MAXIMUM SIGNIFICANT INPUT LINE LENGTH *)
|     MINLINESFORMATCH = 6; (* LINES TO END MIS-MATCH *)
| 
|   TYPE
|     LINEPOINTER = @LINE;
|     LINE =                 (* SINGLE LINE BUFFER *)
|        RECORD
|          NEXTLINE : LINEPOINTER;
|          LENGTH : 0..LINELENGTH;
|          IMAGE : ARRAY (/0..LINELENGTH/) OF CHAR;
|        END;
|     STREAM =               (* BOOKKEEPING FOR EACH INPUT FILE *)
|        RECORD
|          CURSOR, HEAD, TAIL : LINEPOINTER;
|          CURSORLINENO, HEADLINENO, TAILLINENO : INTEGER;
|          ENDFILE : BOOLEAN;
|          FILLER : ARRAY (/1..3/) OF CHAR; (* FORCES BOUNDARY ALIGNMENT*)
|        END;
|     TEXT = FILE OF CHAR;
| 
|   VAR
|     FILEA, FILEB : TEXT;
|     A, B : STREAM;
|     MATCH :BOOLEAN;
|     ENDFILE : BOOLEAN;    (* SET IF END OF STREAM FOR A OR B *)
|     TEMPLINE :            (* USED BY READLINE *)
|       RECORD
|         LENGTH : INTEGER;
|         IMAGE : ARRAY (/0..LINELENGTH/) OF CHAR;
|         END;
| 
|     FREELINES : LINEPOINTER;   (* FREE LIST OF LINE BUFFERS *)
| 
|     SAME : BOOLEAN;            (* FALSE IF NO MIS-MATCHES OCCUR *)
| 
| 
|   PROCEDURE PAGE (VAR FILEX : TEXT);
|     BEGIN
|     WRITELN(FILEX);
|     WRITELN(FILEX,'1  ');
|     END;
| 
| 
|   PROCEDURE COMPAREFILES;
| 
|     FUNCTION ENDSTREAM(VAR X : STREAM) : BOOLEAN;
|       BEGIN  (* ENDSTREAM *)
|       ENDSTREAM := ((X.CURSOR = NIL)  AND X.ENDFILE)
|       END; (* ENDSTREAM *)
| 
|     PROCEDURE MARK(VAR X : STREAM);
|       (* CAUSES BEGINNING OF STREAM TO BE POSITIONED BEFORE
|          CURRENT STREAM CURSOR. BUFFERS GET RECLAIMED, LINE
|          COUNTERS RESET, ETC.                               *)
|       VAR
|         P : LINEPOINTER;
|     BEGIN (* MARK *)
|       WITH X DO
|         IF HEAD <> NIL
|            THEN BEGIN
|                 WHILE HEAD <> CURSOR DO (* RECLAIM BUFFERS *)
|                   BEGIN
|                     WITH HEAD@ DO
|                       BEGIN
|                       P := NEXTLINE;
|                       NEXTLINE := FREELINES;
|                       FREELINES := HEAD
|                       END;
|                    HEAD := P
|                    END;
|               HEADLINENO := CURSORLINENO;
|               IF CURSOR = NIL
|                  THEN BEGIN
|                       TAIL := NIL;
|                       TAILLINENO := CURSORLINENO
|                       END
|                  ELSE;
|               END
|            END; (* MARK *)
| 
| 
|     PROCEDURE MOVECURSOR(VAR X : STREAM; VAR FILEX : TEXT);
| 
|       (* FILEX IS THE INPUT FILE ASSOCIATED WITH STREAM X. THE CURSOR
|          FOR X IS MOVED FORWARD ONE LINE, READING FROM X IF NECESARY,
|          AND INCREMENTING THE LINE COUNT. ENDFILE IS SET IF EOF IS
|          ENCOUNTERED ON EITHER STREAM.                     *)
| 
| 
|       PROCEDURE READLINE;
|         VAR
|           NEWLINE : LINEPOINTER;
|           C, C2 : 0..LINELENGTH;
| 
|         BEGIN (* READLINE *)
|           IF NOT X.ENDFILE
|              THEN BEGIN
|             ¯"+++ C := 0;
|                   WHILE NOT EOLN(FILEX) AND (C < LINELENGTH) DO
|                     BEGIN    (* READ A LINE INTO TEMPLINE.IMAGE *)
|                     C := C + 1;
|                     TEMPLINE.IMAGE(/C/) := FILEX@;
|                     GET(FILEX)
|                     END;
|                   READLN(FILEX);
|                   WHILE (TEMPLINE.IMAGE(/C/) = ' ') AND (C < LINELENGTH) DO
|                      C := C + 1;
|                   IF C < TEMPLINE.LENGTH
|                      THEN
|                        FOR C2 := C+1 TO TEMPLINE.LENGTH DO
|                          TEMPLINE.IMAGE (/C2/) := ' '
|                      ELSE;  +++"ò
| #
| #                 readln(filex, templine.image);
| #                 c := linelength;
| #                   repeat
| #                   c := c-1
| #                   until (templine.image[c] <> ' ') or (c = 1);
| #
|                   TEMPLINE.LENGTH := C;
|                   NEWLINE := FREELINES;
|                   IF NEWLINE = NIL
|                      THEN NEW (NEWLINE)
|                      ELSE FREELINES := FREELINES@.NEXTLINE;
|                   NEWLINE@.IMAGE := TEMPLINE.IMAGE; (* THIS STMT IS
|                                              IN LIEU OF A PACK*)
|                   NEWLINE@.LENGTH := C;
|                   NEWLINE@.NEXTLINE := NIL;
|                   IF X.TAIL = NIL
|                      THEN BEGIN
|                           X.HEAD := NEWLINE;
|                           X.TAILLINENO := 1;
|                           X.HEADLINENO := 1
|                           END
|                      ELSE BEGIN
|                           X.TAIL@.NEXTLINE := NEWLINE;
|                           X.TAILLINENO := X.TAILLINENO + 1
|                           END;
|                   X.TAIL := NEWLINE;
|                   X.ENDFILE := EOF(FILEX)
|                   END
|               END; (* READLINE *)
| 
| 
|       BEGIN    (* MOVECURSOR *)
|         IF X.CURSOR <> NIL
|            THEN BEGIN
|                 IF X.CURSOR = X.TAIL
|                    THEN READLINE
|                    ELSE;
|                 X.CURSOR := X.CURSOR@.NEXTLINE;
|                 IF X.CURSOR = NIL
|                    THEN ENDFILE := TRUE
|                    ELSE;
|                 X.CURSORLINENO := X.CURSORLINENO + 1;
|                 END
|            ELSE IF NOT X.ENDFILE
|                    THEN BEGIN  (* BEGINNING OF STREAM *)
|                         READLINE;
|                         X.CURSOR := X.HEAD;
|                         X.CURSORLINENO := X.HEADLINENO
|                         END
|                    ELSE ENDFILE := TRUE;  (* END OF STREAM *)
|         END;  (* MOVECURSOR *)
| 
| 
| 
|    PROCEDURE BACKTRACK(VAR X :STREAM; VAR XLINES : INTEGER);
|      (* CAUSES THE CURRENT POSITION OF STREAM X TO BECOME THAT OF THE
|         LAST MARK OPERATION. I.E. THE CURRENT LINE WHEN THE STREAM
|         WAS MARKED LAST BECOMES THE NEW CURSOR. XLINES IS SET TO THE
|         NUMBER OF LINES FROM THE NEW CURSOR TO THE OLD CURSOR INCLUSIVE
|                                          *)
| 
|      BEGIN   (* BACKTRACK *)
|        XLINES := X.CURSORLINENO + 1 - X.HEADLINENO;
|        X.CURSOR := X.HEAD;
|        X.CURSORLINENO := X.HEADLINENO;
|        ENDFILE := ENDSTREAM (A) OR ENDSTREAM (B);
|        END;   (* BACKTRACK *)
| 
| 
|     PROCEDURE COMPARELINES (VAR MATCH : BOOLEAN);
| 
|       (* COMPARE THE CURRENT LINES OF STREAMS A AND B, RETURNING MATCH
|          TO SIGNAL THEIR (NON-) EQUIVALENCE. EOF ON BOTH STREAMS IS
|          CONSIDERED A MATCH, BUT EOF ON ONLY ONE STREAM IS A MISMATCH *)
| 
| 
| 
|       BEGIN       (* COMPARELINES *)
|         IF (A.CURSOR = NIL) OR (B.CURSOR = NIL)
|            THEN MATCH := ENDSTREAM (A) AND ENDSTREAM (B)
|            ELSE BEGIN
|                 MATCH := (A.CURSOR@.LENGTH = B.CURSOR@.LENGTH);
|                 IF MATCH
|                    THEN MATCH := (A.CURSOR@.IMAGE = B.CURSOR@.IMAGE)
|                    ELSE
|                 END
|       END;        (* COMPARELINES *)
| 
| 
| 
| 
|     PROCEDURE FINDMISMATCH;
|       BEGIN (* FINDMISMATCH *)
|         (* NOT  ENDFILE AND MATCH *)
|         REPEAT   (* COMPARENEXTLINES *)
|           MOVECURSOR(A, FILEA);
|           MOVECURSOR(B, FILEB);
|           MARK (A);
|           MARK (B);
|           COMPARELINES(MATCH);
|         UNTIL ENDFILE OR NOT MATCH;
|       END;           (* FINDMISMATCH *)
| 
| 
| 
| 
|     PROCEDURE FINDMATCH;
|       VAR
|         ADVANCEB : BOOLEAN; (* TOGGLE ONE-LINE
|                               LOOKAHEAD BETWEEN STREAMS *)
|       PROCEDURE SEARCH(VAR X : STREAM;  (* STREAM TO SEARCH *)
|                        VAR FILEX : TEXT;
|                        VAR Y : STREAM;  (* STREAM TO LOOKAHEAD *)
|                        VAR FILEY : TEXT);
| 
|        (* LOOK AHEAD ONE LINE ON STREAM Y, AND SEARCH FOR THAT LINE
|           BACKTRACKING ON STREAM X. *)
| 
|          VAR
|            COUNT : INTEGER; (* NUMBER OF LINES BACKTRACKED ON X *)
| 
|          PROCEDURE CHECKFULLMATCH;
|          (* FROM  THE CURRENT POSITIONS OF X AND Y, WHICH MATCH
|             MAKE SURE THAT THE NEXT MINLINESFORMATCH - 1 LINES ALSO
|             MATCH, OR SET MATCH := FALSE   *)
| 
|          VAR
|            N : INTEGER;
|            SAVEXCUR ,SAVEYCUR : LINEPOINTER;
|            SAVEXLINE, SAVEYLINE : INTEGER;
| 
|          BEGIN        (* CHECKFULLMATCH *)
|            SAVEXCUR := X.CURSOR;
|            SAVEYCUR := Y.CURSOR;
|            SAVEXLINE := X.CURSORLINENO;
|            SAVEYLINE := Y.CURSORLINENO;
|            COMPARELINES(MATCH);
|            N := MINLINESFORMATCH - 1;
|            WHILE MATCH AND (N <> 0) DO
|               BEGIN
|               MOVECURSOR(X, FILEX);
|               MOVECURSOR(Y, FILEY);
|               COMPARELINES(MATCH);
|               N := N - 1
|            END;
|            X.CURSOR := SAVEXCUR;
|            X.CURSORLINENO := SAVEXLINE;
|            Y.CURSOR := SAVEYCUR;
|            Y.CURSORLINENO := SAVEYLINE;
|            END;    (* CHECKFULLMATCH *)
| 
| 
| 
|          BEGIN         (* SEARCH *)
|            MOVECURSOR(Y, FILEY);
|            BACKTRACK(X, COUNT);
|            CHECKFULLMATCH;
|            COUNT := COUNT - 1;
|            WHILE (COUNT <> 0) AND NOT MATCH DO
|               BEGIN
|               MOVECURSOR(X, FILEX);
|               COUNT := COUNT - 1;
|               CHECKFULLMATCH
|               END
|            END;          (* SEARCH *)
| 
| 
| 
|     PROCEDURE PRINTMISMATCH;
| 
|       VAR
|         EMPTYA, EMPTYB : BOOLEAN;
| 
|       PROCEDURE WRITETEXT(P, Q :LINEPOINTER);
|         VAR I : INTEGER;
|         BEGIN       (* WRITETEXT *)
|           WRITELN();
|           WHILE (P <> NIL) AND (P <> Q) DO
|             BEGIN
|               WRITE(' > ');
|               IF P@.LENGTH = 0
|                  THEN
|                   ELSE FOR I := 1 TO P@.LENGTH DO
|                            WRITE (OUTPUT,P@.IMAGE(/I/));
|                WRITELN();
|               P := P@.NEXTLINE
|               END;
|             IF P = NIL
|                THEN WRITELN(' ==== EOF ====')
|                "ELSE" ;
|             WRITELN();
|             END;    (* WRITETEXT *)
| 
| 
| 
|        PROCEDURE WRITELINENO(VAR X : STREAM);
|          VAR
|            F, L : INTEGER;
| 
|          BEGIN     (* WRITELINENO *)
|            F := X.HEADLINENO;
|            L := X.CURSORLINENO - 1;
|            WRITE('LINE');
|            IF F = L
|               THEN WRITE(' ',F:1)
|               ELSE WRITE('S ',F:1,' TO ',L:1);
|            IF X.CURSOR = NIL
|               THEN WRITE(' (BEFORE EOF)')
|               ELSE;
|            END;          (* WRITELINENO *)
| 
| 
| 
|        PROCEDURE PRINTEXTRATEXT (VAR X : STREAM; XNAME : CHAR
|                                  VAR Y : STREAM; YNAME : CHAR);
| 
|          BEGIN     (* PRINTEXTRATEXT *)
|            WRITE (' EXTRA TEXT ON FILE', XNAME,' --> ');
|            WRITELINENO(X);        WRITELN();
|            IF Y.HEAD = NIL
|               THEN WRITELN(' BEFORE EOF ON FILE', YNAME)
|               ELSE WRITELN(' BETWEEN LINES ', Y.HEADLINENO-1:1,' AND ',
|                          Y.HEADLINENO:1,' OF FILE',YNAME);
|            WRITETEXT(X.HEAD, X.CURSOR)
|            END;         (* PRINTEXTRATEXT *)
| 
| 
| 
|     BEGIN            (* PRINTMISMATCH *)
|       WRITELN (' =========================================');
|       EMPTYA := (A.HEAD = A.CURSOR);
|       EMPTYB := (B.HEAD = B.CURSOR);
|       IF EMPTYA OR EMPTYB
|          THEN IF EMPTYA
|                  THEN PRINTEXTRATEXT(B, 'B', A, 'A')
|                  ELSE PRINTEXTRATEXT(A, 'A', B, 'B')
|          ELSE BEGIN
|               WRITELN (' MISMATCH:');  WRITELN();
|               WRITE(' FILEA --> ');   WRITELINENO(A);
|               WRITELN(':');
|               WRITETEXT(A.HEAD, A.CURSOR);
|               WRITE(' FILEB --> '); WRITELINENO(B); WRITELN (':');
|               WRITETEXT(B.HEAD, B.CURSOR);
|               END
|          END;       (* PRINTMISMATCH *)
| 
| 
| 
|     BEGIN    (* FINDMATCH *)
|         (* NOT MATCH *)
|       ADVANCEB := TRUE;
|       REPEAT
|         IF NOT ENDFILE
|            THEN ADVANCEB := NOT ADVANCEB
|            ELSE ADVANCEB := ENDSTREAM (A);
|         IF ADVANCEB
|            THEN SEARCH (A, FILEA, B, FILEB)
|            ELSE SEARCH (B, FILEB, A, FILEA)
|       UNTIL MATCH;
|       PRINTMISMATCH;
|     END;      (* FINDMATCH *)
| 
| 
| 
|     BEGIN        (* COMPAREFILES *)
|       MATCH := TRUE;   (* I.E. BEGINNINGS OF FILES MATCH *)
|       REPEAT
|         IF MATCH
|            THEN FINDMISMATCH
|            ELSE BEGIN
|                 SAME := FALSE;
|                 FINDMATCH
|                 END
|       UNTIL ENDFILE AND MATCH;
|       (* MARK (A); MARK (B); MARK END OF FILES, THEREBY DISPOSING OF
|                               BUFFERS     *)
|      END;      (* COMPAREFILES *)
| 
| 
| 
| 
|     PROCEDURE INITIALIZE;
| 
|        PROCEDURE INITSTREAM(VAR X : STREAM; VAR FILEX : TEXT);
|          BEGIN    (* INITSTREAM *)
|            WITH X DO
|               BEGIN
|               CURSOR := NIL;
|               HEAD := NIL;
|               TAIL := NIL;
|               CURSORLINENO := 0;
|               HEADLINENO := 0;
|               TAILLINENO := 0
|               END;
|           RESET (FILEX);
|           X.ENDFILE := EOF(FILEX);
|           END;  (* INITSTREAM *)
| 
| 
|       BEGIN   (* INITIALIZE*)
| 
|         INITSTREAM (A, FILEA);    INITSTREAM (B, FILEB);
|         ENDFILE := A.ENDFILE OR B.ENDFILE;
|         FREELINES := NIL;
|         TEMPLINE.LENGTH := LINELENGTH;
|         TEMPLINE.IMAGE(/0/) := 'X';   (* SENTINEL *)
|         END;       (* INITIALIZE *)
| 
| 
| 
| 
| 
|     BEGIN       (* COMPARE *)
|       INITIALIZE;
|       PAGE(OUTPUT);
|       WRITELN ('     COMPARE.  VERSION ', VERSION);
|       WRITELN();
|       WRITELN (' MATCH CRITERION = ',MINLINESFORMATCH:1, ' LINES.');
|       WRITELN();
|       IF A.ENDFILE
|          THEN WRITELN (' FILEA IS EMPTY.')
|          ELSE;
|       IF B.ENDFILE
|          THEN WRITELN(' FILEB IS EMPTY.');
|       IF  NOT ENDFILE
|           THEN BEGIN
|                SAME := TRUE;
|                COMPAREFILES;
|                IF SAME
|                   THEN WRITELN(' NO DIFFERENCES.')
|                   ELSE;
|                END
|           ELSE;
|   END.      (* COMPARE *)
> Member COMPRESS
|   (*$P-,F-,D-,K-,Q+,I+,M-    *)
|  PROGRAM COMPRESS (INPUT,OUTPUT,QRR);
|   (* THIS PROGRAM READS IN SOURCE(OR OTHER) TEXT AND COMPRESSES THE
|      TEXT BY ELIMINATING DUPLICATE CHARACTERS. THERE ARE TWO SPECIAL
|      CHARACTERS WHICH ARE USED TO AID THIS. SPEC1ALCHAR1 AND 2.
|      IF THERE IS AN OCCURRENCE OF 3..256 IDENTICAL CHARACTERS
|      THEY ARE COMPRESSED INTO THE FOLLOWING S C N, WHERE :
|        S = SPECIALCHAR1
|        C = THE DUPLICATED CHARACTER
|        N = A 1 BYTE COUNT OF THE NUMBER OF DUPLICATED CHARACTERS
| 
|        IF SPECIALCHAR1 OR 2 IS ENCOUNTERED, THE FOLLOWING STRING
|        IS OUTPUT : S C 1 WHERE :
|          S = SPECIALCHAR1
|          C = SPECIALCHAR1 OR SPECIALCHAR2
|          1 = BYTE COUNT OF 1
| 
|        AT END OF LINE A CHECKSUM IS WRITTEN OUT. THE CHECKSUM IS OF
|        THE FORM
|        S N WHERE :
|          S = SPECIALCHAR2
|          N = THE LOW ORDER BYTE OF THE CHECKSUM
|        THE CHECKSUM WILL BE IN THE RANGE OF 0 .. 255. OVERFLOW SHOULD
|        NOT OCCUR IF CHECK SUM INTERVAL IS A REASONABLE VALUE, TRUNCATION OF
|        CHECKSUM TO LESS THAN 255 SHOULD BE NO PROBLEM.
| 
|        IN ORDER THAT THE EXPAND PROGRAM CAN CALIBRATE ITSELF THE FIRST
|        CHARACTERS SENT ARE SPECIALCHAR1, SPECIALCHAR2, AND TYPECODE,
|        IN THAT ORDER. TYPECODE WILL BE USED TO DENOTE SOURCE CODE TYPE
|        FOR (FUTURE) KEYWORD COMPACTION.
| 
|        THE DATA IN COMPRESSED FORM IS TERMINATED BY A CHECKSUM AND
|        AN INTERNAL END OF FILE MARK WHICH IS S S 0 WHERE :
|          S = SPECIALCHAR1
|          S = SPECIALCHAR1
|          0 = INDICATES A BYTE COUNT OF ZERO WHICH CAN ONLY LEGALLY
|              OCCUR AT END OF FILE.
| 
|        BECAUSE OF THE AWKWARD HANDLING OF SPECIALCHAR1 AND 2
|        THEY SHOULD BE RARE TO NONEXISTANT IN THE INPUT DATA SET,
|        BUT THEY WILL BE HANDLED CORRECTLY IF PRESENT.
| 
|        UPDATE RECORD:
| 
|        04/27/79 : COMMENT CORRECTIONS AND SET SPECIALCHARS TO MORE
|                   APPROPIATE VALUES. CH
| 
| 
|                                              CURT HILL
|                                              225 NEBRASKA HALL
|                                              UNIVERSITY OF NEBRASKA - LINCOLN
|                                              LINCOLN, NEBRASKA
|                                              68588
|                                              (402) 472-3701
| 
| 
|        THIS PROGRAM IS COPYRIGHT 1979, CURT HILL
| 
|        PERMISSION IS HEREBY GRANTED FOR ANY NONPROFIT USE OF ALL OR
|        PARTS OF THIS PROGRAM, PROVIDED THIS NOTICE IS DISPLAYED.
|        FURTHERMORE DISTRIBUTION AND IMPROVEMENT IS ENCOURAGED.
|        I WOULD LIKE TO HEAR ABOUT AND/OR RECIEVE COPIES OF ANY
|        IMPROVEMENTS THAT ARE WORTH MAKING TO THIS PROGRAM. CONTACT
|        ME AT ABOVE ADDRESS OR SEE PASCAL NEWS FOR AN ADDRESS UPDATE.
| 
|                   FREELY YOU HAVE RECIEVED, FREELY GIVE.
|                                    *)
| 
| 
|    VAR
|      BUFFER : ARRAY (/0..2/) OF CHAR;
|      SPECIALCHAR1, SPECIALCHAR2 : CHAR;
|      INCOUNT,            (* CHARS INPUT *)
|      OUTCOUNT,           (* CHARS OUTPUT *)
|      CHECKSUM,
|      INLINE : INTEGER;   (* INPUT LINES (ALSO OUTPUT CHECKSUMS) *)
|      TYPECODE : CHAR;    (* INDICATES TYPE OF SOURCE CODE *)
| 
| 
| 
|    PROCEDURE WRITECHAR(C : CHAR);
| 
|      (* THIS PROCEDURE WRITES OUT ONE CHARACTER AND SUMS CHECKSUM AND
|         THE COUNT OF CHARACTERS OUTPUT       *)
| 
|      BEGIN (* WRITECHAR *)
|        WRITE (QRR, C);
|        OUTCOUNT := OUTCOUNT + 1;
|        CHECKSUM := CHECKSUM + ORD(C);
|        END;    (* WRITECHAR *)
| 
| 
| 
|    PROCEDURE WRITECHECKSUM;
| 
|      (* THIS PROCEDURE WRITES OUT THE CHECKSUM *)
| 
|      BEGIN(* WRITECHECKSUM *)
|        WRITE (QRR, SPECIALCHAR2, CHR(CHECKSUM MOD 256));
|        OUTCOUNT := OUTCOUNT + 2;
|        CHECKSUM := 0;
|        INLINE := INLINE + 1;
|        END;    (* WRITECHECKSUM *)
| 
| 
|    FUNCTION GETCHAR (VAR C:CHAR):BOOLEAN;
|      (* GET ONE CHAR, HANDLE EOLN PROPERLY AND PASS BACK WHETHER EOLN
|         OR NOT SOAS TO TRIGGER CHECKSUM ACTIVITIES.   *)
| 
|      BEGIN     (* GETCHAR *)
|        IF NOT EOF(INPUT) THEN
|           BEGIN
|           IF EOLN(INPUT)
|              THEN BEGIN
|                   READLN(INPUT);
|                   GETCHAR := FALSE;
|                   END
|              ELSE BEGIN
|                   READ (INPUT,C);
|                   INCOUNT := INCOUNT + 1;
|                   GETCHAR := TRUE;
|                   END;
|             END;   (*IF NOT EOF BEGIN *)
|        END;           (* GETCHAR *)
| 
| 
|    PROCEDURE FILLBUFFER (INDEX:INTEGER);
|      (* FILL UP THE BUFFER FROM INDEX ON, IF GETCHAR FALSE THEN
|         WRITECHECKSUM AFTER EMPTYING THE BUFFER    *)
| 
|      VAR
|        I , J : INTEGER;
| 
| 
| 
|      BEGIN   (* FILLBUFFER *)
|        I := INDEX;
|        WHILE (I <= 2) AND (NOT EOF(INPUT))  DO
|          BEGIN
|          IF NOT GETCHAR(BUFFER(× I ×))
|             THEN BEGIN        (* WRITE BUFFER AND GET NEW ONE *)
|                  FOR J := 0 TO I-1  DO
|                      WRITECHAR ( BUFFER (/J/) );
|                  I := 0;
|                  WRITECHECKSUM;
|                  END
|             ELSE I := I + 1;
|          END;
|          IF EOF(INPUT)         (* CLEAN THE BUFFER *)
|             THEN FOR J := 0 TO I DO
|                      WRITECHAR( BUFFER(/0/) )
|             ELSE;
| 
|      END;             (* FILLBUFFER *)
| 
| 
|    PROCEDURE SENDDUPGROUP;
|      (* ACCUMULATE DUPLICATE CHARACTERS AND SEND ONE THREE CHARACTER
|         DUPLICATION GROUP *)
| 
|      VAR
|        NEWCHAR : CHAR;
|        COUNT : INTEGER;
|        DIFFERENT : BOOLEAN;
|        ENDLINE : BOOLEAN;
|        IND : INTEGER;
| 
|      BEGIN                    (* SENDDUPGROUP *)
|        ENDLINE := FALSE;
|        COUNT := 3;       (* ONLY CALLED WHEN 3 DUPLICATES ALREADY *)
|        DIFFERENT := FALSE;
|        WHILE ( (NOT EOF (INPUT))   AND
|                (COUNT < 255)       AND
|                (NOT DIFFERENT) )             DO
|           BEGIN
|           IF NOT GETCHAR( BUFFER(×0×) )
|              THEN BEGIN
|                   DIFFERENT := TRUE;
|                   ENDLINE := TRUE
|                   END
|              ELSE BEGIN
|                   DIFFERENT := NOT (BUFFER (/0/) = BUFFER (/1/));
|                   END;
|           COUNT := COUNT + 1;
|           END;
| 
|        WRITECHAR(SPECIALCHAR1);
|        WRITECHAR( BUFFER(/1/) );
|        WRITECHAR( CHR(COUNT-1) );
|        IF ENDLINE
|           THEN BEGIN
|                WRITECHECKSUM;
|                IND := 0;
|                END
|           ELSE IND := 1;
|        FILLBUFFER(IND)
|        END;       (* PROCDUPE *)
| 
| 
| 
|    PROCEDURE PROCCHAR;
| 
|      (* THIS PROCEDURE WRITES OUT THE FIRST ELEMENT OF BUFFER, SHIFTS
|         THE REST AND READS IN THE LAST ELEMENT OF BUFFER.
|         IT ALSO DETECTS OCCURRENCES OF SPECIALCHAR1 AND 2 AND WRITES
|         THEM OUT CORRECTLY.              *)
| 
| 
| 
| 
| 
|      BEGIN
|        IF (BUFFER (/0/) = SPECIALCHAR1)   OR
|           (BUFFER (/0/) = SPECIALCHAR2)
|           THEN BEGIN    (* WRITE SPECIAL CHARACTERS *)
|                WRITECHAR (SPECIALCHAR1);
|                WRITECHAR ( BUFFER(/0/) );
|                WRITECHAR ( CHR(1) );
|                END
|           ELSE WRITECHAR ( BUFFER(/0/) );
| 
|       BUFFER (/0/) := BUFFER (/1/);     (* SHIFT *)
|       BUFFER (/1/) := BUFFER (/2/);
|       FILLBUFFER(2)
| 
|       END;          (* PROCCHAR *)
| 
| 
| 
| 
|    BEGIN     (* COMPRESS *)
|                                    (* INITIALIZATION *)
|      INCOUNT := 0;
|      CHECKSUM := 0;
|      OUTCOUNT := 0;
|      INLINE := 0;
|      TYPECODE := ' ';   (* SET TO BLANK UNTIL PROPERLY IMPLEMENTED *)
|      SPECIALCHAR1 := CHR(251);  (* UNUSED IN ASCII AND EBCDIC *)
|      SPECIALCHAR2 := CHR(252);   (* UNUSED IN ASCII AND EBCDIC *)
|      REWRITE (QRR);
|      FILLBUFFER (0);
|      WRITECHAR (SPECIALCHAR1);    (* THIS ALLOWS THE EXPAND PROGRAM *)
|      WRITECHAR (SPECIALCHAR2);    (* TO BE SELF CALIBRATING  *)
|      WRITECHAR (TYPECODE);
|      WHILE NOT EOF(INPUT)  DO
|        IF (BUFFER (/0/) = BUFFER (/1/)) AND
|           (BUFFER (/0/) = BUFFER (/2/))
|           THEN SENDDUPGROUP
|           ELSE PROCCHAR;
| 
|      IF OUTCOUNT = 0
|         THEN (* BY CHANCE WE JUST SENT OUT A CHECKSUM *)
|         ELSE WRITECHECKSUM;
|      WRITECHAR (SPECIALCHAR1);
|      WRITECHAR (SPECIALCHAR1);
|      WRITECHAR ( CHR(0) );  WRITELN(QRR);
|      WRITELN (OUTPUT, ' **** COMPRESS ****');
|      WRITELN (OUTPUT, ' NUMBER OF CHARACTERS INPUT : ', INCOUNT:10);
|      WRITELN (OUTPUT, ' NUMBER OF LINES INPUT :      ', INLINE:10);
|      WRITELN (OUTPUT, ' NUMBER OF CHARACTERS OUTPUT : ', OUTCOUNT:9);
|      END.
| 
> Member ED
|  program ed(output);
|  (* software tools editor translated into PASCAL *)
| 
| (* Notes:                                                         *)
| (* 1) Program now runs under ORVYL/370 on SLAC's 370/168          *)
| (* 2) We did not change (much) more than was necessary to get it  *)
| (*    running.                                                    *)
| (* 3) Open and terminal I/O are done through external subroutines.*)
| (* 4) The character set is EBCDIC, which may explain some things  *)
| (*    in the program.                                             *)
| (*             -- M Powell, SLAC Computation Research Group, 1979 *)
| 
|  const
|    (* global flags *)
|    (* constant definitons *)
|    ARB = 100;
|    MAXCARD = 163;
|    MAXLINE = 165;
|    MAXPACK = 165;
|    MAXNAME = 30;
|    MAXTOK = 200;
|    MAXDEF = 200;
|    MAXSYMBOL = 10;
|    ASSGSTRSIZE = 163;
| 
|    LETTER = 1;
|    DIGIT = 2;
| 
|    ESCAPE = '@';
|    BANG = '!';
|    CFLEX = 'Ö';
|    TILDE = '^';
|    BOL = '%';
|    ANY = '?';
|    EOL = '$';
|    CLOSURE = '*';
|    AMPER = '&';
| (* DITTO = chr(1); *)
|    CCL = '[';
|    CCLEND = ']';
|    NCCL = 'n';
|    CHARA = 'a';
|    (* constants for pattern routines *)
|    COUNT = 1;
|    PREVCL = 2;
|    START = 3;
|    CLOSIZE = 4;
| 
|    MAXPAT = MAXLINE;  (* must be same due to parameter passing *)
|    GLOBAL = 'g';
|    PRINT = 'p';
|    LIST = 'l';
|    FORW = 0;
|    BACK = -1;
|    EXCLUDE = 'x';
|    APPENDCOM = 'a';
|    BLOCK = 'b';
|    CHANGE = 'c';
|    DELCOM = 'd';
|    ENTER = 'e';
|    PRINTFILE = 'f';
|    READCOM = 'r';
|    WRITECOM = 'w';
|    INSERT = 'i';
|    PRINTCUR = '=';
|    MOVECOM = 'm';
|    QUIT = 'q';
|    SUBSTITUTE = 's';
|    QUERY = '?';
|    CURLINE = '.';
|    LASTLINE = '$';
|    SCAN = '/';
|    BACKSCAN = '\';
|    PERIOD = '.';
|    NEWLINE = '
';
|    PLUS = '+';
|    MINUS = '-';
|    DASH = '-';
|    COMMA = ',';
|    SEMICOL = ';';
|    DIG0 = '0';
|    DIG7 = '7';
|    DIG9 = '9';
|    BLANK = ' ';
|    LETA = 'a';
|    LETN = 'n';
|    LETT = 't';
| (* TAB = chr(9); *)
|    DIRIN = 0;
|    DIROUT = 1;
| 
| type
|    (* global type declarations *)
|    lineString = array [1..MAXLINE] of char;
|    argString = lineString;
|    lineLength = 0..MAXLINE;
|    fileNameString = array [1..MAXNAME] of char;
|    patternString = array [1..MAXPAT] of char;
|    traceString = array [1..6] of char;
|    assignString = array [1..ASSGSTRSIZE] of char;
|    linePtr = @lineRec;
|    lineRec = record
|      next, prev : linePtr;
|      mark : boolean;
|      length : lineLength;
|      line : lineString;
|    end;
|    statusRange = (NOSTATUS, OKSTATUS, ERRSTATUS, EOFSTATUS, INTSTATUS);
| 
| var
|    (* constant variables *)
|    EOS, TAB, DITTO : char;
|    LINE0 : linePtr;
|    ONE, ZERO : integer;
|    (* global variable definitions *)
|    terminopen : boolean;
|    freeList : linePtr;
|    n0 : integer;
|    k0 : linePtr;
|    line1, line2, nlines, curln, cursav, lastln : integer;
|    increment : integer;
|    pat : patternString;
|    txt : lineString;
|    pak : array [1..MAXPACK] of char;
|    lpak : integer;
|    savfil : array [1..MAXNAME] of char;
|    status : statusRange;
|    lin : lineString;
|    i : integer;
|    glob : boolean;
|    termin, termout, filex : text;
| (*******************************************************************)
| 
| (***************)
| (* subroutines *)
| (***************)
| 
| (* a debugging routine *)
|    (* etrace - trace status of edit *)
|    procedure etrace(traceName : traceString);
|    begin
|      (*writeln(debug,traceName,':   i=',i,',  s=',ord(status),
|          ',  g=',glob);*)
|    end;
| 
| (* miscellaneous i/o routines *)
|    (* readline - reads a line *)
|    procedure readline(var filex : text; var lin : lineString;
|        var lineLen : integer);
|    var
|      i : integer;
|    begin
|      if not eof(filex) then begin
|        i := 1;
|        while not eoln(filex) and not eof(filex) do begin
|          lin[i] := filex@;
|          get(filex);
|          i := i + 1;
|        end;
|        readln(filex);
|        lineLen := i-1;
|        lin[i] := EOS;
|      end
|      else begin
|        lineLen := -1;
|        lin[1] := EOS;
|      end;
|    end;
| 
|    (* intrpt - indicate a user attempt to interrupt *)
|    function intrpt(var x : integer) : boolean; fortran;
| 
|    (* readcmd - read a line from the terminal *)
|    function readcmd(var lin : lineString; promptCh : char) : boolean;
|    const
|      MAXPROMPT = 163;
|    type
|      promptString = array [1..MAXPROMPT] of char;
|      promptRec = record
|        len : integer;
|        str : promptString;
|      end;
|    var
|      i : integer;
|      len, ret, readlen : integer;
|      prompt : promptRec;
|      function readterm(var lin : lineString; var len : integer;
|          var prompt : promptRec; var readlen : integer) : integer; fortran;
|    begin
|      (* read from the terminal *)
|      readcmd := TRUE;
|      repeat
|        prompt.len := 1;
|        prompt.str[1] := promptCh;
|        len := MAXLINE-2;
|        ret := readterm(lin,len,prompt,readlen);
|        if (ret = 4) and (readlen = 1) and (lin[1] = '@') then begin
|          ret := 0;
|          readcmd := FALSE;
|        end;
|      until ret = 0;
|      lin[readlen+1] := NEWLINE;
|      lin[readlen+2] := EOS;
|    end;
| 
|    (* assign - external function to assign a file *)
|    function assign(var str : assignString) : integer; fortran;
| 
|    (* open - opens a file using uram *)
|    function open(fileName : fileNameString; dir : integer) : integer;
|    var
|    assgStr : assignString;
|      tempStr6 : array [1..6] of char;
|      tempStr9 : array [1..9] of char;
|      tempStr21 : array [1..21] of char;
|      i : integer;
|    begin
|    (* clean up file name *)
|    i := 1;
|    while fileName[i] <> EOS do begin
|      if (fileName[i] >= 'a') and (fileName[i] <= 'z') then
|        fileName[i] := chr(ord(fileName[i])+ord('A')-ord('a'));
|      i := i + 1;
|    end;
|    for i := i to MAXNAME do fileName[i] := ' ';
|      tempStr21 := 'ASSIGN FILEX TO FILE ';
|      tempStr9 := ' RECFM=E ';
|      if dir = DIRIN then tempStr6 := 'INPUT '
|      else if dir = DIROUT then tempStr6 := 'OUTPUT'
|      else tempStr6 := '??????';
|      (* build up string *)
|      for i := 1 to 21 do assgStr[i] := tempStr21[i];
|      for i := 22 to 51 do assgStr[i] := fileName[i-21];
|      for i := 52 to 60 do assgStr[i] := tempStr9[i-51];
|      for i := 61 to 66 do assgStr[i] := tempStr6[i-60];
|      assgStr[67] := ';';
|      i := assign(assgStr);
|      if i = 0 then begin
|        if dir = DIRIN then reset(filex)
|        else if dir = DIROUT then rewrite(filex);
|      end
|      else writeln(output,'assign error',i);
|      open := i;
|    end;
| 
|    (* ctoi - convert character to integer *)
|    function ctoi(lin : lineString; var i : integer) : integer;
|    var
|      temp : integer;
|    begin
|      temp := 0;
|      while (lin[i] >= DIG0) and (lin[i] <= DIG9) do begin
|        temp := temp * 10 + ord(lin[i]) - ord(DIG0);
|        i := i + 1;
|      end;
|      ctoi := temp;
|    end;
| (* string manipulation routines *)
| 
|    (* addset - put c in str[j] if it fits. increment j *)
|    function addset(c : char; var str : lineString; var j : integer;
|        maxsiz : integer) : boolean;
|    begin
|      if j > maxsiz then addset := FALSE
|      else begin
|        str[j] := c;
|        j := j + 1;
|        addset := TRUE;
|      end;
|    end;
| 
|    (* esc - map str[i] into escaped character if appropriate *)
|    function esc(str : lineString; var i : integer) : char;
|    label 1;
|    var
|      temp, j : integer;
|    begin
|      if str[i] <> ESCAPE then esc := str[i]
|      else if str[i+1] = EOS then esc := ESCAPE (* not special at end *)
|      else begin
|        i := i + 1;
|        if str[i] = LETN then esc := NEWLINE
|        else if str[i] = LETT then esc := TAB
|        else if (str[i] >= DIG0) and (str[i] <= DIG7) then begin
|          temp := 0;
|          for j := 1 to 3 do begin
|            if (str[i] < DIG0) or (str[i] > DIG7) then goto 1;
|            temp := temp * 8 + ord(str[i]) - ord(DIG0);
|            i := i + 1;
|          end;
|        1:
|          esc := chr(temp);
|          i := i - 1;
|        end
|        else esc := str[i];
|      end;
|    end;
| 
|    (* filset - expand set at lin[i] into str[j] *)
|    procedure filset(delim : char; lin : lineString; var i : integer;
|        var str : lineString; var j : integer; maxstr : integer);
|    var
|      limit, k : char;
|      junk : boolean;
|    begin
|      while (lin[i] <> delim) and (lin[i] <> EOS) do begin
|        if lin[i] = ESCAPE then
|          junk := addset(esc(lin,i),str,j,maxstr)
|        else if lin[i] <> DASH then
|          junk := addset(lin[i],str,j,maxstr)
|        else if (j <= 1) or (lin[i] = EOS) then
|          junk := addset(DASH,str,j,maxstr)  (* literal - *)
|        else begin
|          i := i + 1;
|          j := j - 1;
|          limit := esc(lin,i);
|          for k := str[j] to limit do
|            junk := addset(k,str,j,maxstr);
|        end;
|        i := i + 1;
|      end;
|    end;
| 
| (* pattern matching subroutines *)
| 
|    (* dumppat - print a pattern, starting at j *)
|    procedure dumppat(pat : patternString; j : integer);
|    var p, i : integer;
|    begin
|      p := j;
|      write(output,'[');
|      while pat[p] <> EOS do begin
|        case pat[p] of
|          BOL : write(output,'<bol>');
|          EOL : write(output,'<eol>');
|          ANY : write(output,'<any>');
|          CHARA : begin write(output,'<char><',pat[p+1],'>'); p := p + 1; end;
|          CLOSURE : begin
|            write(output,'<clos><',ord(pat[p+1]):1,'><',ord(pat[p+2]):1,
|              '><',ord(pat[p+3]):1,'>');
|            p := p + 3;
|          end;
|          CCL, NCCL : begin
|            if pat[p] = CCL then write(output,'<ccl>')
|            else write(output,'<nccl>');
|            write(output,'<',ord(pat[p+1]):1,'><');
|            for i := 1 to ord(pat[p+1]) do write(output,pat[p+1+i]);
|            write(output,'>');
|            p := p + 1 + ord(pat[p+1]);
|          end;
|        end;
|        p := p + 1;
|      end;
|      writeln(output,']');
|    end;
| 
|    (* patsiz - returns size of the pattern entry at pat[n] *)
|    function patsiz(pat : patternString; n : integer) : integer;
|    begin
|      if pat[n] = CHARA then patsiz := 2
|      else if (pat[n] = BOL) or (pat[n] = EOL) or (pat[n] = ANY) then
|        patsiz := 1
|      else if (pat[n] = CCL) or (pat[n] = NCCL) then
|        patsiz := ord(pat[n+COUNT]) + 2
|      else if pat[n] = CLOSURE then patsiz := CLOSIZE
|      else writeln(termout,'patsize: impossible');
|    end;
| 
|    (* locate - look for c in char class at pat[offset] *)
|    function locate(c : char; pat : patternString; offset : integer) : boolean;
|    label 1;
|    var
|      i : integer;
|    begin
|      locate := FALSE;
|      for i := offset + ord(pat[offset]) downto offset + 1 do begin
|        if c = pat[i] then begin
|          locate := TRUE;
|          goto 1;
|        end;
|      end;
|    1:
|    end;
| 
|    (* omatch - try to match a single pattern at pat[j] *)
|    function omatch(lin : lineString; var i : integer; pat : patternString;
|        j : integer) : boolean;
|    var
|      bump : integer;
|    begin
|      omatch := FALSE;
|      if lin[i] <> EOS then begin
|        bump := -1;
|        if pat[j] = CHARA then begin
|          if lin[i] = pat[j+1] then bump := 1;
|        end
|        else if pat[j] = BOL then begin
|          if i = 1 then bump := 0;
|        end
|        else if pat[j] = ANY then begin
|          if lin[i] <> NEWLINE then bump := 1;
|        end
|        else if pat[j] = EOL then begin
|          if lin[i] = NEWLINE then bump := 0;
|        end
|        else if pat[j] = CCL then begin
|          if locate(lin[i],pat,j+1) then bump := 1;
|        end
|        else if pat[j] = NCCL then begin
|          if lin[i] <> NEWLINE then
|            if not locate(lin[i],pat,j+1) then bump := 1;
|        end
|        else begin
|          writeln(termout,'omatch: impossible');
|        end;
|        if bump >= 0 then begin
|          i := i + bump;
|          omatch := TRUE;
|        end;
|      end;
|    end;
| 
| 
|    (* amatch (non-recursive) - look for match starting at lin[from] *)
|    function amatch(lin : lineString; from : integer; var pat : patternString)
|        : integer;
|    label 1, 2, 3;
|    var
|      i, j, offset, stack : integer;
|    begin
|      stack := 0;
|      offset := from;
|      j := 1;
|      while pat[j] <> EOS do begin
|        if pat[j] = CLOSURE then begin
|          stack := j;
|          j := j + CLOSIZE;
|          i := offset;
|          while lin[i] <> EOS do
|            if not omatch(lin,i,pat,j) then goto 1;
|        1:
|          pat[stack+COUNT] := chr(i-offset);
|          pat[stack+START] := chr(offset);
|          offset := i;
|        end
|        else if not omatch(lin,offset,pat,j) then begin (* non-closure *)
|          while stack > 0 do begin
|            if ord(pat[stack+COUNT]) > 0 then goto 2;
|            stack := ord(pat[stack+PREVCL]);
|          end;
|        2:
|          if stack <= 0 then begin
|            offset := 0;
|            goto 3;
|          end;
|          pat[stack+COUNT] := chr(ord(pat[stack+COUNT]) - 1);
|          j := stack + CLOSIZE;
|          offset := ord(pat[stack+START]) + ord(pat[stack+COUNT]);
|        end;
|        (* else omatch succeeded *)
|        j := j + patsiz(pat,j);
|      end;
|    3:
|      amatch := offset;
|    end;
| 
|    (* match - find match anywhere on line *)
|    function match(lin : lineString; var pat : patternString) : boolean;
|    var
|      i : integer;
|      result : boolean;
|    begin
|      i := 1;
|      result := FALSE;
|      while (lin[i] <> EOS) and not result do begin
|        result := amatch(lin,i,pat) > 0;
|        i := i + 1;
|      end;
|      match := result;
|    end;
| 
|    (* stclos - insert closure entry at pat[j] *)
|    function stclos(var pat : patternString; var j, lastj, lastcl : integer)
|        : integer;
|    var
|      jp, jt : integer;
|      junk : boolean;
|    begin
|      for jp := j-1 downto lastj do begin
|        jt := jp + CLOSIZE;
|        junk := addset(pat[jp],pat,jt,MAXPAT);
|      end;
|      j := j + CLOSIZE;
|      stclos := lastj;
|      junk := addset(CLOSURE,pat,lastj,MAXPAT);  (* put closure in it *)
|      junk := addset(chr(0),pat,lastj,MAXPAT); (* COUNT *)
|      junk := addset(chr(lastcl),pat,lastj,MAXPAT); (* PREVCL *)
|      junk := addset(chr(0),pat,lastj,MAXPAT); (* START *)
|    end;
| 
|    (* getccl - expand character class at arg[i] into pat[j] *)
|    function getccl(arg : argString; var i : integer; var pat : patternString;
|        var j : integer) : boolean;
|    var
|      junk : boolean;
|      jstart : integer;
|    begin
|      i := i + 1;
|      if (arg[i] = BANG) or (arg[i] = CFLEX) or (arg[i] = TILDE) then begin
|        junk := addset(NCCL,pat,j,MAXPAT);
|        i := i + 1;
|      end
|      else junk := addset(CCL,pat,j,MAXPAT);
|      jstart := j;
|      junk := addset(chr(0),pat,j,MAXPAT); (* leave room for count *)
|      filset(CCLEND,arg,i,pat,j,MAXPAT);
|      pat[jstart] := chr(j-jstart-1);
|      getccl := arg[i] = CCLEND;
|    end;
| 
|    (* makpat - make pattern from arg[from], terminate at delim *)
|    function makpat(arg : argString; from : integer; delim : char;
|        var pat : patternString) : integer;
|    label 1;
|    var
|      i, j, lastcl, lastj, lj : integer;
|      junk : boolean;
|    begin
|      j := 1;  (* pat index *)
|      lastj := 1;
|      lastcl := 0;
|      i := from;
|      while (arg[i] <> delim) and (arg[i] <> EOS) do begin
|        lj := j;
|        if arg[i] = ANY then junk := addset(ANY,pat,j,MAXPAT)
|        else if (arg[i] = BOL) and (i = from) then
|          junk := addset(BOL,pat,j,MAXPAT)
|        else if (arg[i] = EOL) and (arg[i+1] = delim) then
|          junk := addset(EOL,pat,j,MAXPAT)
|        else if arg[i] = CCL then begin
|          if not getccl(arg,i,pat,j) then goto 1;
|        end
|        else if (arg[i] = CLOSURE) and (i > from) then begin
|          lj := lastj;
|          if (pat[lj] = BOL) or (pat[lj] = EOL) or (pat[lj] = CLOSURE) then
|            goto 1;
|          lastcl := stclos(pat,j,lastj,lastcl);
|        end
|        else begin
|         junk := addset(CHARA,pat,j,MAXPAT);
|         junk := addset(esc(arg,i),pat,j,MAXPAT);
|        end;
|        lastj := lj;
|        i := i + 1;
|      end;
|    1:
|      if arg[i] <> delim then makpat := -1 (* error making pattern *)
|      else if not addset(EOS,pat,j,MAXPAT) then makpat := -1 (* no room *)
|      else makpat := i;
|    end;
| 
| (* string substitution routines *)
| 
|    (* catsub - add replacement text to end of str *)
|    procedure catsub(lin : lineString; f, t : integer; sub : patternString;
|        var str : lineString; var k : integer; maxnew : integer);
|    var
|      i, j : integer;
|      junk : boolean;
|    begin
|      (*writeln(debug,'catsub',f,t);*)
|      (*writeln(debug,lin:20);*)
|      (*writeln(debug,sub:20);*)
|      i := 1;
|      while sub[i] <> EOS do begin
|        if sub[i] = DITTO then begin
|          for j := f to t-1 do junk := addset(lin[j],str,k,maxnew);
|        end
|        else junk := addset(sub[i],str,k,maxnew);
|        i := i + 1;
|      end;
|    end;
| 
|    (* maksub - make substitution string in sub *)
|    function maksub(arg : argString; f : integer; delim : char;
|        var sub : patternString) : integer;
|    var
|      i, j : integer;
|      junk : boolean;
|    begin
|      j := 1;
|      i := f;
|      while (arg[i] <> delim) and (arg[i] <> EOS) do begin
|        if arg[i] = AMPER then junk := addset(DITTO,sub,j,MAXPAT)
|        else junk := addset(esc(arg,i),sub,j,MAXPAT);
|        i := i + 1;
|      end;
|      if arg[i] <> delim then
|        maksub := -1  (* error - missing delimiter *)
|      else if not addset(EOS,sub,j,MAXPAT) then
|        maksub := -1  (* error - no room *)
|      else maksub := i;
|    end;
| 
| (* line manipulating routines *)
| 
| 
|    (* nextln - get line after "line" *)
|    function nextln(line : integer) : integer;
|    var
|      result : integer;
|    begin
|      result := line + 1;
|      if result > lastln then result := 0;
|      nextln := result;
|    end;
| 
|    (* prevln - get line before "line" *)
|    function prevln(line : integer) : integer;
|    var
|      result : integer;
|    begin
|      result := line - 1;
|      if result < 0 then result := lastln;
|      prevln := result;
|    end;
| 
|    (* linkup - make line k2 follow line k1 *)
|    procedure linkup(k1, k2 : linePtr);
|    begin
|      k1@.next := k2;
|      k2@.prev := k1;
|      (* reset line cache *)
|      n0 := 0;
|      k0 := LINE0;
|    end;
| 
|    (* alloline - allocate a line record *)
|    function alloline : linePtr;
|    var
|      result : linePtr;
|    begin
|      if freeList = NIL then new(result)
|      else begin
|        result := freeList;
|        freeList := freeList@.next;
|      end;
|      result@.next := NIL;
|      result@.prev := NIL;
|      result@.mark := FALSE;
|      alloline := result;
|    end;
| 
|    (* freeline - release a line record *)
|    procedure freeline(var linep : linePtr);
|    begin
|      linep@.next := freeList;
|      freeList := linep;
|    end;
| 
|    (* getind - locate line index in buffer *)
|    function getind(line : integer) : linePtr;
|    var
|      d, d0, n1 : integer;
|    begin
|      (*writeln(debug,'getind',line);*)
|      n1 := lastln + 1;
|      d0 := line;
|      (* d := min(d0,n1-d0,abs(d0-n0)); *)
|      d := d0;
|      if n1-d0 < d then d := n1-d0;
|      if abs(d0-n0) < d then d := abs(d0-n0);
|      (*writeln(debug,d0,n1-d0,abs(d0-n0));*)
|      if d = d0 then begin (* go forward from LINE0 *)
|        n0 := 0;
|        k0 := LINE0;
|      end
|      else if d = n1-d0 then begin (* go backwards from LINE0 *)
|        n0 := n1;
|        k0 := LINE0;
|      end;
|      (*writeln(debug,'search',n0,' ',k0@.line:k0@.length);*)
|      while n0 > d0 do begin  (* search backward *)
|      (*writeln(debug,'back');*)
|        k0 := k0@.prev;
|        n0 := n0 - 1;
|      (*writeln(debug,'search',n0,' ',k0@.line:k0@.length);*)
|      end;
|      while n0 < d0 do begin  (* search forward *)
|      (*writeln(debug,'forw');*)
|        k0 := k0@.next;
|        n0 := n0 + 1;
|      (*writeln(debug,'search',n0,' ',k0@.line:k0@.length);*)
|      end;
|      getind := k0;
|      (*writeln(debug,'k0',ord(k0));*)
|    end;
| 
|    (* getpak - get packed text for line *)
|    function getpak(line : integer) : linePtr;
|    var
|      result : linePtr;
|    begin
|      (* this routine should do something more *)
|      (*writeln(debug,'getpak',line);*)
|      result := getind(line);
|      (*writeln(debug,'result',ord(result));*)
|      pak := result@.line;
|      lpak := result@.length;
|      (*writeln(debug,'pak=',pak:lpak,result@.line:result@.length);*)
|      getpak := result;
|    end;
| 
|    (* gettxt - locate text for a line *)
|    function gettxt(line : integer) : linePtr;
|    begin
|      (* this routine should do something more *)
|      (*writeln(debug,'gettxt');*)
|      gettxt := getpak(line);
|      txt := pak;
|      (*writeln(debug,'txt=pak?');*)
|      (*writeln(debug,pak:lpak);*)
|      (*writeln(debug,txt:lpak);*)
|      txt[lpak+1] := NEWLINE;
|      txt[lpak+2] := EOS;
|    end;
| 
|    (* injpak - insert packed line from pak after curln *)
|    function injpak(var sts : statusRange) : statusRange;
|    var
|      k1, k2, k3 : linePtr;
|    begin
|      (*writeln(debug,'injpak',curln,lpak,pak:lpak);*)
|      k1 := getind(curln);
|      k2 := k1@.next;
|      k3 := alloline;
|      k3@.line := pak;
|      k3@.length := lpak;
|      linkup(k1,k3);
|      linkup(k3,k2);
|      k1 := k3;
|      curln := curln + 1;
|      lastln := lastln + 1;
|      n0 := curln;
|      k0 := k1;
|      injpak := OKSTATUS;
|      sts := OKSTATUS;
|    end;
| 
|    (* inject - insert text from lin after curln *)
|    function inject(lin : lineString) : statusRange;
|    label 1, 2;
|    var
|      i, j : integer;
|      result : statusRange;
|    begin
|      (*writeln(debug,'inject',lin:20);*)
|      i := 1;
|      while lin[i] <> EOS do begin
|        j := i;
|        while lin[i] <> EOS do begin
|          i := i + 1;
|          if lin[i-1] = NEWLINE then goto 1;
|        end;
|      1:
|        if lin[i-1] = NEWLINE then begin
|          lin[i-1] := EOS;
|          (* move in line *)
|          lpak := 0;
|          repeat
|            lpak := lpak + 1;
|            pak[lpak] := lin[j+lpak-1];
|          until pak[lpak] = EOS;
|          lpak := lpak - 1;
|          lin[i-1] := NEWLINE;
|          if injpak(result) <> OKSTATUS then goto 2;
|        end;
|      end;
|      result := OKSTATUS;
|    2:
|      inject := result;
|    end;
| 
|    (* append lines after 'line' *)
|    function append(line:integer) : statusRange;
|    var
|      result : statusRange;
|      lin : lineString;
|    begin
|      etrace('append');
|      if glob then begin
|        result := ERRSTATUS;
|      end
|      else begin
|        curln := line;
|        result := NOSTATUS;
|        while result = NOSTATUS do begin
|          if not readcmd(lin,'*') then result := ERRSTATUS
|          else if (lin[1] = PERIOD) and (lin[2] = NEWLINE) then
|            result := OKSTATUS
|          else if inject(lin) = ERRSTATUS then result := ERRSTATUS;
|        end;
|      end;
|      append := result;
|    end;
| 
|    (* delete - delete lines "from" through "to" *)
|    function delete(fromLine, toLine : integer) : statusRange;
|    label 1;
|    var
|      number : integer;
|      k1, k2, k3 : linePtr;
|    begin
|      status := ERRSTATUS;
|      if fromLine > 0 then begin
|        status := INTSTATUS;
|        curln := prevln(fromLine);
|        k1 := getind(curln);
|        k2 := k1@.next;
|        for number := toLine-fromLine+1 downto 1 do begin
|          if intrpt(ONE) then goto 1;
|          k3 := k2@.next;
|          linkup(k1,k3);
|          freeline(k2);
|          lastln := lastln - 1;
|          k2 := k3;
|        end;
|        status := OKSTATUS;
|      1:
|        n0 := curln;
|        k0 := k1;
|      end;
|      delete := status;
|    end;
| 
|    (* clrbuf - initialize for new file *)
|    procedure clrbuf;
|    begin
|      (* perhaps this routine should do something *)
|    end;
| 
|    (* setbuf - initialize line buffer *)
|    procedure setbuf(initial : boolean);
|    var
|      junk : statusRange;
|    begin
|      if initial then begin
|        n0 := 0;
|        k0 := alloline;
|        k0@.next := k0;
|        k0@.prev := k0;
|        k0@.line[1] := 'L';
|        k0@.line[2] := 'I';
|        k0@.line[3] := 'N';
|        k0@.line[4] := 'E';
|        k0@.line[5] := '0';
|        k0@.length := 5;
|        lastln := 0;
|        LINE0 := k0;
|      end;
|      junk := delete(1,lastln);
|    end;
| 
| (* command interpretation routines *)
| 
| 
|    (* ckp - check for 'p' after command *)
|    function ckp(var pflag : char) : statusRange;
|    begin
|      etrace('   ckp');
|      if lin[i] = PRINT then begin
|        i := i + 1;
|        pflag := PRINT;
|      end
|      else if lin[i] = LIST then begin
|        i := i + 1;
|        pflag := LIST;
|      end
|      else pflag := BLANK;
|      if lin[i] = NEWLINE then status := OKSTATUS
|      else status := ERRSTATUS;
|      ckp := status;
|    end;
| 
|    (* defalt - set defaulted line numbers *)
|    function defalt(def1, def2 : integer) : statusRange;
|    begin
|      etrace('defalt');
|      if nlines = 0 then begin;
|        line1 := def1;
|        line2 := def2;
|      end;
|      if (line1 > line2) or (line1 <= 0) then status := ERRSTATUS
|      else status := OKSTATUS;
|      defalt := status;
|    end;
| 
|    (* skipbl - skip blanks and tabs at lin[i] *)
|    procedure skipbl;
|    begin
|      while (lin[i] = BLANK) or (lin[i] = TAB) do i := i + 1;
|    end;
| 
|    (* getfn - get file name from lin[i] *)
|    function getfn(var fileName : fileNameString) : statusRange;
|    var
|      result : statusRange;
|      k : integer;
|    begin
|      etrace(' getfn');
|      result := ERRSTATUS;
|      if lin[i] = BLANK then begin
|        (* get new file name *)
|        i := i + 1;
|        skipbl;
|        k := 1;
|        while lin[i] <> NEWLINE do begin
|          if k < MAXNAME then begin
|            fileName[k] := lin[i];
|            k := k + 1;
|          end;
|          i := i + 1;
|        end;
|        fileName[k] := EOS;
|        if k > 1 then result := OKSTATUS;
|      end
|      else if (lin[i] = NEWLINE) and (savfil[1] <> EOS) then begin
|        fileName := savfil;
|        result := OKSTATUS;
|      end;
|      (* else error *)
|      if (result = OKSTATUS) and (savfil[1] = EOS) then
|        savfil := fileName; (* if no old name, save new one *)
|      getfn := result;
|    end;
| 
|    (* ptscan - scan for next occurrence of pattern *)
|    function ptscan(way : integer; var num0 : integer) : statusRange;
|    label 1;
|    var
|      num : integer;
|      k : linePtr;
|    begin
|      etrace('ptscan');
|      num := curln;
|      ptscan := INTSTATUS;
|      repeat
|        if intrpt(ONE) then goto 1;
|        if way = FORW then num := nextln(num)
|        else num := prevln(num);
|        k := gettxt(num);
|        if match(txt,pat) then begin
|          num0 := num;
|          ptscan := OKSTATUS;
|          goto 1;
|        end;
|      until num = curln;
|      ptscan := ERRSTATUS;
|    1:
|    end;
| 
|    (* optpat - make pattern if specified at lin[i] *)
|    procedure optpat;
|    var
|      j : integer;
|      delim : char;
|    begin
|      etrace('optpat');
|      status := ERRSTATUS;
|      if lin[i] <> EOS then begin
|        delim := lin[i];
|        i := i + 1;
|        if (lin[i] = delim) and (pat[1] <> EOS) then
|          status := OKSTATUS   (* use old pattern *)
|        else if lin[i] <> EOS then begin
|          j := makpat(lin,i,delim,pat);
|          if j > 0 then begin
|            i := j;
|            status := OKSTATUS;
|          end
|          else pat[1] := EOS;
|        end;
|      end;
|    end;
| 
|    (* getnum - convert one term to line number *)
|    function getnum(var pnum : integer) : statusRange;
|    var
|      result : statusRange;
|    begin
|      etrace('getnum');
|      result := OKSTATUS;
|      if (lin[i] >= DIG0) and (lin[i] <= DIG9) then
|        pnum := ctoi(lin,i)
|      else if lin[i] = CURLINE then begin
|        pnum := curln;
|        i := i + 1;
|      end
|      else if lin[i] = LASTLINE then begin
|        pnum := lastln;
|        i := i + 1;
|      end
|      else if (lin[i] = SCAN) or (lin[i] = BACKSCAN) then begin
|        optpat;  (* build pattern *)
|        if status = ERRSTATUS then result := ERRSTATUS
|        else if lin[i] = SCAN then begin
|          getnum := ptscan(FORW,pnum);
|          i := i + 1;
|        end
|        else begin
|          getnum := ptscan(BACK,pnum);
|          i := i + 1;
|        end;
|      end
|      else result := EOFSTATUS;
|      status := result;
|      getnum := result;
|      etrace('gotnum');
|    end;
| 
|    (* getone - evaluate one line number expression *)
|    function getone(var num0 : integer) : statusRange;
|    label 1;
|    var
|      istart, mul, num, pnum : integer;
|      result : statusRange;
|    begin
|      etrace('getone');
|      istart := i;
|      num := 0;
|      skipbl;
|      if (lin[i] = PLUS) or (lin[i] = MINUS) then begin
|        num := curln;
|        status := OKSTATUS;
|      end
|      else status := getnum(num);
|      while status = OKSTATUS do begin
|        skipbl;
|        if lin[i] = PLUS then mul := +1
|        else if lin[i] = MINUS then mul := -1
|        else begin
|          status := EOFSTATUS;
|          goto 1;
|        end;
|        i := i + 1;
|        skipbl;
|        if getnum(pnum) = OKSTATUS then num := num + mul * pnum
|        else if status = EOFSTATUS then begin
|          num := num + mul;
|          status := OKSTATUS;
|        end;
|      end;
|    1:
|      if (status = ERRSTATUS) or (status = INTSTATUS) then result := status
|      else if (num < 0) or (num > lastln) then result := ERRSTATUS
|      else if i <= istart then result := EOFSTATUS
|      else result := OKSTATUS;
|      num0 := num;
|      status := result;
|      getone := result;
|      etrace('gotone');
|    end;
| 
|    (* getlst - collect line numbers (if any) at lin[i] *)
|    procedure getlst;
|    label 1;
|    var
|      num : integer;
|    begin
|      etrace('getlst');
|      line2 := 0;
|      nlines := 0;
|      while getone(num) = OKSTATUS do begin
|        line1 := line2;
|        line2 := num;
|        nlines := nlines + 1;
|        if (lin[i] <> COMMA) and (lin[i] <> SEMICOL) then goto 1;
|        if lin[i] = SEMICOL then curln := num;
|        i := i + 1;
|      end;
|    1:
|      if nlines > 2 then nlines := 2;
|      if nlines = 0 then line2 := curln;
|      if nlines <= 1 then line1 := line2;
|      if status = EOFSTATUS then status := OKSTATUS;
|      etrace('gotlst');
|      (*writeln(debug,line1,line2,nlines);*)
|    end;
| 
|    (* getrhs - get substitution string for "s" command *)
|    function getrhs(var sub : patternString; var gflag : boolean) : statusRange;
|    var
|      delim : char;
|      j : integer;
|      result : statusRange;
|    begin
|      etrace('getrhs');
|      result := ERRSTATUS;
|      gflag := FALSE;
|      if lin[i] <> EOS then begin
|        delim := lin[i];
|        i := i + 1;
|        if lin[i] <> EOS then begin
|          j := maksub(lin,i,delim,sub);
|          if j > 0 then begin
|            i := j + 1;
|            if lin[i] = GLOBAL then begin
|              i := i + 1;
|              gflag := TRUE;
|            end;
|            result := OKSTATUS;
|          end;
|        end;
|      end;
|      status := result;
|      getrhs := result;
|    end;
| 
| (* command routines *)
| 
| 
|    (* dolist - print lines fromLine through toLine with all chars visible *)
|    function dolist(fromLine, toLine : integer) : statusRange;
|    label 1;
|    var
|      line, k, m : integer;
|      j : linePtr;
|      ch : char;
|      numb : array [1..2] of char;
|      junk : integer;
|    begin
|      dolist := ERRSTATUS;
|      if fromLine > 0 then begin
|        dolist := INTSTATUS;
|        for line := fromLine to toLine do begin
|          if intrpt(ONE) then goto 1;
|          j := gettxt(line);
|          k := 1;
|          while txt[k] <> NEWLINE do begin
|            ch := txt[k];
|            if (ch=' ')or((ch>='Ö')and(ch<='&'))or((ch>='!')and(ch<='/'))
|              or((ch>=',')and(ch<='?'))or((ch>='`')and(ch<='#'))
|              or((ch>='''')and(ch<='"'))or((ch>='a')and(ch<='i'))
|              or((ch>='j')and(ch<='r'))or((ch>='s')and(ch<='z'))
|              or(ch='¯')or(ch='ò')or(ch='[')or(ch=']')or(ch='\')
|              or((ch>='A')and(ch<='I'))or((ch>='J')and(ch<='R'))
|              or((ch>='S')and(ch<='Z'))or((ch>='0')and(ch<='9')) then
|              write(termout,ch)
|            else begin
|              if ch = ESCAPE then write(termout,ESCAPE,ESCAPE)
|              else if ch = NEWLINE then write(termout,ESCAPE,LETN)
|              else if ch = TAB then write(termout,ESCAPE,LETT)
|              else begin
|                m := ord(ch) mod 16;
|                if m > 9 then numb[2] := chr(m-10+ord(LETA))
|                else numb[2] := chr(m+ord(DIG0));
|                m := ord(ch) div 16;
|                if m > 9 then numb[1] := chr(m-10+ord(LETA))
|                else numb[1] := chr(m+ord(DIG0));
|                write(termout,ESCAPE,numb);
|              end;
|            end;
|            k := k + 1;
|          end;
|          writeln(termout);
|          curln := line;
|        end;
|        dolist := OKSTATUS;
|      end;
|    1:
|    end;
| 
|    (* doprnt - print lines fromLine through toLine *)
|    function doprnt(fromLine, toLine : integer) : statusRange;
|    label 1;
|    var
|      line : integer;
|      j : linePtr;
|    begin
|      (*writeln(debug,'doprnt');*)
|      doprnt := ERRSTATUS;
|      if fromLine > 0 then begin
|        doprnt := INTSTATUS;
|        for line := fromLine to toLine do begin
|          if intrpt(ONE) then goto 1;
|          j := gettxt(line);
|          writeln(termout,txt:lpak);
|          (*writeln(debug,'txt=',txt:lpak);*)
|          curln := line;
|        end;
|        doprnt := OKSTATUS;
|      end;
|    1:
|    end;
| 
|    (* doread - read 'file' after 'line' *)
|    function doread(line : integer; fileName : fileNameString) : statusRange;
|    label 1;
|    var
|      errNum, number : integer;
|      result : statusRange;
|    begin
|      result := ERRSTATUS;
|      errNum := open(fileName,DIRIN);
|      if errNum = 0 then begin
|        result := OKSTATUS;
|        curln := line;
|        for number := 0 to MAXINT do begin
|          if intrpt(ONE) then begin
|            result := INTSTATUS;
|            goto 1;
|          end;
|          readline(filex,pak,lpak);
|          if lpak < 0 then goto 1;
|          if injpak(result) <> OKSTATUS then goto 1;
|        end;
|      1:
|        reset(filex);
|        writeln(termout,number:1);
|      end;
|      doread := result;
|    end;
| 
|    (* dowrit - write fromLine through toLine into file *)
|    function dowrit(fromLine, toLine : integer; fileName : fileNameString)
|            : statusRange;
|    label 1;
|    var
|      errNum, number : integer;
|      line : integer;
|      k : linePtr;
|    begin
|      dowrit := ERRSTATUS;
|      errNum := open(fileName,DIROUT);
|      if errNum = 0 then begin
|        dowrit := OKSTATUS;
|        number := 0;
|        for line := fromLine to toLine do begin
|          if intrpt(ONE) then begin
|            dowrit := INTSTATUS;
|            goto 1;
|          end;
|          k := getpak(line);
|          writeln(filex,pak:lpak);
|          number := number + 1;
|        end;
|      1:
|        reset(filex);
|        writeln(termout,number:1);
|      end;
|    end;
| 
|    (* move - move "line1" through "line2" after "line3" *)
|    function move(line3 : integer) : statusRange;
|    var
|      k0, k1, k2, k3, k4, k5 : linePtr;
|      line4 : integer;
|    begin
|      line4 := line3;
|      if (line1 <= 0) or ((line1 <= line4) and (line4 <= line2)) then
|        move := ERRSTATUS
|      else begin
|        k0 := getind(prevln(line1));
|        k1 := getind(line1);
|        k2 := getind(line2);
|        k3 := getind(nextln(line2));
|        k4 := getind(line4);
|        k5 := getind(nextln(line4));
|        linkup(k0,k3);
|        if line4 > line1 then begin
|          curln := line4;
|        end
|        else curln := line4 + (line2 - line1 + 1);
|        linkup(k4,k1);
|        linkup(k2,k5);
|        move := OKSTATUS;
|      end;
|    end;
| 
|    (* subst - substitute "sub" for occurrences of pattern *)
|    function subst(sub : patternString; gflag : boolean) : statusRange;
|    label 1, 2;
|    var
|      newString : lineString;
|      j, k, lastm, line, m : integer;
|      junk1 : linePtr;
|      junk2 : boolean;
|      gotcha : statusRange;
|      subbed : boolean;
|    begin
|      etrace(' subst');
|      subst := ERRSTATUS;
|      if line1 > 0 then begin
|        subst := INTSTATUS;
|        gotcha := ERRSTATUS;
|        for line := line1 to line2 do begin
|          if intrpt(ONE) then goto 1;
|          j := 1;
|          subbed := FALSE;
|          junk1 := gettxt(line);
|          lastm := 0;
|          k := 1;
|          while txt[k] <> EOS do begin
|            if gflag or not subbed then
|              m := amatch(txt,k,pat)
|            else m := 0;
|            if (m > 0) and (lastm <> m) then begin (* replace matched text *)
|              subbed := TRUE;
|              catsub(txt,k,m,sub,newString,j,MAXLINE);
|              lastm := m;
|            end;
|            if (m = 0) or (m = k) then begin (* no match or null match *)
|              junk2 := addset(txt[k],newString,j,MAXLINE);
|              k := k + 1;
|            end
|            else k := m; (* skip matched text *)
|          end;
|          if subbed then begin
|            if not addset(EOS,newString,j,MAXLINE) then goto 2;
|            gotcha := delete(line,line);   (* remembers dot *)
|            if gotcha <> OKSTATUS then goto 2;
|            if inject(newString) = ERRSTATUS then begin
|              subst := ERRSTATUS;
|              goto 1;
|            end;
|          end;
|        end;
|      2:
|        subst := gotcha;
|      end;
|    1:
|    end;
| 
| (* global command execution routines *)
| 
|    (* docmd - handle all commands except globals *)
|    procedure docmd;
|    var
|      fileName : fileNameString;
|      sub : patternString;
|      ch : char;
|      line3 : integer;
|      gflag : boolean;
|      pflag : char;
|      ix : integer;
|    begin
|      etrace(' docmd');
|      pflag := BLANK;   (* may be set by d, m, s *)
|      status := ERRSTATUS;
|      ch := lin[i];
|      if lin[i] <> EOS then i := i + 1;
|      case ch of
|        APPENDCOM: begin
|          if lin[i] = NEWLINE then status := append(line2);
|        end;
|        BLOCK: begin
|          if nlines <> 1 then status := ERRSTATUS
|          else begin
|            increment := line2;
|            status := OKSTATUS;
|          end;
|        end;
|        CHANGE: begin
|          if lin[i] = NEWLINE then
|            if defalt(curln,curln) = OKSTATUS then
|              if delete(line1,line2) = OKSTATUS then
|                status := append(prevln(line1));
|        end;
|        DELCOM: begin
|          if ckp(pflag) = OKSTATUS then
|            if defalt(curln,curln) = OKSTATUS then
|              if delete(line1,line2) = OKSTATUS then
|                if nextln(curln) <> 0 then curln := nextln(curln);
|        end;
|        INSERT: begin
|          if lin[i] = NEWLINE then status := append(prevln(line2));
|        end;
|        PRINTCUR: begin
|          if ckp(pflag) = OKSTATUS then begin
|            writeln(termout,line2:1);
|          end;
|        end;
|        MOVECOM: begin
|          if getone(line3) = EOFSTATUS then status := ERRSTATUS;
|          if status = OKSTATUS then
|            if ckp(pflag) = OKSTATUS then
|              if defalt(curln,curln) = OKSTATUS then status := move(line3);
|        end;
|        SUBSTITUTE: begin
|          optpat;
|          if status = OKSTATUS then
|            if getrhs(sub,gflag) = OKSTATUS then
|              if ckp(pflag) = OKSTATUS then
|                if defalt(curln,curln) = OKSTATUS then
|                  status := subst(sub,gflag);
|        end;
|        ENTER: begin
|          if nlines = 0 then
|            if getfn(fileName) = OKSTATUS then begin
|              savfil := fileName;
|              clrbuf;
|              setbuf(FALSE);
|              status := doread(0,fileName);
|            end;
|        end;
|        PRINTFILE: begin
|          if nlines = 0 then
|            if getfn(fileName) = OKSTATUS then begin
|              savfil := fileName;
|              ix := 1;
|              while savfil[ix] <> EOS do ix := ix + 1;
|              writeln(termout,savfil:ix-1);
|              status := OKSTATUS;
|            end;
|        end;
|        READCOM: begin
|          if getfn(fileName) = OKSTATUS then status := doread(line2,fileName);
|        end;
|        WRITECOM: begin
|          if getfn(fileName) = OKSTATUS then
|            if defalt(1,lastln) = OKSTATUS then
|              status := dowrit(line1,line2,fileName);
|        end;
|        PRINT: begin
|          if lin[i] = NEWLINE then
|            if defalt(curln,curln) = OKSTATUS then
|              status := doprnt(line1,line2);
|        end;
|        LIST: begin
|          if lin[i] = NEWLINE then
|            if defalt(curln,curln) = OKSTATUS then
|              status := dolist(line1,line2);
|        end;
|        QUERY: begin
|          if lin[i] = NEWLINE then
|            if nlines = 0 then begin
|              etrace('     ?');
|              (* qrymem; *) writeln(termout,'not yet implemented');
|              status := OKSTATUS;
|            end;
|        end;
|        NEWLINE: begin
|          if nlines = 0 then begin
|            line1 := nextln(curln);
|            line2 := line1 + increment - 1;
|            if line2 > lastln then line2 := lastln;
|          end;
|          status := doprnt(line1,line2);
|        end;
|        QUIT: begin;
|          if (lin[i] = NEWLINE) and (nlines = 0) and not glob then
|            status := EOFSTATUS;
|        end;
|      (* else status is ERRSTATUS *)
|      end;
|      if (status = OKSTATUS) and (pflag = PRINT) then
|        status := doprnt(curln,curln)
|      else if (status = OKSTATUS) and (pflag = LIST) then
|        status := dolist(curln,curln);
|    end;
| 
|    (* ckglob - if global prefix, mark lines to be affected *)
|    procedure ckglob;
|    label 1, 2;
|    var
|      line : integer;
|      gflag : boolean;
|      k : linePtr;
|    begin
|      etrace('ckglob');
|      if (lin[i] <> GLOBAL) and (lin[i] <> EXCLUDE) then begin
|        glob := FALSE;
|        status := EOFSTATUS;
|      end
|      else begin
|        glob := TRUE;
|        gflag := lin[i] = GLOBAL;
|        i := i + 1;
|        optpat;
|        if status = OKSTATUS then status := defalt(1,lastln);
|        if status = OKSTATUS then begin
|          i := i + 1;
|          for line := line1 to line2 do begin
|            if intrpt(ONE) then begin
|              status := INTSTATUS;
|              goto 1;
|            end;
|            k := gettxt(line);
|            k@.mark := match(txt,pat) = gflag;
|          end;
|        1:
|          if status = OKSTATUS then begin
|            line := nextln(line2);
|            while line <> line1 do begin
|              if intrpt(ONE) then begin
|                status := INTSTATUS;
|                goto 2;
|              end;
|              k := getind(line);
|              k@.mark := FALSE;
|              line := nextln(line);
|            end;
|          2:
|          end;
|        end;
|      end;
|    end;
| 
|    (* doglob - do command at lin[i] on all marked lines *)
|    procedure doglob(var cursav : integer);
|    var
|      number, istart, line : integer;
|      k : linePtr;
|    begin
|      etrace('doglob');
|      status := OKSTATUS;
|      number := 0;
|      line := line1;
|      istart := i;
|      repeat
|        k := getind(line);
|        if intrpt(ONE) then status := INTSTATUS
|        else if k@.mark then begin
|          k@.mark := FALSE;
|          curln := line;
|          cursav := curln;
|          i := istart;
|          getlst;
|          if status = OKSTATUS then docmd;
|          if status = OKSTATUS then number := 0;
|        end
|        else begin
|          line := nextln(line);
|          number := number + 1;
|        end;
|      until (number > lastln) or (status <> OKSTATUS);
|    end;
| 
| (* global initialization *)
| 
|    (* initialize - perform initialization *)
|    procedure initialize;
|    var
|      tempstr34 : array [1..34] of char;
|      assgstr : assignString;
|      i : integer;
|      dummy : boolean;
|    begin
|      tempstr34 := 'ASSIGN TERMIN  TO TERMINAL INPUT ;';
|      for i := 1 to 34 do assgstr[i] := tempstr34[i];
|      i := assign(assgstr);
|      if i <> 0 then writeln(output,'error in assign of termin',i);
|      tempstr34 := 'ASSIGN TERMOUT TO TERMINAL OUTPUT;';
|      for i := 1 to 34 do assgstr[i] := tempstr34[i];
|      i := assign(assgstr);
|      if i <> 0 then writeln(output,'error in assign of termout',i);
|      EOS := chr(0);
|      TAB := chr(9);
|      ONE := 1;
|      ZERO := 0;
|      DITTO := chr(1);
|      terminopen := FALSE;
|      freeList := NIL;
|      rewrite(termout);
|      dummy := intrpt(ZERO);
|      increment := 1;
|    end;
| 
| (*******************************************************************)
| begin
| 
|    (****************)
|    (* main program *)
|    (****************)
| 
|    (* initialize *)
|    initialize;
| 
|    setbuf(TRUE);
| 
|    pat[1] := EOS;
|    savfil[1] := EOS;
|    (*??? look for argument, if possible *)
|    status := OKSTATUS;
|    while status <> EOFSTATUS do if readcmd(lin,'.') then begin
|      i := 1;
|      etrace('  edit');
|      cursav := curln;
|      getlst;
|      if status = OKSTATUS then begin
|        ckglob;
|        if status = OKSTATUS then doglob(cursav)
|        else if status = EOFSTATUS then docmd;
|      end;
|      etrace('  exit');
|      if status = ERRSTATUS then begin
|        writeln(termout,'?');
|        curln := cursav;
|      end
|      else if status = INTSTATUS then writeln(termout,'!');
|    end;
|    clrbuf;
| end.
> Member EIGHTQNS
| PROGRAM EIGHTQUEENS(OUTPUT) ;
| VAR I : INTEGER ;
|     A : ARRAY[1..8] OF BOOLEAN ;
|     B : ARRAY[2..16] OF BOOLEAN ;
|     C : ARRAY[-7..7] OF BOOLEAN ;
|     X : ARRAY[1..8] OF INTEGER ;
|     SAFE : BOOLEAN ;
| PROCEDURE TRYCOL(J : INTEGER ) ;
|          VAR I, K : INTEGER ;
|          PROCEDURE SETQUEEN ;
|          BEGIN A[I]:=FALSE ; B[I+J]:=FALSE ; C[I-J]:=FALSE
|          END ;
|          PROCEDURE REMOVEQUEEN ;
|          BEGIN A[I]:=TRUE ; B[I+J]:=TRUE ; C[I-J]:=TRUE
|          END ;
|               BEGIN
|                     I:=0      ;
|                    REPEAT I:=I+1 ; SAFE:=A[I] AND B[I+J] AND C[I-J] ;
|                         IF SAFE THEN
|                         BEGIN SETQUEEN ; X[J]:=I ;
|                              IF J<8 THEN TRYCOL(J+1)
|                                ELSE
|                                  BEGIN
|                                  FOR K := 1 TO 8 DO WRITE(X[K]) ;
|                                  WRITELN()
|                                  END ;
|                              REMOVEQUEEN
|                         END
|                    UNTIL I=8
|               END ;
|               BEGIN FOR I:=1 TO 8 DO A[I]:=TRUE ;
|                     FOR I:=2 TO 16 DO B[I]:=TRUE ;
|                     FOR I:=-7  TO 7 DO C[I]:=TRUE ;
|    TRYCOL (1);
|    WRITELN('  * DONE *') ;
| END.  (*EIGHT QUEENS*)
> Member EXPAND
|   (*$P-,F-,D-,K-,Q+,I+,M-    *)
|  PROGRAM EXPAND (INPUT,OUTPUT,QRR);
|   (* THIS PROGRAM IS THE COMPLEMENT OF COMPRESS. COMPRESS
|      COMPACTS A FILE BY ELIMINATING DUPLICATE CHARACTERS, AND
|      EXPAND RESTORES IT TO ORIGINAL FORM. FOR SPECIFICATIONS OF
|      THE COMPRESSED FILE SEE COMPRESS.
|      EXPAND DOES HAVE TO LOOK OUT FOR CHECKSUM ERRORS AND MUST
|      DISPLAY THEM ON OUTPUT.
| 
|      UPDATE RECORD:
|                    04/27/79 COMMENT CORRECTIONS. CH
| 
| 
|                                              CURT HILL
|                                              225 NEBRASKA HALL
|                                              UNIVERSITY OF NEBRASKA - LINCOLN
|                                              LINCOLN, NEBRASKA
|                                              68588
|                                              (402) 472-3701
| 
| 
|      THIS PROGRAM IS COPYRIGHT 1979, CURT HILL
| 
|      PERMISSION IS HEREBY GRANTED FOR ANY NONPROFIT USE OF ALL OR
|      PARTS OF THIS PROGRAM, PROVIDED THIS NOTICE IS DISPLAYED.
|      FURTHERMORE DISTRIBUTION AND IMPROVEMENT IS ENCOURAGED.
|      I WOULD LIKE TO HEAR ABOUT AND/OR RECIEVE COPIES OF ANY
|      IMPROVEMENTS THAT ARE WORTH MAKING TO THIS PROGRAM. CONTACT
|      ME AT ABOVE ADDRESS OR SEE PASCAL NEWS FOR AN ADDRESS UPDATE.
| 
|                FREELY YOU HAVE RECIEVED, FREELY GIVE.
|                                    *)
| 
| 
|    VAR
|      SPECIALCHAR1, SPECIALCHAR2 : CHAR;
|      INCOUNT,              (* INPUT CHARACTERS *)
|      OUTCOUNT,             (* OUTPUT LINES *)
|      CHECKSUM : INTEGER;
|      INCHAR : CHAR;
|      TYPECODE : CHAR;
|      ENDFILE  : BOOLEAN;
| 
|    PROCEDURE GETCHAR(VAR C : CHAR);
|      (* GET A CHARACTER, HANDLE EOLN, INCREMENT INCOUNT *)
| 
|      BEGIN
|        READ (INPUT,C);
|        IF EOLN(INPUT) THEN READLN(INPUT);
|        INCOUNT := INCOUNT + 1;
|        END;     (* GETCHAR *)
| 
| 
|    PROCEDURE PROCDUPE;
|      (* WE HAVE RECIEVED SPECIAL CHARACTER 1 GENERATE A DUPLICATE *)
|      VAR
|        COUNT, LASTLINE : INTEGER;
|        COUNTCHAR : CHAR;
| 
|      BEGIN     (* PROCDUPE *)
|       GETCHAR (INCHAR);
|       GETCHAR (COUNTCHAR);
|       IF (ORD(COUNTCHAR) = 0) AND (INCHAR = SPECIALCHAR1)
|          THEN ENDFILE := TRUE
|          ELSE BEGIN
|               FOR COUNT := 1 TO ORD(COUNTCHAR) DO
|                   WRITE (QRR, INCHAR);
|               CHECKSUM := CHECKSUM + ORD(INCHAR) + ORD(COUNTCHAR) +
|                             ORD (SPECIALCHAR1);
|               END;
|       END;   (* PROCDUPE *)
| 
| 
|    PROCEDURE PROCCHKSUM;
|        (* PROCESS CHECK SUM CHARACTER *)
|       VAR
|         LASTLINE,
|         COUNT : INTEGER;
| 
|       BEGIN
|         OUTCOUNT := OUTCOUNT + 1;
|         GETCHAR (INCHAR);
|         COUNT :=  ORD(INCHAR);
|         IF COUNT <> (CHECKSUM MOD 256)
|            THEN WRITELN (OUTPUT,'  *** CHECK SUM ERROR ***',
|                         '  IN LINE ',OUTCOUNT)
|            ELSE;
|         CHECKSUM := 0;
|         END;       (* PROCCHKSUM *)
| 
| 
| 
|    BEGIN   (* EXPAND *)
|      INCOUNT := 3;     (* INITIALIZE VARIABLES *)
|      OUTCOUNT := 0;
|      READ (INPUT, SPECIALCHAR1, SPECIALCHAR2, TYPECODE);
|          (* OBTAIN SPECIAL CHARACTERS AND TYPE CODE *)
|      CHECKSUM := ORD(SPECIALCHAR1) + ORD(SPECIALCHAR2) + ORD(TYPECODE);
|      ENDFILE := FALSE;
|      REWRITE (QRR);
| 
|      WHILE (NOT EOF(INPUT)) AND (NOT ENDFILE) DO
|        BEGIN
|        GETCHAR (INCHAR);
|        IF INCHAR = SPECIALCHAR1
|           THEN PROCDUPE
|           ELSE IF INCHAR = SPECIALCHAR2
|                   THEN PROCCHKSUM
|                   ELSE BEGIN
|                        CHECKSUM := CHECKSUM + ORD(INCHAR);
|                        WRITE (QRR,INCHAR)
|                        END;
|        END;
|        WRITELN (OUTPUT,' **** EXPAND ****');
|        WRITELN (OUTPUT,' TOTAL INPUT CHARACTERS : ',INCOUNT:9);
|        WRITELN (OUTPUT,' TOTAL OUTPUT LINES :     ',OUTCOUNT:9);
|      END.  (* EXPAND *)
> Member FFT
| (*$L+,C+,M-,D-*)
| PROGRAM OSCAR(OUTPUT) ;
| 
| (* FAST FOURIER TRANSFER PROGRAM AFTER OSCAR BUENMAN, S. HAZEGHI. *)
| 
| CONST TWO_K = 1024 ;  TWO_K_2 = 513  ;  TWO_TO_15 = 32768 ;
| 
| TYPE COMPLEX = RECORD  RP: REAL ;  IP: REAL  END ;
|      C_K_ARRAY = ARRAY [1..TWO_K] OF COMPLEX ;
|      C_K_2_ARRAY = ARRAY [1..TWO_K_2] OF COMPLEX ;
|      ALPHA = ARRAY [1..8] OF CHAR ;
| 
| VAR
|      SEED, I: INTEGER ;
|      Z, W : C_K_ARRAY ;
|      E    : C_K_2_ARRAY ;
| 
| FUNCTION UNIFORM_10_10 : REAL ;
|     VAR T : INTEGER ;
|          BEGIN
|          SEED := (14159269*SEED+231818041) MOD TWO_TO_15 ;
|          UNIFORM_10_10 := 20.0*SEED/TWO_TO_15 - 10.0 ;
|          END (* UNIFORM *) ;
| 
| PROCEDURE EXPTAB(N: INTEGER; VAR E: C_K_2_ARRAY) ;
| 
|     VAR  H: ARRAY [1..13] OF REAL ;
|          HT: ARRAY ['A'..'9'] OF  0..15 ;
|          I, J, K, L, M: INTEGER ;
|          C : CHAR ;
| 
|     FUNCTION Z(HEX_STR: ALPHA): REAL ;
|          VAR T: REAL ;  I: INTEGER ;
|               BEGIN  T := 0.0;
|               FOR I := 8 DOWNTO 2 DO T := HT[HEX_STR[I]]+T/16.0 ;
|               Z := T
|               END ;
| 
|          BEGIN (* EXPTAB *)
|          FOR C := 'A' TO 'F' DO HT[C] := ORD(C)-ORD('A')+10 ;
|          FOR C := '0' TO '9' DO HT[C] := ORD(C)-ORD('0') ;
|          H[1] := Z('40B504F3'); H[2] := Z('408A8BD4') ;
|          H[3] := Z('408281F7'); H[4] := Z('40809E8D') ;
|          H[5] := Z('40802785'); H[6] := Z('408009DF') ;
|          H[7] := Z('40800278'); H[8] := Z('4080009E');
|          H[9] := Z('40800027'); H[10] := Z('4080000A');
|          H[11] := Z('40800002'); H[12] := Z('40800001');
|          H[13] := Z('40800000');
|          M := N DIV 2 ;  L := M DIV 2 ;  J := 1 ;
|          E[1].RP := 1.0 ;  E[1].IP := 0.0; E[L+1].RP := 0.0;
|          E[L+1].IP := 1.0 ;  E[M+1].RP := -1.0 ; E[M+1].IP := 0.0 ;
| 
|               REPEAT I := L DIV 2 ;  K := I ;
| 
|                    REPEAT
|                    E[K+1].RP := H[J]*(E[K+I+1].RP+E[K-I+1].RP) ;
|                    E[K+1].IP := H[J]*(E[K+I+1].IP+E[K-I+1].IP) ;
|                    K := K+L ;
|                    UNTIL K > M ;
| 
|               IF J > 12 THEN J := 13  ELSE J := J+1 ;
|               L := I ;
|               UNTIL L <= 1 ;
| 
|          END (* EXPTAB *) ;
| 
| PROCEDURE FFT( N: INTEGER ;VAR Z, W: C_K_ARRAY ;
|               VAR E: C_K_2_ARRAY ; SQRINV: REAL) ;
| 
|     VAR  I, J, K, L, M: INTEGER ;
| 
|          BEGIN  M := N DIV 2 ;  L := 1 ;
| 
|               REPEAT  K := 0 ;  J := L ;  I := 1 ;
| 
|                    REPEAT
| 
|                         REPEAT
|                         W[I+K].RP := Z[I].RP+Z[M+I].RP ;
|                         W[I+K].IP := Z[I].IP+Z[M+I].IP ;
|                         W[I+J].RP := E[K+1].RP*(Z[I].RP-Z[I+M].RP)
|                                      -E[K+1].IP*(Z[I].IP-Z[I+M].IP) ;
|                         W[I+J].IP := E[K+1].RP*(Z[I].IP-Z[I+M].IP)
|                                      +E[K+1].IP*(Z[I].RP-Z[I+M].RP) ;
|                         I := I+1 ;
|                         UNTIL I > J ;
| 
|                    K := J ;  J := K+L ;
|                    UNTIL J > M ;
| 
|               Z := W ; (*FOR I := 1 TO N DO  Z[I] := W[I]  ;*)
|               L := L+L ;
|               UNTIL L > M ;
| 
|          FOR I := 1 TO N DO
| 
|               BEGIN
|               Z[I].RP := SQRINV*Z[I].RP ;  Z[I].IP := -SQRINV*Z[I].IP
|               END ;
| 
|          END ;
| 
| PROCEDURE PRINT_COMPLEX ;
| 
|     VAR I, J: INTEGER ;
| 
|          BEGIN  WRITELN() ;  I := 1 ;  J := 0 ;
| 
|               REPEAT  J := J+1 ;
|               WRITE('    ',Z[I].RP:10,'  ',Z[I].IP:10) ;
|               IF (J MOD 4) = 0 THEN WRITELN() ;
|               I := I+17 ;
|               UNTIL I > TWO_K ;
| 
|          WRITELN() ;
|          END ;
| 
|     BEGIN (* OSCAR *)
| 
|     EXPTAB(TWO_K,E) ;
|     SEED := 12345 ;
|     FOR I := 1 TO TWO_K DO
| 
|          BEGIN
|          Z[I].RP := UNIFORM_10_10 ;  Z[I].IP := UNIFORM_10_10 ;
|          END ;
| 
|     PRINT_COMPLEX ;
|     FFT(TWO_K,Z,W,E,SQRT(1.0/TWO_K)) ;  PRINT_COMPLEX ;
|     FFT(TWO_K,Z,W,E,SQRT(1.0/TWO_K)) ;  PRINT_COMPLEX ;
|     END (* OSCAR *) .
> Member GCIRCLE
| PROGRAM  GREATC(INPUT, OUTPUT); (*$M-*)
| 
|   CONST  DEGSRADIANS = 57.29578;
| 
|   VAR  SIDEA,  SIDEB,  SIDEC,
|        ANGLEA, ANGLEB, ANGLEC,
|        AMINUSB, APLUSB,
|        DELTA, PLUSMINUS,
|        STRTLATMNTS, STRTLONMNTS,
|        DESTLATMNTS,  DESTLONMNTS,
|        STRTLAT, STRTLON,
|        DESTLAT,  DESTLON:             REAL;
| 
|        DISTANCE, I, STEP,
|        STRTLATDEGS, STRTLONDEGS,
|        DESTLATDEGS,  DESTLONDEGS,
|        LATDEGS, LATMNTS,
|        LONDEGS, LONMNTS:       INTEGER;
| 
| 
| 
| FUNCTION  TAN(X: REAL):  REAL;
| 
| BEGIN  (* TAN *)
|   TAN := SIN(X) / COS(X)
| END;  (* TAN *)
| 
| 
| 
| FUNCTION  COT(X: REAL):  REAL;
| 
| BEGIN  (* COT *)
|   COT := (1.0 / X) - (X / 3.0)
|                    - (X * X * X / 45.0)
|                    - (2.0 * X * X * X * X * X / 945.0)
|                    - (X * X * X * X * X * X * X / 4725.0);
| END;  (* COT *)
| 
| 
| 
| FUNCTION  ASIN(X: REAL):  REAL;
| 
| BEGIN  (* ASIN *)
|   ASIN := X + (X * X * X / 6.0)
|             + (3.0 * X * X * X * X * X / 40.0)
|             + (15.0 * X * X * X * X * X * X * X / 336.0);
| END;  (* ASIN *)
| 
| 
| 
| 
| BEGIN  (* GREATCIRCLE *)
|       READ(STRTLATDEGS, STRTLATMNTS, STRTLONDEGS, STRTLONMNTS);
|       READ(DESTLATDEGS,  DESTLATMNTS,  DESTLONDEGS,  DESTLONMNTS) ;
| 
|       STRTLAT := STRTLATDEGS + (STRTLATMNTS / 60.0);
|       STRTLON:= STRTLONDEGS + (STRTLONMNTS / 60.0);
|       DESTLAT  := DESTLATDEGS  + (DESTLATMNTS  / 60.0);
|       DESTLON := DESTLONDEGS  + (DESTLONMNTS  / 60.0);
| 
|       WRITELN('1STRTING LAT:      ', STRTLATDEGS:3,
|                                            STRTLATMNTS:5);
|       WRITELN(' STRTING LON:     ', STRTLONDEGS:3,
|                                            STRTLONMNTS:5);
|       WRITELN('0DESTINATION LAT:   ', DESTLATDEGS:3,
|                                            DESTLATMNTS:5);
|       WRITELN(' DESTINATION LON:  ', DESTLONDEGS:3,
|                                            DESTLONMNTS:5);
| 
|       PLUSMINUS := 1.0;
|       IF  STRTLON > DESTLON   THEN PLUSMINUS := -1.0;
|       READ(STEP);
| 
|       SIDEA := (90.0 - DESTLAT) / DEGSRADIANS;
|       SIDEB := (90.0 - STRTLAT)/ DEGSRADIANS;
|       ANGLEC := ABS(STRTLON - DESTLON) / DEGSRADIANS;
|       AMINUSB := 2.0 * (ARCTAN(SIN(0.5*(SIDEA-SIDEB))/
|                           SIN(0.5*(SIDEA+SIDEB))*
|                           COT(0.5*ANGLEC)));
|       APLUSB  := 2.0 * (ARCTAN(COS(0.5*(SIDEA-SIDEB))/
|                            COS(0.5*(SIDEA+SIDEB))*
|                            COT(0.5*ANGLEC)));
|       ANGLEA := (AMINUSB + APLUSB) / 2.0;
|       SIDEC  := ASIN(SIN(ANGLEC) * SIN(SIDEA)/ SIN(ANGLEA));
|       DISTANCE := TRUNC(0.5+SIDEC * 3963.2);
|       WRITELN('0GREATCIRCLE DISTANCE = ', DISTANCE:6, ' STATUTE MILES');
|       WRITELN('0');
| 
| 
|       SIDEC  := SIDEB;
|       ANGLEB := 0.0;
|       DELTA  := ANGLEC / STEP;
| 
|       FOR I := 1 TO STEP+1  DO
|         BEGIN
|           AMINUSB := 2.0*(ARCTAN(SIN(0.5*(ANGLEA-ANGLEB))/
|                                  SIN(0.5*(ANGLEA+ANGLEB))*
|                                  TAN(0.5*SIDEC)));
|           APLUSB  := 2.0*(ARCTAN(COS(0.5*(ANGLEA-ANGLEB))/
|                                  COS(0.5*(ANGLEA+ANGLEB))*
|                                  TAN(0.5*SIDEC)));
|           SIDEA := (AMINUSB + APLUSB) / 2.0;
|           LATDEGS  := TRUNC(90.0 - (SIDEA * DEGSRADIANS));
|           LATMNTS  := TRUNC(0.5+((90.0 - (SIDEA * DEGSRADIANS))
|                                            - LATDEGS) * 60.0);
|           LONDEGS := TRUNC(STRTLONDEGS + ((ANGLEB * DEGSRADIANS)
|                                                     * PLUSMINUS));
|           LONMNTS := TRUNC(0.5+((STRTLON + ((ANGLEB *DEGSRADIANS)
|                                      * PLUSMINUS)) - LONDEGS) * 60.0);
|           IF  LONMNTS >= 60
|               THEN
|                 BEGIN
|                   LONDEGS := LONDEGS + 1;
|                   LONMNTS := LONMNTS - 60;
|                 END;
|          WRITELN(LATDEGS:3, LATMNTS:3,
|                  LONDEGS:8, LONMNTS:3);
|          ANGLEB := ANGLEB + DELTA;
|         END  (* FOR LOOP *)
| END  (* GREATCIRCLE *)  .
|  27 46   45 26  39 12   16 22     (TYPICAL DATA FOR GREATCIRCLE)
> Member INQUIRE
| (* after a program by A. Sale, published in Pascal News, CH July 79 *)
| 
| PROGRAM INVESTIGATEREPRESENTATION(OUTPUT);
|         (* DETERMINE REAL NUMBER CHARACTERISTICS OF BASE MACHINE
|            AND COMPILER.                  *)
| VAR
|     BASE,
|     NUMBEROFDIGITS,
|     I                      : INTEGER;
|     ROUNDING               : BOOLEAN;
|     EPSILON                : REAL;
| 
|  PROCEDURE ENQUIRY (VAR RADIX, DIGITS : INTEGER; VAR ROUNDS : BOOLEAN);
| 
|  VAR
|     NUMBER,
|     INCREMENT              : REAL;
| 
|  BEGIN  (* ENQUIRY *)
|      (* FIND LARGE INTEGRAL VALUE JUST BEYOND INTEGER LIMITS *)
|      NUMBER := 2;
|      WHILE (((NUMBER+1)-NUMBER ) = 1 ) DO NUMBER := NUMBER * 2;
|      (* MANUFACTURE THE NEXT LARGEST REAL VALUE *)
|      INCREMENT := 2;
|      WHILE ((NUMBER + INCREMENT) = NUMBER) DO
|           INCREMENT := INCREMENT * 2;
|      (* SUBTRACT THESE TO GIVE RADIX OF REPRESENTATION *)
|      RADIX := TRUNC((NUMBER + INCREMENT) - NUMBER);
|      (* SEE IF IT ROUNDS OR TRUNCATES BY ADDING (RADIX - 1)  *)
|      ROUNDS := ((NUMBER + (RADIX + 1)) <> NUMBER);
|      (* WORK OUT HOW MANY DIGITS IN MANTISSA *)
|      DIGITS := 0;
|      NUMBER := 1;
|      WHILE (((NUMBER + 1) - NUMBER) = 1) DO
|          BEGIN
|           DIGITS := DIGITS + 1;
|           NUMBER := NUMBER * RADIX;
|          END;
|      END;   (* ENQUIRY *)
| 
| 
| 
| BEGIN   (* MAIN PROGRAM *)
|     (* FIND OUT BASIC PROPERTIES *)
|     ENQUIRY(BASE,NUMBEROFDIGITS,ROUNDING);
|     WRITELN(OUTPUT, ' BASE=',BASE:5);
|     WRITELN(OUTPUT, ' NUMBER OF DIGITS=',NUMBEROFDIGITS:5);
|     IF ROUNDING
|        THEN WRITELN(OUTPUT, ' ROUNDED')
|        ELSE WRITELN(OUTPUT, ' TRUNCATED');
|     (* COMPUTE THE PRECISION BOUNDS *)
|     EPSILON := 1;
|     FOR I := 1 TO NUMBEROFDIGITS DO EPSILON := EPSILON/BASE;
|     IF ROUNDING THEN EPSILON := EPSILON / 2;
|     (* PRINT THE BEST AND WORST *)
|     WRITELN(OUTPUT, ' BEST AND WORST PRECISIONS ARE ',
|                      EPSILON,(EPSILON*BASE) );
| END.
> Member INVERT
| PROGRAM  INVERT(OUTPUT);  (*$M-*)
| 
|   CONST  ARRAYSIZE =  9;
|          NUMBEROFINVERSIONS =  50;
| 
|   VAR  A:  ARRAY[1..ARRAYSIZE, 1..ARRAYSIZE] OF REAL;
|        TEMP, SUM:   REAL;
|        I, J, K, L:  INTEGER;
| 
| (* THIS PROGRAM DOES REPEATED INVERSIONS OF A HILBERT MATRIX *)
| 
| BEGIN  (* INVERT *)
|   FOR I := 1 TO ARRAYSIZE  DO
|       FOR J := 1 TO ARRAYSIZE  DO
|           A[I,J] := 1.0 / (I + J - 1.0);         (* SET UP THE HILBERT MATRIX *)
| 
|   FOR L := 1 TO NUMBEROFINVERSIONS  DO
|       BEGIN FOR I := 1 TO ARRAYSIZE  DO
|                 BEGIN TEMP := A[I,I];
|                       A[I,I] := 1.0;
|                       FOR J := 1 TO ARRAYSIZE  DO
|                           A[I,J] := A[I,J] / TEMP;
|                       FOR K := 1 TO ARRAYSIZE  DO
|                           BEGIN IF K <> I  THEN
|                                    BEGIN TEMP := A[K,I];
|                                          A[K,I] := 0.0;
|                                          FOR J := 1 TO ARRAYSIZE  DO
|                                              A[K,J] := A[K,J] -
|                                                        (TEMP * A[I,J])
|                                    END
|                           END
|                 END;
|             IF ODD(L)  THEN
|                BEGIN SUM := 0.0;
|                      FOR I := 1 TO ARRAYSIZE  DO
|                          FOR J := 1 TO ARRAYSIZE  DO
|                              SUM := SUM + A[I,J];
|                      WRITELN(' SUM = ', SUM:17)
|                END
|       END
| END  (* INVERT *)  .
> Member PASCREF
| PROGRAM PASCREF(INPUT,OUTPUT);      (*$D-,L+,M+   N.WIRTH  2.7.75  *)   00010000
| (*CROSS REFERENCE GENERATOR FOR PASCAL PROGRAMS*)                       00020000
| (*QUADRATIC QUOTIENT HASH METHOD*)                                      00030000
| (*MODIFIED SLIGHTLY BY A. MICKEL 75/12/08 AND D. LALIBERTE              00040000
|   78/03/15 TO PRODUCE PROCEDURE LIST AND SKIP COMPILER TITLE*)          00050000
| (* PASCAL-6000 DEPENDENT CONSTRUCTS CHANGED. S.HAZEGHI,  02-15-79 *)    00060000
| (* 6/86 - CORRECTIONS FOR COMPILER OUTPUT PROCESSING (LPP, LINE#)   *)  00070000
| (*             INCREASED HASH TABLE SIZE; FIXED BRACED COMMENTS     *)  00080000
| (*          G. POSTPISCHIL, EXPERT SYSTEM PROGRAMMING, INC. / 86180 *)  00090000
| (*$D-  TESTS OFF*)                                                      00100000
| LABEL 99;                                                               00110000
| CONST P = 8999;     (*SIZE OF HASH TABLE*)                 (* 86180 *)  00120000
|   NK = 33;          (*NO. OF KEYWORDS*)                                 00130000
|   KLN = 10;         (*KEYLENGTH*)                                       00140000
|   LPPG = 55;        (*NO. OF LINES PER PAGE*)                           00150000
|   LLMAX = 132;      (*LINE LENGTH DEFAULT MAX*)                         00160000
|   LLMIN = 72;       (*LINE LENGTH MINIMUM*)                             00170000
|   MAXN = 10000;     (*MAX NO. OF LINES*)                                00180000
|   DGPN =  6;        (*NO. OF DIGITS PER NUMBER*)                        00190000
|   LITL = 3;         (*NUMBER OF LINES IN COMPILER TITLE*)               00200000
|   ADDRWIDTH = 11;        (*NUMBER OF DIGITS IN CODE ADDRESS / 86180 *)  00210000
|   EMPTY = '          ';                                                 00220000
|   STARS = ' *****';                                                     00230000
| TYPE INDEX = 0..P;                                                      00240000
|   ALFA = PACKED ARRAY [1..KLN] OF CHAR;                                 00250000
|   REF = @ITEM;                                                          00260000
|   WORD = RECORD KEY: ALFA;                                              00270000
|            FIRST: REF;                                                  00280000
|          END ;                                                          00290000
|   ITEM = PACKED RECORD                                                  00300000
|            LNO: 0..MAXN;                                                00310000
|            NEXT: REF                                                    00320000
|          END ;                                                          00330000
|   PROCREF = @PROC;  (*PROCEDURE OR FUNCTION REFERENCE*)                 00340000
|   PROC = PACKED RECORD                                                  00350000
|            NAME: ALFA;                                                  00360000
|            LNO: 0..MAXN;                                                00370000
|            NEXT: PROCREF                                                00380000
|          END ;                                                          00390000
| VAR I: INDEX;                                                           00400000
|   K: INTEGER;                                                           00410000
|   M: INTEGER;       (*NO. OF LINES ON PAGE*)                            00420000
|   N: INTEGER;       (*NO. OF LINES INPUT*)                              00430000
|   LN: INTEGER;      (*CURRENT LINE NUMBER*)                             00440000
|   OLDLN: INTEGER;               (* LINE NUMBER OF LAST LINE / 86180 *)  00450000
|   LLNGOUT: INTEGER; (*LINE LENGTH FOR OUTPUT*)                          00460000
|   LLNGIN: INTEGER;  (*LINE LENGTH FOR INPUT*)                           00470000
|   CCOUNT: INTEGER;  (*CHARACTER COUNT IN LINE*)                         00480000
|   NOPL: INTEGER;    (*NO. OF LINE-NUMBERS PER LINE*)                    00490000
|   ID: RECORD CASE BOOLEAN OF                                            00500000
|              FALSE: (A: ALFA);                                          00510000
|              TRUE:  (ORD: INTEGER)                                      00520000
|       END ;                                                             00530000
|   KEY: ARRAY [1..NK] OF ALFA;                                           00540000
|   PROCORFUNC,                                                           00550000
|   COMPILERLISTING,                                                      00560000
|   LINENUMBERS: BOOLEAN;                                                 00570000
|   C1, C2, C3 : INTEGER;    (* ID, OCCUR, PROC. COUNTERS *)              00580000
|   FIRSTPROC,                                                            00590000
|   PROCPTR: PROCREF; (*POINTERS TO CHAIN OF PROCEDURES*)                 00600000
|   T: ARRAY [INDEX] OF WORD;    (*HASH TABLE*)                           00610000
|                                                                         00620000
|                                                                         00630000
|    FUNCTION LETTER(C: CHAR): BOOLEAN;                                   00640000
|                                                                         00650000
|      BEGIN                                                              00660000
|      LETTER := (('A' <= C) AND (C <= 'Z')) OR                           00670000
|                (('a' <= C) AND (C <= 'i')) OR                           00680000
|                (('j' <= C) AND (C <= 'r')) OR                           00690000
|                (('s' <= C) AND (C <= 'z')) ;                            00700000
|      END ;                                                              00710000
|                                                                         00720000
|    FUNCTION DIGIT(C: CHAR): BOOLEAN ;                                   00730000
|                                                                         00740000
|      BEGIN                                                              00750000
|      DIGIT := ('0' <= C) AND (C <= '9') ;                               00760000
|      END ;                                                              00770000
|                                                                         00780000
|    FUNCTION SPECIAL(C: CHAR): BOOLEAN;                                  00790000
|      BEGIN  SPECIAL := (C = '$') OR (C = '_')  END ;                    00800000
|                                                                         00810000
| FUNCTION NOKEY: BOOLEAN;                                                00820000
|    VAR I,J,K: INTEGER;                                                  00830000
| BEGIN I := 1; J := NK;   (*BINARY SEARCH*)                              00840000
|   REPEAT K := (I+J) DIV 2;                                              00850000
|     IF KEY[K] <= ID.A THEN I := K+1 ELSE J := K-1                       00860000
|   UNTIL I > J;                                                          00870000
|   IF J = 0 THEN NOKEY := TRUE ELSE                                      00880000
|     NOKEY := KEY[J] <> ID.A                                             00890000
| END (*NOKEY*) ;                                                         00900000
|                                                                         00910000
| PROCEDURE COUNTLINE;                                                    00920000
| BEGIN                                                                   00930000
|   IF M >= LPPG THEN                                                     00940000
|     BEGIN PAGE(OUTPUT); WRITELN(OUTPUT); """WRITELN(OUTPUT); """        00950000
|       M := 0                                                            00960000
|     END;                                                                00970000
|   M := M + 1                                                            00980000
| END (*COUNTLINE*) ;                                                     00990000
|                                                                         01000000
| PROCEDURE ADVANCE;                                                      01010000
| BEGIN                                                                   01020000
|   WRITE(OUTPUT,INPUT@); GET(INPUT);                                     01030000
|   CCOUNT := CCOUNT + 1;                                                 01040000
|   IF CCOUNT = LLNGIN THEN                                               01050000
|     WHILE NOT EOLN(INPUT) DO                                            01060000
|       BEGIN WRITE(OUTPUT,INPUT@); GET(INPUT);                           01070000
|       END                                                               01080000
| END (*ADVANCE*);                                                        01090000
|                                                                         01100000
| PROCEDURE SPACE(J: INTEGER);                                            01110000
| BEGIN                                                                   01120000
|   REPEAT J := J-1; WRITELN(OUTPUT); COUNTLINE                           01130000
|   UNTIL J = 0                                                           01140000
| END (*SPACE*) ;                                                         01150000
|                                                                         01160000
| PROCEDURE SKIPCOMPILERTITLE;                               (* 86180 *)  01170000
|                                                            (* 86180 *)  01180000
|   VAR I: INTEGER;                                          (* 86180 *)  01190000
| BEGIN                                                      (* 86180 *)  01200000
|   COMPILERLISTING := INPUT@ = '1';                         (* 86180 *)  01210000
|   PAGE(OUTPUT);                                            (* 86180 *)  01220000
|   IF COMPILERLISTING THEN                                  (* 86180 *)  01230000
|   BEGIN I := 0; GET(INPUT);                                (* 86180 *)  01240000
|     WHILE I < LITL DO                                      (* 86180 *)  01250000
|       BEGIN I := I + 1;                                    (* 86180 *)  01260000
|         WHILE NOT EOLN(INPUT) DO                           (* 86180 *)  01270000
|           ADVANCE;                                         (* 86180 *)  01280000
|         READLN; WRITELN(OUTPUT);                           (* 86180 *)  01290000
|       END;                                                 (* 86180 *)  01300000
|     """COUNTLINE;"""      (* GENERATES INCORRECT LINES/PAGE / 86180 *)  01310000
|          M := 0;(* SET LINE COUNT CORRECTLY - WE JUST EJECTED/86180 *)  01320000
|     LINENUMBERS := TRUE                                    (* 86180 *)  01330000
|   END ELSE                                                 (* 86180 *)  01340000
|   BEGIN WRITELN(OUTPUT); WRITELN(OUTPUT);                  (* 86180 *)  01350000
|     LINENUMBERS := """INPUT@ IN ['0'..'9']""" DIGIT(INPUT@)(* 86180 *)  01360000
|   END;                                                     (* 86180 *)  01370000
| END (*SKIPCOMPILERTITLE*) ;                                (* 86180 *)  01380000
|                                                                         01390000
| PROCEDURE HEADSHOP;                                        (* 86180 *)  01400000
| BEGIN                                                      (* 86180 *)  01410000
|   IF COMPILERLISTING AND NOT EOLN AND (INPUT@ = '1')       (* 86180 *)  01420000
|     THEN SKIPCOMPILERTITLE                                 (* 86180 *)  01430000
| END; (* HEADSHOP *)                                        (* 86180 *)  01440000
|                                                            (* 86180 *)  01450000
| PROCEDURE FLUSHLINE;                                       (* 86180 *)  01460000
| BEGIN                                                      (* 86180 *)  01470000
|   WHILE NOT EOLN DO                                        (* 86180 *)  01480000
|     ADVANCE;                                               (* 86180 *)  01490000
| END; (* FLUSHLINE *)                                       (* 86180 *)  01500000
|                                                                         01510000
| PROCEDURE BLANKSKIP;                                       (* 86180 *)  01520000
| BEGIN                                                      (* 86180 *)  01530000
|   IF NOT EOLN AND (INPUT@ = ' ') THEN                      (* 86180 *)  01540000
|     ADVANCE;                                               (* 86180 *)  01550000
| END; (* BLANKSKIP *)                                       (* 86180 *)  01560000
|                                                                         01570000
| PROCEDURE NEWLINE;                                                      01580000
| BEGIN CCOUNT := 0;                                                      01590000
|   HEADSHOP;      (* CHECK FOR COMPILER TITLE *)            (* 86180 *)  01600000
|   OLDLN := LN;                         (* SAVE PRIOR LINE # / 86180 *)  01610000
|   LN := 0;                                                              01620000
|   IF N < MAXN THEN                                                      01630000
|   BEGIN COUNTLINE;  N := N + 1;                                         01640000
|     IF COMPILERLISTING THEN                                             01650000
|        BEGIN                                                            01660000
|        WHILE NOT EOLN AND (INPUT@ <>  ')') DO              (* 86180 *)  01670000
|          BEGIN                                             (* 86180 *)  01680000
|          FOR I := 1 TO 9 DO                                (* 86180 *)  01690000
|            BLANKSKIP;                                      (* 86180 *)  01700000
|          IF NOT DIGIT(INPUT@) THEN FLUSHLINE;              (* 86180 *)  01710000
|          WHILE DIGIT(INPUT@) DO                            (* 86180 *)  01720000
|              BEGIN LN := 10*LN + ORD(INPUT@) - ORD('0');   (* 86180 *)  01730000
|              ADVANCE;                                      (* 86180 *)  01740000
|              END;                                          (* 86180 *)  01750000
|          FOR I := 1 TO ADDRWIDTH DO                        (* 86180 *)  01760000
|            IF NOT EOLN THEN ADVANCE;                       (* 86180 *)  01770000
|        END;                                                (* 86180 *)  01780000
|          IF NOT EOLN AND (INPUT@ <> ')') THEN FLUSHLINE    (* 86180 *)  01790000
|                             ELSE ADVANCE;                  (* 86180 *)  01800000
|        END                                                 (* 86180 *)  01810000
|     ELSE WRITE(OUTPUT,' ');                                             01820000
|     IF LINENUMBERS THEN                                                 01830000
|       BEGIN                                                             01840000
|       WHILE DIGIT(INPUT@) DO                                            01850000
| """   WHILE INPUT@ IN ['0'..'9'] DO   """                               01860000
|         BEGIN LN := 10*LN + ORD(INPUT@) - ORD('0');                     01870000
|           ADVANCE;                                                      01880000
|         END;                                                            01890000
|       END                                                               01900000
|     ELSE BEGIN                                                          01910000
|       LN := N;  WRITE(OUTPUT,LN:6, ') ')                                01920000
|       END                                                               01930000
|     END                                                                 01940000
|   ELSE BEGIN                                                            01950000
|     WRITELN(STARS, ' TEXT TOO LONG', STARS);                            01960000
|     "GOTO 99"  EXIT(99);                                                01970000
|     END;                                                                01980000
|     IF LN = 0 THEN LN := OLDLN         (* REL. TO PRIOR LINE /86180 *)  01990000
| END (*NEWLINE*) ;                                                       02000000
|                                                                         02010000
| PROCEDURE SEARCH;   (*MODULO P HASH SEARCH*)                            02020000
|   VAR H,D: INDEX;                                                       02030000
|       X: REF; F: BOOLEAN;                                               02040000
|       K: INTEGER;                                                       02050000
| BEGIN  I := ABS(ID.ORD);  H := I MOD P;                                 02060000
|   F := FALSE; D := 1;                                                   02070000
|   NEW(X); X@.LNO := LN;                                                 02080000
|   REPEAT                                                                02090000
|     IF T[H].KEY = ID.A THEN                                             02100000
|     BEGIN (*FOUND*) F := TRUE;                                          02110000
|       X@.NEXT := T[H].FIRST; T[H].FIRST := X;                           02120000
|     END ELSE                                                            02130000
|     IF T[H].KEY = EMPTY THEN                                            02140000
|     BEGIN (*NEW ENTRY*) F := TRUE;                                      02150000
|       T[H].KEY := ID.A;                                                 02160000
|       T[H].FIRST := X; X@.NEXT := NIL                                   02170000
|     END ELSE                                                            02180000
|     BEGIN (*COLLISION*) H := H+D; D := D+2;                             02190000
|       IF H >= P THEN H := H-P;                                          02200000
|       IF D = P THEN                                                     02210000
|         BEGIN WRITELN(OUTPUT); WRITELN(STARS,' TABLE FULL',STARS);      02220000
|         """GOTO 99"""   EXIT(99);                                       02230000
|         END                                                             02240000
|     END                                                                 02250000
|   UNTIL F                                                               02260000
| END (*SEARCH*) ;                                                        02270000
|                                                                         02280000
| PROCEDURE SORT(MIN, MAX: INTEGER);                                      02290000
|                                                                         02300000
| (* QUICKSORT WITH BOUNDED RECURSION DEPTH *)                            02310000
| (* REQUIRES MIN <= MAX *)                                               02320000
|                                                                         02330000
|    VAR                                                                  02340000
|          LOW,                                                           02350000
|         HIGH: INDEX;                                                    02360000
|       MIDKEY: ALFA;                                                     02370000
|         TEMP: WORD;                                                     02380000
|                                                                         02390000
|    BEGIN                                                                02400000
|       REPEAT (*PICK SPLIT POINT*)                                       02410000
|          MIDKEY := T[(MIN + MAX) DIV 2].KEY;                            02420000
|          LOW := MIN;                                                    02430000
|          HIGH := MAX;                                                   02440000
|          REPEAT (*PARTITION*)                                           02450000
|             WHILE T[LOW].KEY < MIDKEY DO                                02460000
|                LOW := LOW + 1;                                          02470000
|             WHILE T[HIGH].KEY > MIDKEY DO                               02480000
|                HIGH := HIGH - 1;                                        02490000
|             IF LOW <= HIGH THEN                                         02500000
|                BEGIN                                                    02510000
|                   TEMP := T[LOW];                                       02520000
|                   T[LOW] := T[HIGH];                                    02530000
|                   T[HIGH] := TEMP;                                      02540000
|                   LOW := LOW + 1;                                       02550000
|                   HIGH := HIGH - 1                                      02560000
|                END;                                                     02570000
|          UNTIL LOW > HIGH;                                              02580000
|                                                                         02590000
|          (*RECURSIVELY SORT SHORTER SUB-SEGMENT*)                       02600000
|          IF HIGH - MIN < MAX - LOW                                      02610000
|          THEN                                                           02620000
|             BEGIN                                                       02630000
|                IF MIN < HIGH THEN                                       02640000
|                   SORT(MIN, HIGH);                                      02650000
|                MIN := LOW                                               02660000
|             END                                                         02670000
|          ELSE                                                           02680000
|             BEGIN                                                       02690000
|                IF LOW < MAX THEN                                        02700000
|                   SORT(LOW, MAX);                                       02710000
|                MAX := HIGH                                              02720000
|             END                                                         02730000
|       UNTIL MAX <= MIN                                                  02740000
|    END (*SORT*);                                                        02750000
|                                                                         02760000
|                                                                         02770000
| PROCEDURE NOTEPROC;   (*NOTE INSTANCE OF PROCEDURE OR FUNCTION*)        02780000
|   VAR P: PROCREF;                                                       02790000
| BEGIN PROCORFUNC := FALSE;                                              02800000
|   NEW(P); PROCPTR@.NEXT := P;                                           02810000
|   P@.NAME := ID.A; P@.LNO := LN; P@.NEXT := NIL;                        02820000
|   PROCPTR := P                                                          02830000
| END (*NOTEPROC*) ;                                                      02840000
|                                                                         02850000
| PROCEDURE PRINTWORD(W: WORD);                                           02860000
|   VAR L: INTEGER; X,Y,Z: REF;                                           02870000
| BEGIN COUNTLINE; WRITE(OUTPUT,' ', W.KEY);                              02880000
|   X := W.FIRST; Y := X@.NEXT; X@.NEXT := NIL;                           02890000
|   WHILE Y <> NIL DO                                                     02900000
|     BEGIN Z := Y@.NEXT; Y@.NEXT := X; X := Y; Y := Z                    02910000
|     END ;                                                               02920000
|   L := 0;                                                               02930000
|   REPEAT                                                                02940000
|     IF L = NOPL THEN                                                    02950000
|       BEGIN L := 0; WRITELN(OUTPUT); COUNTLINE; WRITE(OUTPUT,' ', EMPTY)02960000
|       END;                                                              02970000
|     L := L+1; WRITE(OUTPUT,X@.LNO: DGPN); X := X@.NEXT; C2 := C2+1;     02980000
|   UNTIL X = NIL;                                                        02990000
|   WRITELN(OUTPUT);                                                      03000000
| END (*PRINTWORD*) ;                                                     03010000
|                                                                         03020000
| PROCEDURE PRINTTABLE;                                                   03030000
|   VAR I,N: INDEX;                                                       03040000
| BEGIN N := 0;    (*COMPRESS TABLE*)                                     03050000
|   FOR I := 0 TO P-1 DO                                                  03060000
|     IF T[I].KEY <> EMPTY THEN                                           03070000
|       BEGIN T[N] := T[I]; N := N+1                                      03080000
|       END ;                                                             03090000
|   IF N > 0 THEN SORT(0,N-1);                                            03100000
|   NOPL := (LLNGOUT-KLN-1) DIV DGPN;                                     03110000
| # M := LPPG; SPACE(1); WRITELN(' CROSS REFERENCE OF IDENTIFIERS,',      03120000
|             ' LABEL DECLARATIONS AND GOTO STATEMENTS:');                03130000
| # COUNTLINE; SPACE(1);  C1 := N;  C2 := 0;                              03140000
|   FOR I := 0 TO N-1 DO PRINTWORD(T[I])                                  03150000
| END (*PRINTTABLE*) ;                                                    03160000
|                                                                         03170000
| PROCEDURE PRINTPROCS;                                                   03180000
| BEGIN SPACE(2); COUNTLINE;                                              03190000
|   WRITELN(' LIST OF PROCEDURES AND FUNCTIONS:');                        03200000
| # C3 := 0;  COUNTLINE;  SPACE(1);                                       03210000
|   PROCPTR := FIRSTPROC@.NEXT;                                           03220000
|   WHILE PROCPTR <> NIL DO                                               03230000
|     BEGIN WITH PROCPTR@ DO WRITELN(NAME:24,LNO:10);                     03240000
| #     C3 := C3+1;  COUNTLINE; PROCPTR := PROCPTR@.NEXT                  03250000
|     END;                                                                03260000
| # SPACE(2);                                                             03270000
| # WRITELN(OUTPUT, ' # OF IDENTIFIERS: ', C1:1, ',  # OF OCCURENCES: ',  03280000
| #                 C2:1, ',  # OF PROCEDURES: ', C3:1, '.');             03290000
| END (*PRINTPROCS*) ;                                                    03300000
|                                                                         03310000
| PROCEDURE INITIALIZE;                                                   03320000
|   TYPE SETTING = PACKED RECORD                                          03330000
|                    CASE SWITCH: BOOLEAN OF                              03340000
|                      TRUE: (ONOFF: CHAR);                               03350000
|                      FALSE: (SIZE: 0..999999)                           03360000
|                    END;                                                 03370000
|   VAR S: SETTING;                                                       03380000
|   FUNCTION OPTION(NAME: CHAR; VAR S: SETTING): BOOLEAN;                 03390000
|     EXTERNAL;                                                           03400000
| BEGIN N := 0; M := 0;                                                   03410000
|   LLNGIN := LLMAX; LLNGOUT := LLMAX;                                    03420000
| """IF OPTION('U',S) THEN                                                03430000
|     IF S.SWITCH AND (S.ONOFF = '+')                                     03440000
|       THEN LLNGIN := LLMIN;                                             03450000
|   IF OPTION('W',S) THEN                                                 03460000
|     IF S.SWITCH AND (S.ONOFF = '+')                                     03470000
|       THEN LLNGOUT := LLMIN;    """                                     03480000
|   FOR I := 0 TO P-1 DO T[I].KEY := EMPTY;                               03490000
|   NEW(PROCPTR); FIRSTPROC := PROCPTR; PROCPTR@.NEXT := NIL;             03500000
|   PROCORFUNC := TRUE;   (*TO GET P R O G R A M NAME IN PROCEDURE INDEX*)03510000
|   KEY[ 1] := 'AND       '; KEY[ 2] := 'ARRAY     ';                     03520000
|   KEY[ 3] := 'BEGIN     '; KEY[ 4] := 'CASE      ';                     03530000
|   KEY[ 5] := 'CONST     '; KEY[ 6] := 'DIV       ';                     03540000
|   KEY[ 7] := 'DOWNTO    '; KEY[ 8] := 'DO        ';                     03550000
|   KEY[ 9] := 'ELSE      '; KEY[10] := 'END       ';                     03560000
|   KEY[11] := 'FILE      '; KEY[12] := 'FOR       ';                     03570000
|   KEY[13] := 'FUNCTION  '; KEY[14] := 'IF        ';                     03580000
|   KEY[15] := 'IN        '; KEY[16] := 'MOD       ';                     03590000
|   KEY[17] := 'NIL       '; KEY[18] := 'NOT       ';                     03600000
|   KEY[19] := 'OF        '; KEY[20] := 'OR        ';                     03610000
|   KEY[21] := 'PACKED    '; KEY[22] := 'PROCEDURE ';                     03620000
|   KEY[23] := 'PROGRAM   '; KEY[24] := 'RECORD    ';                     03630000
|   KEY[25] := 'REPEAT    '; KEY[26] := 'SET       ';                     03640000
|   KEY[27] := 'THEN      '; KEY[28] := 'TO        ';                     03650000
|   KEY[29] := 'TYPE      '; KEY[30] := 'UNTIL     ';                     03660000
|   KEY[31] := 'VAR       '; KEY[32] := 'WHILE     ';                     03670000
|   KEY[33] := 'WITH      '                                               03680000
| END (*INITIALIZE*) ;                                                    03690000
|                                                                         03700000
| PROCEDURE SCANANDLISTINPUT;                                             03710000
| BEGIN                                                                   03720000
|   WHILE NOT EOF(INPUT) DO                                               03730000
|   BEGIN NEWLINE;                                                        03740000
|     WHILE NOT EOLN(INPUT) DO                                            03750000
|     CASE INPUT@ OF                                                      03760000
|      'a','b','c','d','e','f','g','h','i','j','k','l','m',               03770000
|      'n','o','p','q','r','s','t','u','v','w','x','y','z',               03780000
|      'A','B','C','D','E','F','G','H','I','J','K','L','M',               03790000
|      'N','O','P','Q','R','S','T','U','V','W','X','Y','Z':               03800000
|       BEGIN K := 0; ID.A := EMPTY;                                      03810000
|         REPEAT                                                          03820000
|           IF K < KLN THEN                                               03830000
|             BEGIN K := K+1; ID.A[K] := INPUT@                           03840000
|             END;                                                        03850000
|           ADVANCE                                                       03860000
| """     UNTIL NOT(INPUT@ IN ['A'..'Z', '0'..'9']);   """                03870000
|         UNTIL NOT(LETTER(INPUT@) OR DIGIT(INPUT@) OR SPECIAL(INPUT@));  03880000
|         IF NOKEY THEN                                                   03890000
|         BEGIN SEARCH;                                                   03900000
|           IF PROCORFUNC THEN NOTEPROC                                   03910000
|         END ELSE                                                        03920000
|         IF (ID.A = 'PROCEDURE ') OR (ID.A = 'FUNCTION  ') THEN          03930000
|           PROCORFUNC := TRUE                                            03940000
|       END;                                                              03950000
|      '0','1','2','3','4','5','6','7','8','9':                           03960000
|         REPEAT ADVANCE;                                                 03970000
| """     UNTIL NOT (INPUT@ IN ['B','E','0'..'9']);  """                  03980000
|         UNTIL NOT DIGIT(INPUT@) ;                                       03990000
|      '''':                                                              04000000
|       BEGIN (*STRING*)                                                  04010000
|         REPEAT ADVANCE;                                                 04020000
|         UNTIL (INPUT@ = '''') OR EOLN(INPUT);                           04030000
|         IF NOT EOLN(INPUT) THEN                                         04040000
|           ADVANCE                                                       04050000
|       END;                                                              04060000
| #    '"':                                                               04070000
|       BEGIN (*COMMENT*)                                                 04080000
|         REPEAT ADVANCE;                                                 04090000
|           WHILE EOLN(INPUT) DO                                          04100000
|             BEGIN WRITELN(OUTPUT); GET(INPUT); NEWLINE                  04110000
|             END                                                         04120000
|         UNTIL INPUT@ = '"';                                             04130000
|         ADVANCE                                                         04140000
|       END;                                                              04150000
|      '¯':                                                   (* 86180 *) 04160000
|       BEGIN (*COMMENT*)                                     (* 86180 *) 04170000
|         REPEAT ADVANCE;                                     (* 86180 *) 04180000
|           WHILE EOLN(INPUT) DO                              (* 86180 *) 04190000
|             BEGIN WRITELN(OUTPUT); GET(INPUT); NEWLINE      (* 86180 *) 04200000
|             END                                             (* 86180 *) 04210000
|         UNTIL INPUT@ = 'ò';                                 (* 86180 *) 04220000
|         ADVANCE                                             (* 86180 *) 04230000
|       END;                                                  (* 86180 *) 04240000
|      '(':                                                               04250000
|       BEGIN ADVANCE;                                                    04260000
|         IF INPUT@ = '*' THEN                                            04270000
|         BEGIN (*COMMENT*) ADVANCE;                                      04280000
|           REPEAT                                                        04290000
|             WHILE INPUT@ <> '*' DO                                      04300000
|             BEGIN                                                       04310000
|               IF EOLN(INPUT) THEN                                       04320000
|                 BEGIN GET(INPUT); WRITELN(OUTPUT); NEWLINE              04330000
|                 END ELSE                                                04340000
|                 ADVANCE                                                 04350000
|             END ;                                                       04360000
|             ADVANCE                                                     04370000
|           UNTIL INPUT@ = ')';                                           04380000
|           ADVANCE                                                       04390000
|         END                                                             04400000
|       END;                                                              04410000
|      '+','-','*','/',')','$','=',' ',',','.','[',']',                   04420000
|      ':','!','×','&','@','?','<','>','Ö','\','^',';','#','_','%','ò':   04430000
|       ADVANCE                                                           04440000
|     END (*CASE*) ;                                                      04450000
|     WRITELN(OUTPUT); GET(INPUT)                                         04460000
|   END ;                                                                 04470000
| END (*SCANANDLISTINPUT*) ;                                              04480000
|                                                                         04490000
| BEGIN (*CROSSREF*)                                                      04500000
| """LINELIMIT(OUTPUT, MAXN);PAGE(OUTPUT)"""  ; INITIALIZE;               04510000
|   IF NOT EOF(INPUT) THEN                                                04520000
|   BEGIN SKIPCOMPILERTITLE;                                              04530000
|     SCANANDLISTINPUT; """LINELIMIT(OUTPUT, MAXN); """                   04540000
|     PRINTTABLE; PRINTPROCS                                              04550000
|   END ELSE WRITELN(STARS,' NO PROGRAM FOUND TO CROSS REFERENCE',STARS); 04560000
| 99:END .                                                                04570000
> Member PAT
| (*$M-*)
| program pat;
| 
| 
| 
|     ¯***********************************************ò
|     ¯*       PAL     (pat,lalr)                    *ò
|     ¯*                                             *ò
|     ¯*   PATTERN  ACTION  LANGUAGE                 *ò
|     ¯*                                             *ò
|     ¯*    AUTHOR  :   G. POONEN                    *ò
|     ¯*                                             *ò
|     ¯*    modification :  J. Bloch, H. Eskin       *ò
|     ¯*    modification :  G. Minshall              *ò
|     ¯*                                             *ò
|     ¯*     VERSION :                               *ò
|     ¯*                                             *ò
|     ¯*      DATE    :        December, 1983        *ò
|     ¯*                                             *ò
|     ¯***********************************************ò
| 
| ¯ Dependancies - The algorithm for making a character
|         upper case DEPENDS on (ord(LowerCaseLetter)-ord(UpperCaseLetter))
|         being constant as 'Letter' varies from 'a' to 'z'
|         (Both ASCII and EBCDIC have this property).
| ò
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
|     ¯  GLOBAL DECLARATIONS  ò
|     ¯***********************ò
| 
| 
| 
|     ¯ GLOBAL constANTSò
|   const
|     XCONTINUE = 9996 ;     ¯ CODE FOR CONTINUE IN TABLE ò
|     ELSECODE = 9997  ;
|     NOSCANCODE   = 9998 ; ¯ CODE FOR SCANò
|     ERRORCODE = 9999 ;    ¯ CODE FOR ERROR IN TABLE ò
|     UNKNOWN=-9999 ;       ¯ UNKNOWN QTY ò
|     MAXSEGMENT = 200 ;
|     MAXTABSIZE =3000;
|     MAXADDR    = 4*65536-1;
|     MAXNAME    = 15   ;   ¯ MAX LENGTH OF NAMES  (was 15) ò
|     MAXERR     =  20  ;   ¯ MAX ERRORS PER LINEò
|     MAXERRNmr  =  200 ;   ¯ MAX ERROR NUMBERò
|     MAXLINECNT =   132;   ¯  LINE COUNTò
|     GTMAXERR   =  199 ;   ¯ EXCEEDED MAX ERRORS PER LINEò
|     MAXSYM     =    6 ;   ¯ SIZE OF SPECIAL SYMBOLSò
|     STATETABSIZE= 2000 ;  ¯ was 1000 ò
|     MAXSTATE = 2000 ;     ¯ was 1000 ò
|     MAXRHS = 32 ;
|     MAXVISIT = 3200  ;    ¯ MAX NO OF STATES VISITED FOR ò
|                           ¯ RESOLVING LA STATES ò ¯ was 1600ò
| 
|     MAXVOCSIZE = 2048 ;   ¯ MAX VOCABULARY CODE (was 512) ò
|     MAXTERMINALS = 1023 ; ¯ was 255 ò
|     NAMETABSIZE = 4001 ;  ¯ KEEP IT PRIME  (was 1023) ò
|     MAXRULENO    = 4001 ; ¯ KEEP IT PRIME  (was 1023) ò
|     DIGMAX    =    5 ;    ¯ MAXIMUM NUMBER of DIGITS FOR INTEGERò
|     THRESHOLD =3 ;        ¯ USED FOR SORTING AND MATCHING LISTSò
|     FILENAMELEN = 133 ;   ¯ MAX charACTERS IN FILESPECò
|     B14 = 12;             ¯ was 14B in DEC version ò
|     WHITESPACE = [ ' ' ]; ¯ What INsymbol skips. ò
| 
| 
|     ¯ GLOBAL typeS ò
| type
|     word  =  packed array [1 .. MAXNAME] of char ;
|     symbol =  (Ident ,Res, Intconst,  SemiSy, SlashSy, OrSy, EqSy, ColSy
|     ,PeriodSy    ) ;
|     setofsymbol = set of symbol ;
|     namety = (Term,NonTerm,
|               Lab
|               ) ;
|     codety = -1 .. MAXTERMINALS ;
|     listptrty = @ list ;
|     list   =  packed  record
|                              CDR     : listptrty;
|                              CAR     : 1 .. '5FFF'X
|                       end ;
|     setofnamety = set of namety ;
| 
| 
|     ¯  NAME TABLE ENTRIES   ò
|     ¯***********************ò
| 
|     identptrty = @ identry ;
|     prodptrty  = @ prod ;
|     identry   =   record
|                          Nic     : identptrty;
|                          FirstAlt: prodptrty;
| 
|                          Defin   : listptrty;
|                          UsedIn  : listptrty;
|                          InternalName,
|                          ExternalName    : word   ;
|                          Kind    : namety ;
|                          SpId    : symbol ;
|                          Code    : codety
|                   end ;
|     prod = record
|                   Next   : prodptrty;
|                   XDef   : identptrty;
|                   Action : identptrty;
|                   NxtAlt : prodptrty;
|                   Production : 1 .. MAXRULENO
|            end ;
| 
| 
|     ¯  STATE ENTRIES ò
|     ¯****************ò
|     statekind     = (Reads,Inadequate,Lookahead,Reduction,Subgoal,LAString) ;
|     stateptrty    = @ statety ;
|     tranlistptr   = @ tranlist ;
|     statelistptr  = @ statelist ;
|     tranptrty     = @ tranty ;
|     statety = record
|                  FirstTran : tranptrty  ;
|                  Back      : tranptrty ;
|                  Nic       : stateptrty ;
|                  State     : 0 .. MAXSTATE ;
|                  Kind      : statekind
|               end ;
| 
|     statelist = record
|                   CAR : stateptrty ;
|                   CDR : statelistptr
|                 end ;
|     tranlist = record
|                   CAR : tranptrty ;
|                   CDR : tranlistptr
|                end ;
|     tranty =  packed record
|                         Next      : tranptrty ;
|                         NextState : stateptrty ;
|                         Rule      : prodptrty ;
|                         Pos       : 0 .. MAXRHS ;
|                         MarkE     : BOOLEAN
|                      end ;
| 
|     ¯ type specifiers for OPEN procedure ò
|     openOptions = ( OpenInput, OpenOutput, OpenUppercase );
|     openOption  = set of openOptions;
|     filenameType = packed array [1 .. FILENAMELEN] of char  ;
|     promptType = packed array[1..121] of char;
| 
| 
| 
| 
|     ¯ GLOBAL varIABLES ò
| var
|     Heap,HeapBot,HeapTop      : @integer ; ¯ MARKS Heap ò
|     Visit   : array [ 1.. MAXVISIT ] of tranptrty ;
|     CurrentVisit : integer ;
| 
|     ¯ Table ENTRIES ò
| 
| 
|     Table : array [0 .. MAXTABSIZE] of packed record
|                                               Tran : integer ;
|                                               Action : integer
|                                        end ;
|     Index : -1 .. MAXTABSIZE ;
|     Segment : array [0 .. MAXSEGMENT] of packed record
|                                                 Tran : integer ;
|                                                 Action : integer
|                                          end ;
|     SegIndex : -1 .. MAXSEGMENT ;
|     NewState : array [0 .. MAXSTATE] of integer ;
| 
| 
|     SymbolName : packed array [0 .. MAXVOCSIZE] of identptrty;
|     NameTab  :  array [0 .. NAMETABSIZE ] of identptrty ;
|     RuleTab   :  array [1 .. MAXRULENO ] of   prodptrty;
|                  ¯  Contains no. of elements on rhs e.g  ò
|                  ¯  X =  A   B   C    will be 3          ò
|     PopTab  : array [ 1 .. MAXRULENO ] of integer ;
| 
|     NState : array [0 .. MAXSTATE ] of stateptrty ;
|     StateTab  : array [0 .. STATETABSIZE ] of stateptrty ;
|     Inadeq,Conflict : statelistptr ; ¯ list of Inadequate StateS ò
|     CurrentState : 0 .. MAXSTATE ;
|     Sy     : symbol  ; ¯ LAST symbolò
|     SyLeng : integer ; ¯ LENGTH of symbolò
|     SyKey  : integer ; ¯ symbol KEY      ò
| 
|     SyVal : integer ;
|     MaxK  : integer ; ¯ MAX VAL of Lookahead ò
|     InternalId,               ¯ symbol InternalName     ò
|     ExternalId    :  word   ; ¯ symbol ExternalName     ò
|     Ch    :  char   ; ¯ LAST charACTER  ò
|     InSymbolState : ( InSymbolNormalState, InSymbolStringState );
|                     ¯ that is: returning a string, or just normal
|                         processing ò
| 
|     ChCnt : integer ;
|     Letters
|     ,Digits  :  set of char   ;
| 
|    MaxPop     : integer ;
|    MaxCode    : integer ;
|    MaxProdNo  : 0 .. MAXRULENO ;
|       ProdNo  : 0 .. MAXRULENO ;
| 
|     L      : integer ; ¯ CONTROL varIABLE ò
| 
|                        ¯  OPTION FLAGS  ò
|     ListFl                  ¯ L ò
|     , Look                  ¯ A ò
|     , Grammar               ¯ G ò
|     , Debug                 ¯ D ò
|     , Optimize              ¯ O ò
|     , Trace                 ¯ R - Print trace info during run ò
|     , Tables                ¯ T ò
|     , PN                    ¯ P ò
|     , Terminals             ¯ S ò
|     , Frequency             ¯ F ò
|     , Lr0                   ¯ C ò
|     , IFSM                  ¯ I ò
|     , Research              ¯ Z ò
|     , Symbolic              ¯ Y - The state tables should be symbolic ò
|     , NonTerminals          ¯ N - Put non terminals in .TER ò
|     , FSM      :   boolean; ¯ M ò
| 
|     ¯  ERROR  list  ò
| 
|     FatalError,
|     ErrorFlag  : boolean ;
|     ErrInx   :   integer   ;   ¯ NO of ERRORS IN THIS LINEò
|     ErrList  :  array  [1 .. MAXERR]  of
|                     record
|                       Pos :  0 .. MAXLINECNT ;
|                       Nmr :  0 .. MAXERRNmr
|                     end ;
|     ¯  FILES  ò
|     Filename  :  filenameType;
|       TTYOut                                 ¯  Console output ò
|     , CrefPas                                ¯  Cref       ò
|     , TerPas                                 ¯  Terminals  ò
|     , NewPrgPas                              ¯  Formatted Grammar ò
|     , TabPas                                 ¯  Tables ò
|     , PNPas    :  text;                      ¯  Production num ò
| 
|     ¯  LALR  ò
|     LrK
|     :  boolean    ;
| 
|     ¯  SPECIAL symbolS  ò
|     SpList   :  array [1 .. MAXSYM]  of char  ;
|     SpSy    :  array [1 .. MAXSYM]  of symbol  ;
| 
| LowerCaseLetters : set of char;
| 
| 
| ¯ The following are for the Arguments part of the implementation
|         specific part of the Pascal/VS version (IBM)
| ò
|     OurArgs : packed array[1..255] of char;
|     OurArgsIndex,
|     OurArgsLength : integer;
|     OurArgsUpperCase : boolean;
| 
| 
| 
| 
| 
| 
| 
| 
| 
| ¯ The following proceduRes are, hopefully,
|     the only PASCAL/VS specific proceduRes.  Thus, to move to a new
|     environment, one should only need to change the way they deal
|     with your new I/O system.  NOTE that 'filename' is something
|     one might have to reformat.
|         (greg minshall - 12/10/83)
| ò
| 
| ¯ OPEN - this procedure opens a file, doing ResET or REWRITE as
|     necessary
| ò
| 
| procedure open( var f          : text;
|                 const filename : filenametype;
|                 const options  : openOption );
| %include CMS
| var
|     opts : string(50);
|     fn   : string(40);
|     rc   : integer;
| begin
|     assert (( OpenInput in options ) or ( OpenOutput in options )) and
|            not (( OpenInput in options ) and ( OpenOutput in options ));
| 
|     if OpenUppercase in options then
|         opts := 'UCASE '    ¯ translate input to UPPER case ò
|     else
|         opts := '';
| 
|     fn := trim(ltrim(compRess(str(filename))));
| 
|     if fn = 'TTY:' then begin
|         opts := opts ×× 'DDNAME=STDIN';
|         cms( 'FILEDEF STDIN CLEAR', rc );
|         cms( 'FILEDEF STDIN TermINAL ( LRECL 255 BLOCK 255', rc );
|         if OpenInput in options then
|             Reset( f, opts )
|         else
|             rewrite( f, opts );
|     end else begin
|         opts := opts ×× 'NAME=' ×× fn;
|         if OpenInput in options then
|             Reset( f, opts )
|         else
|             rewrite( f, opts );
|     end;
| end;
| 
| ¯ CanOpen - this boolean function returns TRUE if the filename
|           LookS ok, FALSE otherwise
| ò
| function CanOpen( const filename : filenametype ) : boolean;
| %include CMS
| var
|     myfile : filenametype;
|     index,
|     rc     : integer;
| begin
|     for index := 1 to filenamelen do
|         if filename[index] = '.' then
|             myfile[index] := ' '
|         else
|             myfile[index] := filename[index];
| 
|     cms( 'SET CMStype HT', rc );
| 
|     cms( 'State ' ×× str(myfile), rc );
|     CanOpen := rc = 0;
| 
|     cms( 'SET CMStype RT', rc );
| end;
| 
| PROCEDURE BREAK;
| BEGIN
|     ¯ DEC has a procedure called BREAK, which causes the output
|         buffer to be flushed.  Here is my version - it is
|         good for nothing!
|     ò
| end;
| 
| 
| ¯ The following proceduRes are designed to allow PAT to get arguments
|     from the users.  In the Pascal/VS version, we get the options from
|     the command line.  In other versions, one might (as in the DEC
|     version this started from) write a prompt, and the read from the
|     terminal.
| ò
| 
| procedure InitArgs;
| var
|     TempArgs : string(255);
|     Index : integer;
| begin
|     TempArgs := parms;          ¯ parms is a function, returns parms
|                                   from the command line ò
|     OurArgs := TempArgs;        ¯ Pascal/VS converts ò
|     OurArgsIndex := 1;
|     OurArgsLength := length(TempArgs);
|     while (OurArgs[OurArgsIndex] = ' ') and
|           (OurArgsIndex <= OurArgsLength) do
|             OurArgsIndex := OurArgsIndex+1;
|     OurArgsUpperCase := FALSE;
| end;
| 
| 
| procedure PromptArgs( Prompt : promptType );
| begin
|     ¯ We don't use this at all ò
| end;
| 
| 
| procedure OpenArgs( Options : openOption );
| begin
|     if OpenUppercase in Options then
|         OurArgsUpperCase := TRUE
|     else
|         OurArgsUpperCase := FALSE;
| end;
| 
| 
| Procedure GetArgCh( var ch : char; var EndLine, EndArgs : boolean );
| begin
|     if OurArgsIndex > OurArgsLength then begin
|         EndArgs := TRUE;
|         Ch := ' ';
|     end else begin
|         EndArgs := FALSE;
|         Ch := OurArgs[OurArgsIndex];
|         if (Ch in LowerCaseLetters) and OurArgsUpperCase then
|             Ch := chr( ord(Ch) + ord('A')-ord('a') );
|         OurArgsIndex := OurArgsIndex+1;
|         if  Ch = ' ' then begin
|             EndLine := TRUE;
|             while (OurArgs[OurArgsIndex] = ' ') and
|                   (OurArgsIndex <= OurArgsLength) do
|                         OurArgsIndex := OurArgsIndex+1;
|         end else
|             EndLine := FALSE;
|     end;
| end;
| 
| 
| procedure SetReturnCode( I : integer );
| ¯ In CMS, error code is propagatable back to caller, so let
|     them know...
| ò
| begin
|     retcode(i);     ¯ CMS Pascal/VS primitive ò
| end;
| 
| 
| 
| 
| ¯ Thus ends, hopefully, the implementation dependent part
|     of PAT.
|         greg minshall, 12/83
| ò
| 
| 
| 
| 
| procedure InitSp;
| begin
|         SpList  [1] :=  '!'    ;  SpSy [1] := OrSy ;
|         SpList  [2] :=  '/'    ;  SpSy [2] := SlashSy ;
|         SpList  [3] :=  ';'    ;  SpSy [3] := SemiSy ;
|         SpList  [4] :=  '='    ;  SpSy [4] := EqSy ;
|         SpList  [5] :=  ':'    ;  SpSy [5] := ColSy ;
|         SpList  [6]  := '.' ;    SpSy [6] := PeriodSy
| end;
| 
| 
|     ¯used to be an initprocedureò
|     procedure  InitOptions ;  ¯  DEFAULT OPTIONSò
|       begin
|         Optimize   :=   FALSE   ;
|         Tables     :=   TRUE   ;
|         PN         :=   FALSE   ;
|         Terminals  :=   TRUE   ;
|         Frequency  :=   FALSE   ;
|         FSM        :=   FALSE   ;
|         Grammar    :=   TRUE   ;
|         Look       :=  TRUE   ;
|         ListFl     :=  TRUE   ;
|         Lr0        :=  TRUE   ;
|         IFSM       :=  TRUE   ;
|         Research   :=   FALSE ;
|         Debug      :=   FALSE ;
|         Trace      :=   FALSE ;
|         Symbolic   :=   FALSE ;
|         NonTerminals := FALSE ;
| 
|         MaxK  :=  1     ; ¯  DEFAULT Lookaheadò
|       end  ;
| 
| 
| 
| 
|     procedure InitGlob ;    ¯ GLOBAL varIABLES  ò
|     ¯used to be an initprocedureò
|       begin
|         FatalError := FALSE;
|         ErrorFlag := FALSE ;
|         Conflict := NIL ;
|         Inadeq := NIL   ;
|         ErrInx := 0     ;
|         InSymbolState := InSymbolNormalState;
|         LowerCaseLetters := [ 'a', 'b', 'c', 'd', 'e', 'f',
|             'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
|             'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ];
|       end ;
| 
| 
| 
|     procedure   EndOfLine  ;
|         ¯*******************************************************ò
|         ¯*                                                     *ò
|         ¯*   end of LINE                                       *ò
|         ¯*                                                     *ò
|         ¯*       THIS procedure WRITES OUT THE                 *ò
|         ¯*     CURRENT LINE AND FOLLOWS IT WITH                *ò
|         ¯*     ANY ERROR MESSAGES AND POINTERS.                *ò
|         ¯*                                                     *ò
|         ¯*                                                     *ò
|         ¯*      GLOBAL IN: ErrInx  NO. of ERRORS IN THIS LINE  *ò
|         ¯*                                                     *ò
|         ¯*                 ErrList array CONTAINING            *ò
|         ¯*                         ATTRIBUTES of ERROR         *ò
|         ¯*                                                     *ò
|         ¯*                 list    listING REQUIRED IF         *ò
|         ¯*                         TRUE.                       *ò
|         ¯*                                                     *ò
|         ¯*         OUT :  ErrInx   set TO 0                    *ò
|         ¯*                                                     *ò
|         ¯*                                                     *ò
|         ¯*******************************************************ò
|     var
|         LastPos
|         , FreePos
|         , CurrPos
|         , CurrNmr
|         ,  F                ¯  FORMAT  ò
|         ,  K                ¯  LOOP CONTROL  ò
|         :  integer  ;
| 
|       begin
|         readln; writeln;
|         if ErrInx > 0 then  ¯OUTPUT ERROR MESSAGESò
|           begin
|             write('****');
|             LastPos := 0; FreePos := 1;
|             for K := 1 to ErrInx do
|               begin
|                 with ErrList[K] do
|                   begin
|                     CurrPos := Pos; CurrNmr := Nmr
|                   end;
|                 if CurrPos = LastPos then write(',')
|                 else
|                   begin
|                     while FreePos < CurrPos do
|                       begin
|                         write(' '); FreePos := FreePos + 1
|                       end;
|                     write('@');
|                     LastPos := CurrPos
|                   end;
|                 if CurrNmr= 0 then F:= 0
|                 else if CurrNmr < 10 then F :=1
|                 else if CurrNmr < 100 then F := 2
|                 else F := 3;
|                 if F <> 0 then write(CurrNmr:F);
|                 FreePos:=FreePos+F+1
|               end;
|             writeln; ErrInx :=0
|           end;
|         ChCnt := 0
|       end  ¯EndOfLineò ;
| 
| 
| 
|     procedure   Error  (FErrNr : integer) ;
|         ¯******************************************************ò
|         ¯*                                                    *ò
|         ¯*        Error                                       *ò
|         ¯*                                                    *ò
|         ¯*     THIS procedure recordS THE Error               *ò
|         ¯*  AND PosITION of OCCURRENCE                        *ò
|         ¯*                                                    *ò
|         ¯*    GLOBAL  IN :  ChCnt   INDICATE PosITION         *ò
|         ¯*                          ON LINE                   *ò
|         ¯*                                                    *ò
|         ¯*                                                    *ò
|         ¯*                                                    *ò
|         ¯*         OUT :  ErrorFlag                           *ò
|         ¯*                ErrList     array of ErrorS         *ò
|         ¯*                ErrInx                              *ò
|         ¯*                                                    *ò
|         ¯*                            I                       *ò
|         ¯*                                                    *ò
|         ¯******************************************************ò
|       begin
|         ¯  Error ò
|         ErrorFlag :=  TRUE  ;
|         if ErrInx >= MAXERR  then
|           begin
|             ErrList [ MAXERR ].Nmr :=  GTMAXERR  ;
|           end
|         else
|           begin
|             ErrInx  :=  ErrInx +1  ;
|             ErrList [ErrInx] . Nmr := FErrNr  ;
|             ErrList [ErrInx].Pos   :=  ChCnt   ;
|           end  ;
|       end  ;
|     ¯  Error ò
| 
| 
| 
| 
|     procedure  NextCh   ;
|         ¯*******************************************************ò
|         ¯*                                                     *ò
|         ¯*  NextCh.                                            *ò
|         ¯*                                                     *ò
|         ¯*     THIS procedure RETURNS THE Next charACTER       *ò
|         ¯* IN Ch                                               *ò
|         ¯*                                                     *ò
|         ¯*                                                     *ò
|         ¯*                                                     *ò
|         ¯*   GLOBAL      IN:   ChCnt                           *ò
|         ¯*                     ListFl        boolean OPTION    *ò
|         ¯*                                                     *ò
|         ¯*              OUT:   ChCnt                           *ò
|         ¯*                                                     *ò
|         ¯*                      Ch         Next charACTER      *ò
|         ¯*                                                     *ò
|         ¯*******************************************************ò
|       begin
|         ¯ NextCh ò
|         if not ( eoln(Input) or eof(Input) )  then
|           begin
|             read (Ch)  ;
|             if ListFl then write (Ch)  ;
|             ChCnt :=  ChCnt +1  ;
|           end
|         else   Ch := ' '  ;
|       end   ;
| 
| 
| 
|     procedure  InSymbol  ;
|         ¯*******************************************************ò
|         ¯*                                                     *ò
|         ¯*   InSymbol                                          *ò
|         ¯*                                                     *ò
|         ¯*       THIS procedure RETURNS THE Next               *ò
|         ¯*  symbol FROM THE SOURCE Input                       *ò
|         ¯*                                                     *ò
|         ¯*  GLOBAL  IN:  Ch     Next charACTER                 *ò
|         ¯*              SP list                                *ò
|         ¯*              SP Sy                                  *ò
|         ¯*                                                     *ò
|         ¯*         OUT :  SyLeng    symbol LENGTH              *ò
|         ¯*                Sy        symbol type                *ò
|         ¯*                InternalId[I]     symbol charACTERS  *ò
|         ¯*                SyKey     KEY for IdentifIERS        *ò
|         ¯*                                                     *ò
|         ¯*                                                     *ò
|         ¯*                                                     *ò
|         ¯*******************************************************ò
| 
|     label
|         3;
|     var
|         I,K : integer ;
|         Noteoln,
|         Noteof : boolean;
| begin ¯ InSymbol ò
|     if InSymbolState = InSymbolStringState then begin
|         ExternalId[1] := '''';
|         ExternalId[2] := Ch;
|         SyKey := ord(Ch);
|         ExternalId[3] := '''';
|         if Ch = '''' then
|             ExternalId[4] := ''''
|         else
|             ExternalId[4] := ' ';
|         for i := 5 to MAXNAME do
|             ExternalId[i] := ' ';
|         Sy := Res;
|         InternalId := ExternalId;
|                 ¯ End of lines and files terminate strings ò
|         if eoln(Input) or eof(Input) then
|             InSymbolState := InSymbolNormalState;
|         Nextch;
|         if Ch = '''' then begin
|             Nextch;
|             if Ch <> '''' then
|                 InSymbolState := InSymbolNormalState;
|         end;
|     end else begin
|         repeat begin
|             repeat begin
|                 if  eoln(Input)  then EndOfLine ;
|                 if  not ( Ch in WHITESPACE ) then
|                     leave;
|                 NextCh   ;          ¯ skip whitespace ò
|             end until eof(Input);
|             if (Ch <> '¯') AND (Ch <> '%') then
|                 leave;
|             if  Ch = '%' then
|             begin
|                 NextCh   ;
|                 repeat begin
|                     if  eoln(Input)  then EndOfLine ;
|                     if  Ch = 'Ö' then
|                         leave;
|                     NextCh
|                 end until eof(Input);
|             end;
|             if  Ch = '¯' then
|             begin
|                 NextCh   ;
|                 repeat begin
|                     if  eoln(Input)  then EndOfLine ;
|                     if  Ch = 'ò' then
|                         leave;
|                     NextCh
|                 end until eof(Input)
|             end;
|             NextCh
|         end until eof(Input);
|         SyLeng  := 0 ;
|         SyVal :=0 ;
|         SyKey   := 0 ;
|         if  Ch  in  Letters  then begin
|             K  := 0   ;
|             repeat
|                 if  K  <MAXNAME   then begin
|                     K := K+1 ;
|                     ExternalId[K] := Ch   ;
|                     if Ch in LowerCaseLetters then
|                         InternalId[K] := chr( ord(ch) + ord('A')-ord('a') )
|                     else
|                         InternalId[K] := Ch;
|                     SyKey  := SyKey + ord(InternalId[K]);
|                   end   ;
| 
|                 NextCh
|             until  not  (Ch in Letters + Digits) ;
|             if K < MAXNAME  then
|             for I := K+1 to MAXNAME do begin
|                 ExternalId[I] := ' ' ;
|                 InternalId[I] := ' ' ;
|             end;
|             Sy  := Ident   ;
|           end
|         else  if  Ch  in  Digits  then begin
|             Sy := Intconst ;
|             I  :=  0     ;   SyVal :=0;
|             repeat
|                 I := I+1 ;
|                 if   I < DIGMAX then
|                 SyVal := SyVal*10  + ord (Ch) - ord ('0') ;
|                 ExternalId[I] := Ch      ;
|                 NextCh
|             until  not  (Ch in Digits)   ;
|             if I < MAXNAME then
|             for I:= I+1 to MAXNAME  do  ExternalId[I] := ' ';
|             InternalId := ExternalID;
|         end
|         else if Ch = '''' then begin
|             InSymbolState := InSymbolStringState;
|             Nextch;
|             if Ch = '''' then begin
|                 Nextch;
|                 if Ch <> '''' then    ¯ If TRUE, null symbol - ignore ò
|                     InSymbolState := InSymbolNormalState;
|             end;
|             InSymbol;           ¯ recurse to start reading string ò
|         end else begin
|             for I := 1 to MAXSYM do begin
|                 if SpList[I]= Ch  then begin
|                     Sy := SpSy [I] ;
|                     GOto 3 ;
|                 end ;
|             end ;
|             3 : ExternalId[1] := Ch;
|             NextCh ;
|             for I:= 2 to MAXNAME  do ExternalId[I]:= ' ';
|             InternalID := ExternalID;
|         end ;
|         if Trace then begin
|             writeln(TTYOut,InternalId,' ',SyVal:3);BREAK
|         end;
|     end;
| end  ;
|         ¯  InSymbol  ò
| 
| 
| 
|     procedure   InitP ;
|         ¯***********************************************************ò
|         ¯*                                                         *ò
|         ¯*    InitP                                                *ò
|         ¯*                                                         *ò
|         ¯*        THIS procedure Reads in THE OPTIONS              *ò
|         ¯*   AND ALSO inITIALIZES ANY Tables AS                    *ò
|         ¯*   REQUIRED                                              *ò
|         ¯*                                                         *ò
|         ¯***********************************************************ò
|     var
| 
|         ChNext : char;
|         EndLine,
|         EndArgs : boolean;
|         I : integer ;
|         Distance,Dot,J, RBrak,Colon
|                 : 0..FILENAMELEN;       ¯PLACE MarkERS in FILESPECò
|         procedure     InitSets   ;
|         var
|             L : integer ;
|           begin
|             Digits := ['0','1','2','3','4','5','6','7','8','9'] ;
|             Letters:= ['A','B','C','D','E','F','G','H','I','J','K',
|             'L','M','N','O','P','Q','R','S','T','U','V',
|             'W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k',
|             'l','m','n','o','p','q','r','s','t','u','v',
|             'w','x','y','z' ] ;
| 
|             for L := 0 to NAMETABSIZE do
|             NameTab[L] :=  NIL ;
|             for L:= 1 to MAXRULENO do
|               begin
|                 RuleTab[L] :=  NIL;
|                 PopTab [L] := 0
|               end   ;
|             MaxProdNo := 0;
|             ProdNo := 0 ;
|             MaxPop := 0 ;
|             for L := 0 to MAXSTATE do
|               begin
|                 NewState [L] := 0 ;
|                 NState [ L ] := NIL ;
|               end ;
|             for L := 0 to MAXTABSIZE do
|               begin
|                 Table [L].Tran := UNKNOWN ;
|                 Table [L].Action := UNKNOWN;
|               end ;
|             for L := 0 to STATETABSIZE do
|             StateTab [L] := NIL ;
|             CurrentVisit := 0 ;
|             for L := 1 to MAXVISIT do
|             Visit [L] := NIL ;
|             MaxCode := 257 ;    ¯ leave room for ord constants ò
|             CurrentState := 0
|           end  ;
|         ¯ InitSets ò
| 
| 
| 
|         procedure    Options   ;
|             ¯************************************************************ò
|             ¯*                                                          *ò
|             ¯*  Options                                                 *ò
|             ¯*                                                          *ò
|             ¯*  THIS procedure Reads in THE Options                     *ò
|             ¯*   AND SETS THE OPTION FLAGS APPROPRIATELY                *ò
|             ¯*                                                          *ò
|             ¯*      GLOBAL in:  Ch        LAST charACTER                *ò
|             ¯*                                                          *ò
|             ¯*                                                          *ò
|             ¯************************************************************ò
| var
|     ChNext : char;
|     EndLine,
|     EndArgs : boolean;
| 
|           begin
|             ¯ Options ò
|               PromptArgs('Options: ');
|               OpenArgs([ OpenInput, OpenUppercase ]);
|         /*    Reset(TTY,'TTY:','/I/U'); ¯ convert tty input to upper case ò */
|               GetArgCh( ChNext, EndLine, EndArgs );
|               while not EndArgs do begin
|                 Ch := ChNext;       ¯ get Identifier ò
|                 GetArgCh( ChNext, EndLine, EndArgs ); ¯ get +/- ò
|                 if Ch = 'L' then
|                   begin
|                     ListFl  :=  ChNext <> '-';
|                     writeln(TTYOut,'Listfile: ',listfl)
|                   end
|                 else if Ch = 'O' then
|                   begin
|                     Optimize  :=  ChNext <> '-';
|                     writeln(TTYOut,'Optimize: ',optimize)
|                   end
|                 else if Ch = 'T'  then
|                   begin
|                     Tables := ChNext<>'-';
|                     writeln(TTYOut,'Tables: ',tables)
|                   end
|                 else if Ch ='S'  then
|                   begin
|                     Terminals := ChNext<>'-';
|                     writeln(TTYOut,'Terminals: ',terminals)
|                   end
|                 else if Ch = 'F'   then
|                   begin
|                     Frequency  :=  ChNext <>'-';
|                     writeln(TTYOut,'Frequency: ',frequency)
|                   end
|                 else if  Ch = 'M'   then
|                   begin
|                     FSM  :=  ChNext<>'-';
|                     writeln(TTYOut,'FSM: ',fsm)
|                   end
|                 else  if  Ch  = 'D'   then
|                   begin
|                     Debug  := ChNext <> '-';
|                     writeln(TTYOut,'Debug: ',debug)
|                   end
|                 else  if  Ch  = 'R'   then
|                   begin
|                     Trace  :=  ChNext <> '-';
|                     writeln(TTYOut,'Trace: ',trace)
|                   end
|                 else  if  Ch in Digits  then
|                 begin
|                     MaxK:=  ord(Ch) - ord('0');
|                     writeln(TTYOut,'Maximum lookahead: ',maxk)
|                 end
|                 else  if  Ch = 'A'   then
|                   begin
|                     Look := ChNext<>'-';
|                     writeln(TTYOut,'Look: ',look)
|                   end
|                 else if Ch='G'  then
|                   begin
|                     Grammar:=  ChNext <> '-';
|                     writeln(TTYOut,'Grammar: ',grammar)
|                   end
|                 else if Ch ='Z' then
|                   begin
|                     Research:= ChNext<>'-';
|                     writeln(TTYOut,'Research: ',Research)
|                   end
|                 else if Ch ='N' then
|                   begin
|                     NonTerminals:= ChNext<>'-';
|                     writeln(TTYOut,'Non-terminals: ',nonterminals)
|                   end
|                 else if Ch ='Y' then
|                   begin
|                     Symbolic:= ChNext<>'-';
|                     writeln(TTYOut,'Symbolic: ',symbolic)
|                   end
|                 else if Ch = 'I' then
|                   begin
|                     IFSM := ChNext<>'-' ;
|                     writeln(TTYOut,'IFSM: ',ifsm)
|                   end
|                 else if Ch = 'C' then
|                   begin
|                     Lr0 := ChNext <> '-' ;
|                     writeln(TTYOut,'Lr0: ',lr0)
|                   end
|                 else  if  Ch = 'P'   then
|                   begin
|                     PN :=  ChNext <> '-';
|                     writeln(TTYOut,'PN: ',pn)
|                   end;
|               end;
|               writeln(TTYOut)
|           end ;
|         ¯  Options  ò
| 
| 
| 
|       begin
|         ¯  InitP    ò
|         ¯  GET Filename ò
| 
|         InitSets;
|         writeln(TTYOut, 'PAT/lalr -- December, 1983');
|         writeln(TTYOut);
|         InitArgs;
| 
| 
|         PromptArgs('File: ');
|         for I:= 1 to FILENAMELEN do
|             Filename[I] := ' ';
|         I:= 0;
|         Dot:=0;
|         RBrak:=0;
|         Colon:=0;
|         GetArgCh( ch, EndLine, EndArgs );
|         while not EndLine and not EndArgs and
|               not FatalError and (I < FILENAMELEN) do begin
|             if (Ch in (Letters + Digits)) or (Ch = '<') or
|                 (Ch = '-') or (Ch = '.') or (Ch = '>') or (Ch = ':')
|               then
|                 begin
|                 I := I + 1;
|                 Filename [I] := Ch;
|                 if ( Ch = '.' ) AND ( Dot = 0 ) then
|                     Dot := I
|                 else if Ch = ':' then Colon := I
|                 else if Ch = '>' then RBrak := I;
|                 end
|             else begin
|                 writeln (TTYOut,'?Error in filespecs');
|                 FatalError := TRUE;
|             end;
|             GetArgCh( ch, EndLine, EndArgs );
|         end;
| 
|     if not FatalError then begin
|         if dot=0 then ¯set default extension to PATò begin
|             dot := i+1;
|             filename[i+1] := '.';
|             filename[i+2] := 'P';
|             filename[i+3] := 'A';
|             filename[i+4] := 'T';
|             i := i+4
|         end;
| 
|         if CanOpen(filename) then
|             open( input, filename, [ OpenInput, OpenUppercase ] )
|      /*Reset(input,filename,'/U/O'); ¯trap errors & xlate input to UCò*/
|         else begin
|             writeln(TTYOut,'?Cannot open input file');
|             FatalError := TRUE
|         end;
|     end;
| 
|     if not FatalError then begin
|         Ch := ' ';
|         if RBrak > Colon        ¯ Get rid of device and directory names ò
|         then Distance := RBrak
|         else Distance := Colon;
|         if Distance > 0
|         then
|             for J:=1 to I+Distance do
|                 Filename[J] := Filename[J+Distance];
|         Dot := Dot-Distance;            ¯ Move down the dot ò
|         Options;
|         Filename [Dot+1]  :=  'L'   ;
|         Filename [Dot+2]  :=  'S'   ;
|         Filename [Dot+3]  :=  'T'   ;
|         open(OUTPUT,Filename,[ OpenOutput ]);
|         if Frequency or FSM or Look or tables
|         then
|           begin
|             Filename [Dot+1]  :=  'C'   ;
|             Filename [Dot+2]  :=  'R'   ;
|             Filename [Dot+3]  :=  'L'   ;
|             open (CrefPas, Filename, [ OpenOutput ])
|           end   ;
|         if Terminals then
|           begin
|             Filename [Dot+1] := 'T';
|             Filename [Dot+2] := 'E' ;
|             Filename [Dot+3] := 'R' ;
|             open (TerPas,Filename,[OpenOutput])
|           end ;
|         if Tables then
|           begin
|             Filename[Dot+1] := 'T';
|             Filename[Dot+2] := 'A' ;
|             Filename[Dot+3] := 'B';
|             open (TabPas,Filename,[OpenOutput])
|           end ;
|         if PN then
|           begin
|             Filename [Dot+1] := 'P' ;
|             Filename [Dot+2] := 'N' ;
|             Filename [Dot+3] := ' ' ;
|             open (PNPas,Filename,[OpenOutput])
|           end ;
|         NextCh;
|     end;
| end; ¯ InitP ò
| 
| 
| 
|     procedure  Skip (SyS : setofsymbol)  ;
| 
|         ¯********************************************ò
|         ¯*                                          *ò
|         ¯*  Skip                                    *ò
|         ¯*                                          *ò
|         ¯* Skip Input String until RELEVANT symbol  *ò
|         ¯*  IS FOUND                                *ò
|         ¯********************************************ò
|       begin
|         while not(Sy in SyS) and not eof(Input) do InSymbol  ;
|         Error (0)
|       end  ;
| 
| 
| 
|     function FindId (IdName :word; Key : integer ; IdKind
|         : setofnamety ) : identptrty ;
|         ¯*********************************************ò
|         ¯*                                           *ò
|         ¯*  FindId                                   *ò
|         ¯*                                           *ò
|         ¯*     THIS procedure RETURNS A              *ò
|         ¯*   A POinTER to THE GIVEN NAME AND type    *ò
|         ¯*  in then symbol Table                     *ò
|         ¯*                                           *ò
|         ¯*********************************************ò
| 
|     var
|         I : integer ;
|         Found : boolean  ;
|         P,Q  : identptrty;
|       begin
|         I := Key mod NAMETABSIZE ;
|         Q := NameTab[I] ;
|         Found := FALSE;
|         P := NIL ;
|         while (Q <> NIL) AND (not Found ) do
|           begin
|             if Q@.InternalName = IdName
|             then
|               begin
|                 Found := Q@.Kind in IdKind ;
|                 P := Q;
|               end ;
|             Q := Q@.Nic
|           end ;
|         FindId := P
|       end ;
| 
| 
| 
| 
|     function EnterId (ExtIdName, IntIdName: word; Key: integer;
|         IdKind: namety; IdCode: codety; IdSy : symbol)  :  identptrty  ;
|         ¯***************************************************ò
|         ¯*                                                 *ò
|         ¯*  EnterId                                        *ò
|         ¯*                                                 *ò
|         ¯*THIS procedure ENTERS THE GIVEN NAME             *ò
|         ¯*  into THE symbol Table.  if THE NAME IS A       *ò
|         ¯*  TerminAL THE TerminAL Code IS ENTERED AS       *ò
|         ¯*  AN ATTRIBUTE of THE NEWLY ENTERED symbol.      *ò
|         ¯*                                                 *ò
|         ¯***************************************************ò
|     label
|         2;
|     var
|         I : integer ;
|         P,Q : identptrty;
|       begin
|         ¯ EnterId ò
|         I := Key mod NAMETABSIZE ;
|         Q := NameTab [I]  ;
| 
|         if Trace then
|           begin
|             writeln(TTYOut,'I= ',I,'Key= ',Key);
|             BREAK
|           end ;
|         while Q <> NIL do
|           begin
|             if Q@.InternalName = IntIdName then
|               begin
|                 Error (8) ;
|                 EnterId := Q;
|                 GOto 2
|               end ;
|             Q := Q@.Nic
|           end ;
|         new (P) ;
|         with P@ do
|           begin
|             Nic := NIL  ;
|             FirstAlt := NIL  ;
|             ExternalName   := ExtIdName  ;
|             InternalName   := IntIdName  ;
|             SpId := IdSy ;
|             Kind  := IdKind  ;
|             if IdCode= -1 then IdCode :=MaxCode+1;
|             if IdCode > MAXVOCSIZE then
|                 writeln(TTYOut,'Code is too big for cross indexing')
|             else SymbolName[IdCode] := P ;
|             Code  := IdCode  ;
|             if IdCode > MaxCode then MaxCode := IdCode ;
|             UsedIn  := NIL  ;
|             Defin  := NIL
|           end  ;
|         Q := NameTab [I]  ;
|         NameTab [I] := P  ;
|         P@. Nic  := Q     ;
|         EnterId  := P  ;
|         2 :
|       end  ;
|     ¯ EnterId ò
| 
| 
|     procedure Terminal  ;
|         ¯************************************************************ò
|         ¯*                                                          *ò
|         ¯*   Terminal                                               *ò
|         ¯*                                                          *ò
|         ¯* THIS procedure Reads THE Terminal                        *ò
|         ¯* DefinITIONS AND ENTERS THEM in THE                       *ò
|         ¯* symbol Table                                             *ò
|         ¯************************************************************ò
|     var
| 
|         TP   : identptrty ;
|         LKey : integer ;
|         InternalName,
|         ExternalName : word;
|         NotEof : boolean;
| begin
|         ¯ Terminal ò
|         InSymbol ;
|     if InternalId <> 'BEGIN' then begin ¯ Terminal part need not be there ò
|         if InternalId <> 'TERMINAL' then
|           begin
|             Error (5) ;
|             Skip ([SemiSy])
|           end ;
|         NotEof := not eof(Input);
|         InSymbol  ;
|         while (InternalId <> 'END') and NotEof do
|           begin
|             if (Sy <> Ident) AND (Sy <> Res) then
|               begin
|                 Error (6);
|                 Skip ([Ident,Res])
|               end;
|             InternalName := InternalId  ;
|             ExternalName := ExternalId  ;
|             LKey := SyKey ;
|             InSymbol;
|             if Sy <> EqSy  then
|               begin
|                 Error (7)  ;
|                 Skip ([Intconst])
|               end
|             else InSymbol  ;
|             TP :=EnterId(ExternalName, InternalName, LKey, Term, SyVal, Sy);
|             NotEof := not eof(Input);
|             InSymbol  ;
|             if Sy = SemiSy  then begin
|                 NotEof := not eof(Input);
|                 InSymbol;
|             end;
|           end  ;
|         InSymbol ;
|         if Sy= SemiSy then
|             InSymbol;
|     end; ¯ Allow Terminal part to be absent... ò
| end ;
|     ¯ Terminal ò
| 
| 
| 
|     procedure ReadG   ;
|         ¯********************************************ò
|         ¯*                                          *ò
|         ¯*  ReadG                                   *ò
|         ¯*                                          *ò
|         ¯* THIS procedure Reads in THE Grammar      *ò
|         ¯* AND SETS UP THE symbol Table             *ò
|         ¯*                                          *ò
|         ¯********************************************ò
|     label
|         1,2;
|     var
|         T,U¯ CURRENT RHS TranSITION ò
|         ,Q:   prodptrty ;¯ LHS Production ò
|         V,P:   identptrty ;¯ LHS symbol ò
|         R,S:   listptrty ;¯ of Production NO ò
|         PopNo:   integer ;
|         NotEof : boolean;
|       begin
|         ¯ ReadG ò
|         if Trace then
|           begin
|             writeln(TTYOut,'ReadG') ;
|             Break
|           end ;
|         if InternalId <> 'BEGIN' then
|           begin
|             Error(14) ;
|             Skip([Ident,Res])
|           end
|         else InSymbol ;
|         NotEof := TRUE;
|         while (InternalId <> 'END') and NotEof do
|           begin
|             if (Sy <> Ident) AND (Sy <> Res) then
|               begin
|                   repeat
|                     Error (9)  ;
|                     Skip ([SemiSy])  ;
|                     NotEof := not eof(Input);
|                     InSymbol
|                   until (Sy=Ident) or (Sy=Res) or not NotEof;
|                 goto 1
|               end ;
|             P := FindId (InternalId, SyKey, [NonTerm,Term])  ;
|             if P <> NIL then
|             if P@.Kind=Term then P@.Kind := NonTerm ;
|             if P = NIL then
|                 P := EnterId ( ExternalId, InternalId, SyKey,
|                                NonTerm, MaxCode+1, Sy );
|             ¯ ENTER RHS ò
|             InSymbol   ;
|             if Sy <> EqSy then
|               begin
|                 Error (10)  ;
|                 Skip ([SemiSy])  ;
|                 InSymbol  ;
|                 goto 1
|               end  ;
|             Q := P@.FirstAlt ;
|             if Q<> NIL then while Q@.NxtAlt<> NIL do
|             Q := Q@.NxtAlt ;
|               repeat
|                 PopNo := 0  ;
|                 new (U)  ;
|                 if Q = NIL then P@.FirstAlt := U
|                 else Q@.NxtAlt   := U  ;
|                 Q := U  ;
|                 with Q@ do
|                   begin
|                     Next := NIL  ;
|                     XDef :=  P   ;
|                     Action := NIL  ;
|                     NxtAlt := NIL
|                   end ;
|                 if  ProdNo < MAXRULENO then ProdNo := ProdNo +1
|                 else   Error (12)  ;
|                 new (R)  ;
|                 S := P@.Defin;
|                 if S <> NIL  then
|                   begin
|                     while S@.CDR <> NIL  do  S:= S@.CDR  ;
|                     S@.CDR  := R ;
|                   end
|                 else  P@.Defin  := R  ;
| 
|                 R@.CDR := NIL ;
|                 R@.CAR  := ProdNo     ;
|                 RuleTab [ProdNo]  := Q;
|                 Q@.Production := ProdNo ;
|                 InSymbol;
|                 if (Sy = SemiSy) or (Sy = OrSy ) then
|                   begin
|                     PopTab [ProdNo] := PopNo ;
|                     if PopNo > MaxPop then MaxPop := PopNo;
|                     if Sy= SemiSy
|                     then
|                       begin
|                         InSymbol  ;
|                         goto 1
|                       end
|                     else
|                     goto 2
|                   end
|                 else while (Sy=Ident) or (Sy=Res) do
|                   begin
|                     PopNo := PopNo+1 ;
|                     V :=  FindId (InternalId,SyKey, [NonTerm , Term]) ;
|                     if V = NIL then
|                         V := EnterId (ExternalId, InternalId, SyKey,
|                                       Term, MaxCode+1, Sy) ;
|                     new (T)  ;
|                     U@.Next  :=T ;
|                     U   :=T ;
|                     T@.Action  := V  ;
|                     T@.XDef     := P  ;
|                     T@.NxtAlt := NIL  ;
|                     T@.Next    := NIL  ;
|                     S := V@.UsedIn  ;
|                     new (R)  ;  R@.CDR  := NIL ;
|                     if  S <> NIL then
|                       begin
|                         while  S@.CDR <> NIL do  S := S@.CDR  ;
|                         S@.CDR  := R  ;
|                       end
|                     else    V@.UsedIn  :=  R ;
|                     R@.CAR := ProdNo ;
|                     InSymbol
|                   end  ;
|                 PopTab[ProdNo] := PopNo ;
|                 if PopNo > MaxPop then MaxPop := PopNo;
|                 if Sy = SlashSy  then
|                   begin
|                     InSymbol ;
|                     if Sy <> Ident
|                     then
|                       begin
|                         Error (9)  ;
|                         Skip ([SemiSy]);
|                         goto 1
|                       end  ;
|                     V := FindId (InternalId, SyKey, [Lab]) ;
|                     if V=NIL then
|                         V:= EnterId (ExternalId, InternalId, SyKey, Lab,0, Sy) ;
|                     S := V@.UsedIn ;
|                     new(R) ; R@.CDR := NIL;
|                     if S <> NIL then
|                       begin
|                         while S@.CDR <> NIL do S :=S@.CDR;
|                         S@.CDR := R
|                       end
|                     else V@.UsedIn := R;
|                     R@.CAR := ProdNo ;
|                     Q@.Action := V  ;
|                     InSymbol
|                   end ;
| 
|                 2:
|               until Sy <> OrSy ;
|             if Sy <> SemiSy then
|               begin
|                 Error (13)  ;
|                 Skip ([SemiSy])  ;
|               end ;
|             NotEof := not eof(Input);
|             InSymbol ;
|             1:
|           end ;
|         MaxProdNo := ProdNo ;
|         if (PopTab [1] <> 2) or
|             (RuleTab [1]@.Next@.Next@.Action@.InternalName <> 'GOALSY')
|          or (RuleTab[1]@.NxtAlt <> NIL)
|         then writeln(TTYOut,'First production must have GOAL symbol.');
|       end ;
|     ¯ ReadG  ò
| 
| 
| 
|     procedure  PrintG ;
|         ¯*****************************************************ò
|         ¯*                                                   *ò
|         ¯*  PrintG                                           *ò
|         ¯*                                                   *ò
|         ¯*THIS procedure PRinTS OUT A forMATTED              *ò
|         ¯*  Grammar ONto FILENAM. new                        *ò
|         ¯*                                                   *ò
|         ¯*                                                   *ò
|         ¯*                                                   *ò
|         ¯*****************************************************ò
|     var
|         I,Count  : integer ;
| 
| 
| 
|         procedure PrintProd ( LHS : prodptrty
|             ;ProdNo  :  integer  ) ;
|             ¯***********************************************ò
|             ¯*                                             *ò
|             ¯* Print Prod                                  *ò
|             ¯*                                             *ò
|             ¯*   THIS procedure PRINTS OUT A Production    *ò
|             ¯*                                             *ò
|             ¯*                                             *ò
|             ¯***********************************************ò
|         var
|             RHS    : prodptrty ;
| 
| 
| 
|             procedure    PrintRHS  ( LinK  :  prodptrty )  ;
|                 ¯***********************************************ò
|                 ¯*                                             *ò
|                 ¯* PrintRHS                                    *ò
|                 ¯*                                             *ò
|                 ¯*    THIS procedure PRINTS OUT THE RIGHT      *ò
|                 ¯*    HAND SIDE of A Production                *ò
|                 ¯*                                             *ò
|                 ¯*                                             *ò
|                 ¯***********************************************ò
| 
|               begin
|                 ¯ PrintRHSò
|                 Count  := 0  ;
|                 if LinK= NIL
|                 then write(CrefPas,'                   ')
|                 else
|                   repeat
|                     if Count = 3  then
|                       begin
|                         writeln ( CrefPas)  ;
|                         Count := 0  ;
|                         write ( CrefPas,'                         ');
|                       end   ;
|                     Count := Count + 1   ;
|                     write ( CrefPas, LinK@.Action@.ExternalName,'   ');
|                     LinK :=  LinK@.Next
|                   until  LinK = NIL  ;
|                 if LHS@.Action <> NIL
|                 then
|                   begin
|                     while Count <2 do
|                       begin
|                         write(CrefPas,'               ');
|                         Count := Count+1 ;
|                       end;
|                     write ( CrefPas, '/  ', LHS@.Action@.ExternalName);
|                   end ;
|                 if LHS@.NxtAlt = NIL
|                 then write ( CrefPas, '  ;  ');
|               end ;
|             ¯  PrintRHS ò
| 
| 
| 
|           begin
|             ¯ PRINT prod ò
|             if ProdNo <  10
|             then write (CrefPas, '  ', ProdNo:1)
|             else if ProdNo < 100
|             then write (CrefPas, ' ', ProdNo : 2)
|             else if ProdNo < 1000
|             then write (CrefPas, ProdNo : 3)  ;
|             if LHS@.XDef@.FirstAlt = LHS then
|             write ( CrefPas,'   ', LHS@.XDef@.ExternalName, '=   ')
|             else write ( CrefPas, '               ', '   !   ' );
|             RHS :=  LHS@.Next ;
|             PrintRHS (RHS)  ;
|             writeln(CrefPas,' # ',LHS@.Production) ;
|           end ;
| 
| 
| 
|       begin
|         ¯ PRINT Gò
|         I := B14 ;
|         Ch := ChR (I) ;
|         writeln (CrefPas, Ch)  ;
|         writeln (CrefPas, '                      Grammar ');
|         writeln (CrefPas, '                      ======= ');
|         writeln (CrefPas)  ;
|         for I := 1 to MAXRULENO do
|         if RuleTab [I] <> NIL
|         then PrintProd (RuleTab [I], I) ;
|         writeln (CrefPas, Ch)
|       end  ;
|     ¯ PRINT Gò
| 
| 
| 
| 
| 
| 
| 
| 
|     procedure  PrintCref ;
|         ¯******************************************************ò
|         ¯*                                                    *ò
|         ¯*PrintCref                                           *ò
|         ¯*                                                    *ò
|         ¯*   THIS procedure CONTROLS THE PRINTinG of THE      *ò
|         ¯*    CROSS REFERENCE listinG                         *ò
|         ¯*                                                    *ò
|         ¯*                                                    *ò
|         ¯******************************************************ò
|     type
|         symlistptrty = @ symlist ;
|         symlist =  record
|                           Sym : identptrty;
|                           CDR : symlistptrty
|                    end ;
|     var
|         Head  :  symlist  ;
|         I  :  integer  ;
|         Ch  :  char     ;
| 
| procedure PrintTerm (IdKind : setofnamety) ;
| 
|         ¯*****************************************ò
|         ¯*                                       *ò
|         ¯* PrintTerm                             *ò
|         ¯*                                       *ò
|         ¯*  THIS procedure PRINTS OUT THE        *ò
|         ¯* Terminal symbol DefinITIONS           *ò
|         ¯*                                       *ò
|         ¯*****************************************ò
| 
| var
| 
|         P : symlistptrty;
| 
| 
| 
| begin    ¯ PrintTerm ò
| 
| 
|         P := Head.CDR ;
| 
|         while P <> NIL do begin
|                 if P@.Sym@.Kind in IdKind then begin
|                     write(TerPas,P@.Sym@.ExternalName,' = ');
|                     if P@.Sym@.SpId = Res then
|                         writeln(TerPas, '-1 ;')
|                     else
|                         writeln(TerPas,P@.Sym@.Code,' ;');
|                 end;
|                 P := P@.CDR ;
| 
|         end ;
| 
| end  ¯ PrintTerm ò ;
| 
| 
| 
|         procedure   PrintVoc  (IdKind : setofnamety) ;
|             ¯**********************************************************ò
|             ¯*                                                        *ò
|             ¯*    PrintVoc                                            *ò
|             ¯*                                                        *ò
|             ¯*        THIS procedure PRINTS OUT CROSS REFERENCE       *ò
|             ¯*   inforMATION for Terminals , NON-                     *ò
|             ¯*   Terminals AND Action labelS                          *ò
|             ¯*                                                        *ò
|             ¯**********************************************************ò
|         var
|             P   :    symlistptrty ;
|             Count :   integer    ;
|             Q :    listptrty ;
|           begin
|             ¯  PRINT VOC  ò
|             if Trace then
|               begin
|                 writeln(TTYOut,'VOC') ;
|                 Break
|               end ;
|             P :=   Head.CDR ;
|             while  P <> NIL  do
|               begin
|                 if       P@.Sym@.Kind
|                 in  IdKind
|                 then
|                   begin
|                     writeln (CrefPas)  ;
|                     writeln(CrefPas);writeln(CrefPas);
|                     write(CrefPas, P@.Sym@.ExternalName);
|                     if P@.Sym@.SpId <> Res then
|                         write(CrefPas, '  ',P@.Sym@.Code)
|                     else
|                         write(CrefPas,'     Reserved');
|                     writeln(CrefPas) ;
|                     write(CrefPas, ' Defined ') ;
|                     Count := 0   ;
|                     Q := P@.Sym@.Defin;
|                     while  Q <> NIL  do
|                       begin
|                         if Count = 4 then
|                           begin
|                             writeln (CrefPas) ;
|                             Count:=0          ;
|                             write  (CrefPas,'         ')
|                           end ;
|                         Count := Count +1   ;
|                         write (CrefPas, Q@.CAR, '   ') ;
|                         Q := Q@.CDR
|                       end     ;
|                     writeln (CrefPas);
|                     Count  :=0;
|                     Q := P@.Sym@.UsedIn ;
|                     write (CrefPas, ' Used    ') ;
|                     while Q <> NIL  do
|                       begin
|                         if   Count =4   then
|                           begin
|                             writeln (CrefPas) ;
|                             Count :=0  ;
|                             write (CrefPas,'         ')
|                           end   ;
|                         Count := Count +1 ;
|                         write (CrefPas , Q@.CAR, '   ') ;
|                         Q := Q@.CDR
|                       end   ;
|                   end ;
|                 P:= P@.CDR
|               end   ;
|           end ;
|         ¯  PRINT VOC  ò
| 
| 
| 
|         procedure    Sort ;
|             ¯************************************************ò
|             ¯*                                              *ò
|             ¯*    Sort                                      *ò
|             ¯*                                              *ò
|             ¯*       THIS procedure SortS THE symbol Table  *ò
|             ¯*                                              *ò
|             ¯************************************************ò
|         label
|             1,2;
|         var
|             I,K :  integer      ;
|             X   :   identptrty ;
|             P,Q,R   :   symlistptrty ;
|           begin
|             ¯  Sort  ò
|             if Trace then
|               begin
|                 writeln(TTYOut,'Sort');
|                 Break
|               end ;
|             Head.CDR := NIL ;
|             for K :=  0 to  NAMETABSIZE         do
|               begin
|                 X := NameTab [K] ;
|                 while X <> NIL  do
|                   begin
|                     new (R)   ;
|                     R@.Sym  := X  ;
|                     R@.CDR  := NIL;
|                        ¯  Enter in chain  ò
|                     Q       := Head.CDR   ;
|                     if Q=NIL then Head.CDR:= R
|                     else
|                       begin
|                         if R@.Sym@.InternalName<Q@.Sym@.InternalName
|                         then
|                           begin
|                             Head.CDR := R;
|                             R@.CDR := Q
|                           end
|                         else
|                           begin
|                             P       :=  Q@.CDR    ;
|                             while (P <> NIL)
|                             do
|                               begin
|                                 if R@.Sym@.InternalName < P@.Sym@.InternalName
|                                     then goto 1;
|                                 Q :=P   ;
|                                 P := P@.CDR
|                               end   ;
|                             1:  Q@.CDR := R  ;
|                             R@.CDR := P
|                           end ;
|                       end ;
|                     X:= X@.Nic
|                   end
|               end   ;
|             ¯  for  ò
|             2:
|           end   ;
|         ¯  Sort  ò
|       begin
|         ¯  PRINT CREF  ò
|         mark(Heap);
|         Sort ;
|         if Grammar then begin
|         I :=  B14   ;
|         Ch :=  ChR(I)  ;
|         writeln (CrefPas, Ch)   ;
|         writeln (CrefPas, '                      Cross Reference ');
|         writeln (CrefPas, '                      ================');
|         writeln (CrefPas,'      Terminals') ;
|         writeln (CrefPas);
|         PrintVoc([Term])      ;
|         writeln (CrefPas, Ch) ;
|         writeln (CrefPas,'     Non Terminals')  ;
|         PrintVoc([NonTerm])    ;
|         writeln (CrefPas, Ch)  ;
|         writeln (CrefPas, '     Label')  ;
| 
|         PrintVoc([Lab]) ;
|         writeln (CrefPas, Ch)  ;
|         end ;
|         if Terminals and NonTerminals then
|             PrintTerm([ Term, NonTerm ])
|         else if Terminals then
|             PrintTerm([Term])
|         else if NonTerminals then
|             PrintTerm([NonTerm]);
|         release (Heap)
|       end   ;
|     ¯  PRINT CREF  ò
| 
| 
| 
| 
| 
| 
|     procedure PrintCon (T : tranptrty) ;
|         ¯********************************************************ò
|         ¯*                                                      *ò
|         ¯*    PrintCon                                          *ò
|         ¯*                                                      *ò
|         ¯*   THIS procedure PRINT A CONFIGURATION in Symbolic   *ò
|         ¯* forM                                                 *ò
|         ¯*                                                      *ò
|         ¯*   in :   T  GIVEN CONFIGURATION                      *ò
|         ¯********************************************************ò
|     var
|         X : integer ;
|         J : integer ;
|         Red,SameLine : boolean ;
|         P : prodptrty ;
| 
| 
| 
|       begin
|         ¯ PRINT CON  ò
|         X := T@.Pos ;
|         P := T@.Rule ;
|         SameLine := TRUE ;
|         Red := FALSE ;
|         J := 0 ;
|         write(CrefPas,'* ');
|         write(CrefPas,P@.XDef@.ExternalName);
|         write(CrefPas,' = ');
|         while X <> 0 do
|           begin
|             P := P@.Next ;
|             write (CrefPas,P@.Action@.ExternalName,' ') ;
|             X := X-1 ;
|             J := J+1;
|             if J >= 3 then
|               begin
|                 writeln(CrefPas,'   *');
|                 write(CrefPas,'*                   ');
|                 J := 0
|               end ;
|           end ;
|         write(CrefPas,'# ');
|         P := P@.Next ;
|         if P= NIL then Red := TRUE else Red := FALSE ;
|         while P <> NIL do
|           begin
|             write(CrefPas,P@.Action@.ExternalName,' ');
|             J := J+1 ;
|             if J >= 3 then
|               begin
|                 writeln(CrefPas,' *');
|                 write(CrefPas,'*                     ');
|                 SameLine := FALSE ;
|                 J := 0 ;
|               end ;
|             P := P@.Next
|           end ;
|         if Red then
|           begin
|             while J < 2 do
|               begin
|                 write(CrefPas,'                ');
|                 J := J+1 ;
|               end ;
|             P := T@.Rule ;
|             if P@.Action <> NIL then
|               begin
|                 write(CrefPas,'/ ');
|                 write(CrefPas,P@.Action@.ExternalName);
|                 writeln(CrefPas,'*');
|                 if T@.NextState <> NIL then
|                 writeln(CrefPas,'*                                  ',
|                 '                   ',T@.NextState@.State:10,'       *');
|               end
|             else if T@.NextState <> NIL
|             then writeln(CrefPas,T@.NextState@.State:10,'       *')
|             else writeln(CrefPas,'                 *');
|           end
|         else
|           begin
|             while J <2 do
|               begin
|                 write(CrefPas,'                ');
|                 J := J+1
|               end ;
|             if T@.NextState <> NIL then
|               begin
|                 write(CrefPas,T@.NextState@.State: 10);
|                 if SameLine then writeln(CrefPas,'       *')
|                 else writeln(CrefPas,'       *');
|               end
|             else if SameLine then writeln(CrefPas,'                 *')
|             else writeln(CrefPas,'                 *');
|           end
|       end   ¯   PRINT CON ò   ;
| 
| 
| 
|     procedure PrintState(S :stateptrty)  ;
|         ¯**************************************************ò
|         ¯*                                                *ò
|         ¯*  PrintState                                    *ò
|         ¯*                                                *ò
|         ¯*  THIS PROC PRINTS A State                      *ò
|         ¯*   in   :   S State                             *ò
|         ¯**************************************************ò
|     var
|         T : tranptrty ;
|         ST : stateptrty ;
| 
| 
|       begin
|         ¯ PrintState ò
| 
|         writeln(CrefPas) ;
|         writeln(CrefPas) ;
|         writeln(CrefPas,'*******************************************',
|                         '*****************************');
|         write(CrefPas,'*     State ');
|         write(CrefPas,S@.State) ;
|           case S@.Kind of
|             Reads : write(CrefPas,' read State ');
|             Inadequate:write (CrefPas,' Inadequate ');
|             Lookahead :write (CrefPas, ' Lookahead  ') ;
|             Reduction  : write (CrefPas, ' Reduction  ') ;
|             LAString : write (CrefPas,' LAString   ') ;
|             Subgoal : write (CrefPas, ' Subgoal    ')
|           end ;
|         writeln( CrefPas, '                                   *');
|         writeln(CrefPas,'*******************************************',
|                         '*****************************');
|         writeln(CrefPas,'*                                          ',
|                         '                            *');
|         T := S@.FirstTran ;
|         while T <> NIL do
|           begin
|             PrintCon(T) ;
|             T := T@.Next
|           end ;
|         writeln(CrefPas,'*******************************************',
|                         '*****************************');
|         writeln(CrefPas) ;
|         writeln(CrefPas)
|       end  ¯ PrintState ò   ;
| 
| 
| 
|     procedure OutFSM ;
|         ¯*********************************************ò
|         ¯*                                           *ò
|         ¯*         OutFSM                            *ò
|         ¯*    THIS PROC OUTPUTS FSM Tables           *ò
|         ¯*                                           *ò
|         ¯*********************************************ò
| 
|     label
|         1;
|     var
|         I : integer ;
| 
| 
|       begin
|         ¯ OutFSM ò
|         I := B14 ;
|         Ch := ChR(I) ;
|         writeln(CrefPas,Ch) ;
|         writeln(CrefPas,'                      Characteristic States');
|         writeln(CrefPas,'                      =====================');
|         writeln(CrefPas);writeln(CrefPas);writeln(CrefPas);
|         for I := 0 to MAXSTATE do
|           begin
|             if NState [ I ] = NIL then goto 1 ;
|             PrintState (NState [I])
|           end ;
|         1:
|       end     ¯ OutFSM ò  ;
| 
| 
| 
| 
| 
| 
| 
|     procedure PrintTab ;
|         ¯************************************************ò
|         ¯*                                              *ò
|         ¯* PrintTab                                     *ò
|         ¯*                                              *ò
|         ¯*    THIS procedure PRINTS THE symbol Action   *ò
|         ¯*  Tables .                                    *ò
|         ¯*                                              *ò
|         ¯************************************************ò
| 
|     var
|         I : integer ;
|         T,A : integer ;
| 
| 
| 
|       begin
|         ¯ PRINT TABò
|         I := B14 ;
|         Ch := ChR(I);
|         writeln(CrefPas,Ch);
|       I := 3*Index +3 ; ¯ NUMBER of ENTRIESò
|         writeln(CrefPas);
|         writeln(CrefPas,'                Parsing Tables');
|         writeln(CrefPas,'                ==============');
|         writeln(CrefPas);writeln(CrefPas);writeln(CrefPas);
|         writeln(CrefPas,'.__________________________________________',
|                         '___________________________.');
|         writeln(CrefPas,'! Index  Symbol Name                 Action',
|                         '  Pop    Semantics         !');
|         writeln(CrefPas,'.__________________________________________',
| '___________________________.');
|         for I := 0 to Index do
|           begin
|             write(CrefPas,'!',I:5);
|             T := Table[I].Tran ;
|             A := Table[I].Action ;
|             if T=elseCode then write(CrefPas,'    ELSE')
|             else if T=XCONTinUE then  write(CrefPas,'    CONT')
|             else write (CrefPas,'   ',T:5);
|             if (T >=0 ) AND (T <= MAXVOCSIZE)
|             then write(CrefPas,'  ',SymbolName[T]@.ExternalName)
|             else write(CrefPas,'                 ');
|             if A<= 0 then
|               begin
|                 if A <= -NOSCANCODE then write(CrefPas,' ',-A-NOSCANCODE:4,'#')
|                 else
|                 write(CrefPas,' ',-A:4,'#');
|                 if A <= -NOSCANCODE then write(CrefPas,'NO SCAN')
|                 else write (CrefPas,'       ');
|               end
|             else if A= ERRORCODE  then write(CrefPas,'   Error            ')
|             else write(CrefPas,'   ',A:5,'            ');
| 
| 
|             if A < 0 then
|               begin
|                 if A <= - NOSCANCODE then A := A+NOSCANCODE;
|                 write(CrefPas,PopTab[-A]:4,'     ');
|                 if RuleTab[-A]@.Action <> NIL then
|                     write(CrefPas,RuleTab[-A]@.Action@.ExternalName)
|                 else write(CrefPas,'               ');
|               end
|             else write(CrefPas,'                 ');
|             writeln(CrefPas,'  !');
|             writeln(CrefPas,'.______________________________________',
|                             '_______________________________.');
|           end ¯ forò ;
|       end ¯ PRINT TABò ;
| 
| 
| 
|     function NextTran (S :stateptrty; T : tranptrty ):tranptrty ;
| 
|         ¯******************************************************ò
|         ¯*                                                    *ò
|         ¯* NextTran                                           *ò
|         ¯*                                                    *ò
|         ¯*    THIS function GETS THE Next UNMarkED            *ò
|         ¯* TranSITION FROM State S. THE CURRENT TranSITION IS *ò
|         ¯* T. IT RETURNS NIL if NO Next TranSITION EXISTS     *ò
|         ¯*                                                    *ò
|         ¯*  in    : S    CURRENT State                        *ò
|         ¯*          T    CURRENT TranSITION                   *ò
|         ¯*                                                    *ò
|         ¯*  OUT   :                                           *ò
|         ¯*                                                    *ò
|         ¯*  GLOBAL                                            *ò
|         ¯*                                                    *ò
|         ¯* ResULT    PTR to Next TranSITION                   *ò
|         ¯******************************************************ò
| 
| 
|     label
|         1;
|     var
|         CurTran   : tranptrty   ;
| 
|       begin
|         ¯ NextTran ò
|         if Trace then
|           begin
|             writeln(TTYOut,'NextTran');Break
|           end;
|         CurTran := T ;
|         if CurTran = NIL then
|           begin
|             CurTran := S@.FirstTran ;
|             if CurTran = NIL then
|                 writeln(TTYOut,'**System error** in NextTran');
|             CurTran@.MarkE := TRUE
|           end
|         else
|           begin
|             while  CurTran@.MarkE do
|               begin
|                 CurTran := CurTran@.Next ;
|                 if CurTran = NIL then goto 1
|               end ;
|             1:    if CurTran = NIL then
|               begin
|                 CurTran := S@.FirstTran ;
|                   repeat
|                     CurTran@.MarkE := FALSE ;
|                     CurTran       := CurTran@.Next
|                   until CurTran = NIL
|               end
|             else CurTran@.MarkE := TRUE
|           end ;
|         NextTran := CurTran
|       end     ¯ NextTran ò   ;
| 
| 
| 
| 
| 
| 
| 
| 
| 
|     function ConMatch(C1,C2 : tranptrty) : boolean ;
|         ¯***************************************************ò
|         ¯*                                                 *ò
|         ¯*   ConMatch                                      *ò
|         ¯*                                                 *ò
|         ¯*     THIS function COMPARes TWO CONFIGURATIONS   *ò
|         ¯*  AND RETURNS THE ResULT                         *ò
|         ¯*      TWO CONFIGURATIONS MATCh if EVERYTHinG     *ò
|         ¯* BEYOND THE Dot MATChES inCL THE Action          *ò
|         ¯*   for THE Research VERSION . OTHERWISE USUAL DRF *ò
|         ¯*                                                 *ò
|         ¯*    in      : C1,C2 CONFIGURATIONS               *ò
|         ¯*                                                 *ò
|         ¯*                                                 *ò
|         ¯*   GLOBAL          in :   RuleTab                *ò
|         ¯*                                                 *ò
|         ¯*  ResULT     TRUE if MATChES                     *ò
|         ¯***************************************************ò
| 
| 
|     label
|         1;
|     var
|         I1, I2,I   : integer  ;
|         X1,X2  : prodptrty ;
| 
| 
| 
|       begin
|         ¯ ConMatch    ò
|         I1 :=C1@.Pos ;
|         I2 := C2@.Pos ;
|         X1 := C1@.Rule ;
|         X2 := C2@.Rule ;
|         if not Research then begin
|             if (I1=I2) and (X1=X2) then
|                 ConMatch := TRUE
|             else
|                 ConMatch := FALSE;
|         end else begin
|             if (X1@.Action <> X2@.Action) or (I1 <> I2) then
|                 ConMatch := FALSE
|             else begin
|                 for I := 0 to I1 do
|                 X1:= X1@.Next ;
|                 for I := 0 to I2 do
|                 X2 := X2@.Next ;
|                 while (X1<>NIL) and (X2 <> NIL) do
|                   begin
|                     if X1@.Action <> X2@.Action
|                     then
|                       begin
|                         ConMatch := FALSE;
|                         goto 1
|                       end ;
|                     X1:= X1@.Next;
|                     X2 := X2@.Next
| 
|                   end ;
|                 if (X1=NIL) and (X2 = NIL)
|                 then ConMatch := TRUE
|                 else ConMatch  := FALSE ;
|               end ;
|           end ;
|         1:
| 
|       end  ¯ ConMatch  ò   ;
| 
| 
| 
|     procedure AddT( S: stateptrty ; T : tranptrty) ;
|         ¯*****************************************************ò
|         ¯*                                                   *ò
|         ¯*  AddT                                             *ò
|         ¯*                                                   *ò
|         ¯*     THIS procedure ADDS A CONFIGURATION to THE    *ò
|         ¯* GIVEN State . IT ALSO MAKES SURE THE doES not EXIST*ò
|         ¯*  BEforE ENTERinG IT                               *ò
|         ¯*     in       :S   GIVEN State                     *ò
|         ¯*               T  GIVEN CONFIGURATION              *ò
|         ¯*****************************************************ò
| 
| 
|     label
|         1;
|     var
|         Tx,Ty   : tranptrty ;
| 
| 
| 
|       begin
|         ¯  AddT  ò
| 
|         Tx  := S@.FirstTran  ;
|         if Tx = NIL then S@.FirstTran := T
|         else
|           begin
|             while Tx <> NIL do
|               begin
|                 if ConMatch(Tx,T) then goto 1  ;
|                 Ty := Tx ;
|                 Tx := Tx@.Next
|               end ;
|             Ty@.Next   := T  ;
|           end ;
|         1:
|       end   ¯ AddT ò   ;
| 
| 
| 
| 
| 
| 
|     function Token(PR : prodptrty ;PS : integer) : identptrty ;
|         ¯***************************************************ò
|         ¯*                                                 *ò
|         ¯*  Token                                          *ò
|         ¯*                                                 *ò
|         ¯* THIS function RETURNS A POinTER to THE NE T     *ò
|         ¯* Token GIVEN A Rule NO. and  A Pos NUM           *ò
|         ¯*                                                 *ò
|         ¯*   in         : PS   PosITION                    *ò
|         ¯*                 PR Production                   *ò
|         ¯*   OUT                                           *ò
|         ¯*                                                 *ò
|         ¯   ResULT         PTR to Next Token               *ò
|         ¯***************************************************ò
| 
|     label
|         1;
|     var
|         X : identptrty    ;
|         I :  integer    ;
|         Y  : prodptrty  ;
| 
| 
| 
|       begin
|         ¯ Token   ò
|         Token := NIL;
|         Y := PR ;
|         for I := 0 to PS
|         do
|           begin
|             Y := Y@.Next ;
|             if Y = NIL then
|             goto 1
|           end ;
|         Token :=Y@.Action ;
|         1:
| 
|       end   ¯ Token ò ;
| 
| 
| 
|     procedure AddL (S :stateptrty) ;
|         ¯***************************************************ò
|         ¯*                                                 *ò
|         ¯*  AddL                                           *ò
|         ¯*                                                 *ò
|         ¯*    THIS procedure ADDS A State to THE list of   *ò
|         ¯*  of Inadequate StateS                           *ò
|         ¯*                                                 *ò
|         ¯*    in : S State                                 *ò
|         ¯*                                                 *ò
|         ¯***************************************************ò
| 
|     var
|         X,Y  : statelistptr ;
| 
| 
| 
|       begin
|         ¯ AddL ò
|         new(X)  ;
|         X@.CAR := S  ;
|         X@.CDR := NIL ;
|         if Inadeq = NIL then Inadeq := X
|         else
|           begin
|             Y := Inadeq ;
|             while Y@.CDR <> NIL do Y := Y@.CDR ;
|             Y@.CDR := X
|           end
|       end   ¯ AddL ò  ;
| 
| 
| 
| 
|     procedure   CFSM (var  Lr0 : boolean)   ;
|         ¯*********************************************************ò
|         ¯*                                                       *ò
|         ¯*     CFSM                                              *ò
|         ¯*       THIS procedure COMPUTES THE charACTERISTIC      *ò
|         ¯*  FinITE State MAChinE. Lr0 IS set to FALSE            *ò
|         ¯*  if ANY Inadequate State EXISTS. A list of Inadequate *ò
|         ¯*  StateS IS MAinTAinED BY GENS                         *ò
|         ¯*                                                       *ò
|         ¯*                                                       *ò
|         ¯*                                                       *ò
|         ¯*********************************************************ò
|     var
|         S : stateptrty ;
|         S1   : stateptrty ;
|         Sl1 : statelistptr ;
|         AllReduce : boolean ;
| 
| 
| 
|         procedure Closure (A :stateptrty;C:tranptrty;
|             var Reduce : boolean) ;
|             ¯**************************************************ò
|             ¯*                                                *ò
|             ¯*   Closure                                      *ò
|             ¯*                                                *ò
|             ¯*     THIS procedure PERforMS THE Closure        *ò
|             ¯* function ON THE GIVEN CONFIGURATIONS           *ò
|             ¯*                                                *ò
|             ¯*    in     : A  THE GIVEN State                 *ò
|             ¯*             C   CURRENT CONFIG                 *ò
|             ¯*    OUT    : Reduce  set to TRUE if Reduction   *ò
|             ¯*                         N State                *ò
|             ¯*                                                *ò
|             ¯*   GLOBAL                                       *ò
|             ¯*                                                *ò
|             ¯**************************************************ò
| 
| 
|         label
|             1;
|         var
|             CPos : integer   ;
|             Con,CRule : prodptrty ;
|             X,Tran   : tranptrty  ;
|             Nt   : identptrty   ;
|             function Config(Pr : prodptrty ; N: integer) : tranptrty ;
| 
| 
| 
| 
| 
| 
|                 ¯*****************************************************ò
|                 ¯*                                                   *ò
|                 ¯*  Config                                           *ò
|                 ¯*                                                   *ò
|                 ¯*     THIS function CREAES A ConfigURATION          *ò
|                 ¯*                                                   *ò
|                 ¯*    in          :  Pr  Production                  *ò
|                 ¯*                N    PosITION in prod              *ò
|                 ¯*                                                   *ò
|                 ¯*  ResULT         PTR to new Config                 *ò
|                 ¯*****************************************************ò
| 
| 
|             var
|                 X   : tranptrty    ;
| 
|               begin
|                 ¯  Config   ò
|                 new(X) ;
|                 with X@
|                 do
|                   begin
|                     Rule := Pr ;
|                     Pos := N  ;
|                     MarkE  := FALSE ;
|                     Next := NIL ;
|                     NextState := NIL
|                   end ;
|                 Config  := X
| 
| 
|               end ¯ Config ò   ;
| 
| 
| 
|           begin
|             ¯ Closure   ò
|             if Trace then
|               begin
|                 writeln(TTYOut,'Closure');Break
|               end ;
|             CRule  := C@.Rule ;
|             CPos   := C@.Pos;
|             Nt    :=  Token(CRule,CPos) ;
|             if Nt <> NIL
|             then
|               begin
|                 AllReduce := FALSE ;
|                 if Nt@.Kind = NonTerm
|                 then
|                   begin
|                     Tran := A@.FirstTran ;
|                       repeat
|                         if (Nt =Tran@.Rule@.XDef) and
|                         (Tran@.Pos = 0) then goto 1;
|                         Tran := Tran@.Next
|                       until Tran = NIL ;
|                     Con := Nt@.FirstAlt;
|                     while Con <> NIL do
|                       begin
|                         X := Config(Con,0);
|                         AddT(A,X) ;
|                         Con := Con@.NxtAlt
|                       end
|                   end
|               end
|             else Reduce := TRUE ;
|             1:
|           end ¯ Closure   ò    ;
| 
| 
|         function CIS : stateptrty ;
|             ¯*****************************************************ò
|             ¯*                                                   *ò
|             ¯*  CIS                                              *ò
|             ¯*                                                   *ò
|             ¯* THIS procedure SETS UP THE inITIAL State and      *ò
|             ¯* ALSO ChECKS to SEE if THE FIRST Production        *ò
|             ¯* WAS APPrOPrIATELY SET. if not IT GIVES AN Error   *ò
|             ¯*   IT RETURNS A POinTER to THE FIRST State         *ò
|             ¯*                                                   *ò
|             ¯*    GLOBAL    in:   RuleTab                        *ò
|             ¯*                    PopTab                         *ò
|             ¯*                                                   *ò
|             ¯*            OUT :   StateTab                       *ò
|             ¯*                    NState,CurrentState            *ò
|             ¯*                                                   *ò
|             ¯*                                                   *ò
|             ¯*   ResULT    POinTER to FIRST State                *ò
|             ¯*                                                   *ò
|             ¯*****************************************************ò
|         var
|             X  : stateptrty ;
|             Y  : tranptrty ;
|             I   : integer ;
|             B   : boolean ;
|           begin
|             ¯  CIS ò
|             if Trace then
|               begin
|                 writeln(TTYOut,'CIS');
|                 Break
|               end  ;
|             I := 0 ;
|             new(X) ;
|             new(Y) ;
|             CurrentState := 0 ;
|             StateTab [0] := X ;
|             with X@ do
|               begin
|                 FirstTran := Y ;
|                 Back      := NIL ;
|                 Nic       := NIL ;
|                 State     := 0 ;
|                 Kind       := Reads
|               end ;
|             NState [ 0] := X;
|             with Y@ do
|               begin
|                 Next := NIL ;
|                 NextState := NIL ;
|                 Rule      := RuleTab [1] ;
|                 Pos       := 0 ;
|                 MarkE      := FALSE
|               end ;
|             I  := 1 ;
|             CIS := X ;
|             B := FALSE ;
|             AllReduce := TRUE ;
|             Y := NIL ;
|               repeat begin
|                 Y := NextTran(X,Y) ;
|                 if Y = NIL then
|                     leave;
|                 Closure( X,Y,B) ;
|                 I := I+1 ;
|               end until 1 <> 1;
|             if B then if I= 1 then X@.Kind := Reduction
|             else
|               begin
|                 AddL(X) ;
|                 X@.Kind := Inadequate ;
|               end ;
|           end    ¯ CIS ò   ;
| 
| 
| 
| 
|         procedure GenS (S : stateptrty ; var Lr0: boolean) ;
| 
|             ¯*****************************************************ò
|             ¯*                                                   *ò
|             ¯*  GenS                                             *ò
|             ¯*                                                   *ò
|             ¯*  THIS procedure GENERATES THE State MAChinE       *ò
|             ¯* RECURSIVELY. IT SETS Lr0 to FALSE if NECESSARY    *ò
|             ¯*                                                   *ò
|             ¯*   in    :  S  CURRENt State                       *ò
|             ¯*                                                   *ò
|             ¯*   OUT   :  Lr0  inDICATES if MAChinE IS Lr0       *ò
|             ¯*                                                   *ò
|             ¯*   GLOBAL                                          *ò
|             ¯*****************************************************ò
| 
| 
|         var
|             Z : prodptrty   ;
|             I : integer   ; ¯ ConTROL  varIABLEò
|             X : tranptrty    ;
|             Y : stateptrty   ;
|             B : boolean     ;
| 
| 
| 
| 
|             function CHash( S: stateptrty) : integer ;
|                 ¯**************************************************ò
|                 ¯*                                                *ò
|                 ¯*  CHash                                         *ò
|                 ¯*                                                *ò
|                 ¯*     THIS procedure produces A Key.IT USES      *ò
|                 ¯* THash to produce THE Key                       *ò
|                 ¯*                                                *ò
|                 ¯*  in   : S State                                *ò
|                 ¯*                                                *ò
|                 ¯**************************************************ò
|             var
|                 Key   : integer   ;
|                 T     : tranptrty ;
| 
| 
| 
|                 function THash( X: tranptrty) : integer ;
|                     ¯**************************************************ò
|                     ¯*                                                *ò
|                     ¯* THash                                          *ò
|                     ¯*                                                *ò
|                     ¯*  THIS function RETURNS AN integer REPresENtinG *ò
|                     ¯* A ConfigURATION                                *ò
|                     ¯*                                                *ò
|                     ¯*   in :  X TranSITION                           *ò
|                     ¯*                                                *ò
|                     ¯*                                                *ò
|                     ¯**************************************************ò
| 
|                 var
|                     Y   : prodptrty ;
|                     I    : integer ;
|                     TKey : integer ;
| 
| 
| 
|                     function Number(S: identptrty): integer ;
|                       ¯*****************************************************ò
|                       ¯*                                                   *ò
|                       ¯*  Number                                           *ò
|                       ¯*                                                   *ò
|                       ¯*  THIS function RETURNS AN integer BASED ON THE    *ò
|                       ¯* VALUE of THE IdentifIER                           *ò
|                       ¯*                                                   *ò
|                       ¯*   in : S IdentifIER                               *ò
|                       ¯*****************************************************ò
|                    var
|                         Y : word ;
|                         I    : integer ;
|                         Tally : integer ;
|                       begin
|                         ¯ Number ò
|                         Tally := 0 ;
|                         if S <> NIL then
|                           begin
|                             Y := S@.ExternalName ;
|                             for  I := 1 to MAXNAME do
|                             Tally := Tally +ord(Y[I])
|                           end  ;
|                         Number := Tally
| 
|                       end    ¯ Number   ò   ;
| 
| 
|                   begin
|                     ¯ THash ò
|                     Y := X@.Rule ;
|                     TKey :=  Number(Y@.Action) ;
|                     for I := 0 to X@.Pos do Y := Y@.Next ;
|                     if Y <> NIL then
|                     TKey := TKey+Number(Y@.Action) ;
|                     THash := TKey
|                   end      ¯ THash ò    ;
| 
| 
| 
| 
| 
|               begin
|                 ¯ CHash ò
|                 Key := 0 ;
|                 T := S@.FirstTran ;
|                 while T <> NIL do
|                   begin
|                     Key := Key +THash(T) ;
|                     T := T@.Next
|                   end ;
|                 CHash := Key
|               end ;
|             ¯ CHashò
| 
| 
| 
| 
| 
| 
|             function Complete ( S : stateptrty; T : tranptrty) :
|                 stateptrty ;
| 
|                 ¯****************************************************ò
|                 ¯*                                                  *ò
|                 ¯* Complete                                         *ò
|                 ¯*                                                  *ò
|                 ¯* THIS function CREATES A new State and CompleteS IT *ò
|                 ¯* IT RETURNS A POinTER to THE CompleteD State       *ò
|                 ¯*                                                   *ò
|                 ¯*   in    :  S   CURRENt State                      *ò
|                 ¯*            T   TranSITION State                   *ò
|                 ¯*   OUT   :                                         *ò
|                 ¯*                                                   *ò
|                 ¯*   GLOBAL                                          *ò
|                 ¯*                                                   *ò
|                 ¯*  ResULT   PTR to CompleteD State                  *ò
|                 ¯*****************************************************ò
| 
|             var
|                 A : stateptrty ;
|                 C : tranptrty ;
|                 Reduce : boolean  ;
|                 I  : integer    ;
| 
| 
| 
|                 function Collect (S :stateptrty;T : tranptrty):stateptrty ;
|                     ¯************************************************ò
|                     ¯*                                              *ò
|                     ¯*  Collect                                     *ò
|                     ¯*                                              *ò
|                     ¯*  THIS function CREATES A new State  for THE  *ò
|                     ¯* GIVEN TranSITION. IT ALSO CollectS ALL       *ò
|                     ¯* TranSITIONS WHICh HAVE THE SAME TranSITION   *ò
|                     ¯* Token and ADDS IT to THE State               *ò
|                     ¯*                                              *ò
|                     ¯*  in     : S CURRENt State                    *ò
|                     ¯*              T CURRENt TranSITION            *ò
|                     ¯*                                              *ò
|                     ¯*   OUT                                        *ò
|                     ¯*                                              *ò
|                     ¯*   GLOBAL                                     *ò
|                     ¯*                                              *ò
|                     ¯*  ResULT  PTR to new State                    *ò
|                     ¯************************************************ò
| 
|                 var
|                     X,Z : tranptrty ;
|                     Y : stateptrty ;
| 
| 
| 
|                     function TranMatch(T1,T2 : tranptrty) : boolean ;
|                        ¯***********************************************ò
|                        ¯                                              *ò
|                        ¯*  TranMatch                                  *ò
|                        ¯*                                             *ò
|                        ¯*  THIS function ChECKS to SEE if THE TranSITION *ò
|                        ¯*  Token for THE GIVEN TWO ConfigURATIONS     *ò
|                        ¯*  IS THE SAME                                *ò
|                        ¯*                                             *ò
|                        ¯*   in       : T1,T2  ConfigURATIONS          *ò
|                        ¯*                                             *ò
|                        ¯*    OUT     :                                *ò
|                        ¯*                                             *ò
|                        ¯*   GLOBAL                                    *ò
|                        ¯*                                             *ò
|                        ¯*    ResULT IS TRUE if THEY MATCh             *ò
|                        ¯***********************************************ò
| 
| 
|                     var
|                         R : prodptrty ;
|                         I  : integer  ;
|                         S1,S2 : identptrty ;
| 
| 
| 
|                       begin
|                         ¯ TranMatch  ò
|                         R   := T1@.Rule  ;
|                         for I := 0 to T1@.Pos do
|                             R := R@.Next  ;
|                         if R = NIL then S1 := NIL
|                             else S1 := R@.Action ;
| 
|                         R := T2@.Rule  ;
|                         for I := 0 to T2@.Pos
|                             do R := R@.Next ;
|                         if R = NIL then  S2 := NIL
|                             else  S2 := R@.Action  ;
| 
|                         TranMatch := S1=S2  ;
| 
|                       end       ¯ TranMatch ò     ;
| 
| 
| 
|                     function CreateS (S:stateptrty; T: tranptrty):stateptrty ;
|                       ¯******************************************************ò
|                       ¯*                                                    *ò
|                       ¯*   CreateS                                          *ò
|                       ¯*                                                    *ò
|                       ¯*    THIS function CreateS A new State with A SinGLE *ò
|                       ¯*  ConfigURATION T . IT doES not ENtER THE State     *ò
|                       ¯* into  THE  State Table  SinCE THE State CompleteD  *ò
|                       ¯ MAY EXIST ALreadY                                   *ò
|                       ¯*                                                    *ò
|                       ¯*    IT RETURNS A POinTER to THE newLY CREATED State *ò
|                       ¯*                                                    *ò
|                       ¯*   in        : S PARENt State                       *ò
|                       ¯*               T  CURRENt ConfigURATION             *ò
|                       ¯*                                                    *ò
|                       ¯*   OUT       :                                      *ò
|                       ¯*                                                    *ò
|                       ¯*   GLOBAL                                           *ò
|                       ¯*                                                    *ò
|                       ¯    ResULT    PTR to new State                       *ò
|                       ¯******************************************************ò
| 
| 
| 
|                     var
|                         X   : stateptrty ;
| 
| 
| 
|                       begin
|                         ¯ CreateS   ò
|                         new(X)    ;
|                         with X@ do
|                           begin
|                             FirstTran := T;
|                             Nic   := NIL ;
|                             Back     := NIL ;
|                             State := 0    ;
|                             Kind      :=Reads
|                           end ;
| 
| 
|                         CreateS := X
|                       end        ¯ CreateS ò   ;
| 
| 
| 
|                     function  MoveDot (T : tranptrty) : tranptrty ;
|                         ¯***************************************************ò
|                         ¯*                                                 *ò
|                         ¯*   MoveDot                                       *ò
|                         ¯*                                                 *ò
|                         ¯*       THIS function CreateS A new  ConfigURATION*ò
|                         ¯* with THE PosITION of THE Dot MOVED OVER         *ò
|                         ¯*    IT RETURNS A POinTER to THIS TranSITION      *ò
|                         ¯* IT doES not WATChOUT for ReductionS. THIS  ID   *ò
|                         ¯* BY THE Closure function                         *ò
|                         ¯*                                                 *ò
|                         ¯*     in         : T CURRENt Config               *ò
|                         ¯*                                                 *ò
|                         ¯*     OUT         :                               *ò
|                         ¯*                                                 *ò
|                         ¯*      GLOBAL                                     *ò
|                         ¯*                                                 *ò
|                         ¯*    ResULT     PTR to new ConfigURATION          *ò
|                         ¯***************************************************ò
| 
| 
|                     var
|                         X  : tranptrty ;
| 
|                       begin
|                         ¯ MoveDot ò
|                         new(X)   ;
|                         with X@ do
|                           begin
|                             MarkE := FALSE ;
|                             Next := NIL ;
|                             NextState := NIL  ;
|                             Rule := T@.Rule ;
|                             Pos := T@.Pos +1
|                           end ;
| 
| 
|                         MoveDot  := X
|                       end    ¯ MOVE Dot  ò    ;
| 
| 
| 
| 
| 
| 
| 
| 
| 
|                   begin
|                     ¯ Collect  ò
|                     X := MoveDot (T) ;
|                     Y := CreateS (S,X)  ;
|                     Z := T@.Next ;
|                     while Z <> NIL do
|                       begin
|                         if TranMatch (Z,T)
|                         then
|                           begin
|                             Z@.MarkE := TRUE;
|                             X := MoveDot(Z) ;
|                             AddT(Y,X)
|                           end ;
|                         Z := Z@.Next ;
|                       end  ;
|                     Collect := Y
|                   end      ¯ Collect  ò    ;
| 
| 
| 
| 
| 
| 
|               begin
|                 ¯ Complete ò
|                 if Trace then
|                   begin
|                     writeln(TTYOut,'Complete');
|                     Break
|                   end ;
|                 A := Collect(S,T) ;
|                 C := NextTran( A,NIL) ;
|                 AllReduce := TRUE ;
|                 Reduce := FALSE ;
|                 I := 0   ;
|                 while C <> NIL do
|                   begin
|                     Closure(A,C,Reduce) ;
|                     I   := I+1 ;
|                     C := NextTran(A,C)
|                   end ;
|                 if Reduce then if I=1 then A@.Kind := Reduction
|                 else
|                   begin
|                     A@.Kind := Inadequate ;
|                     Lr0  := FALSE
|                   end ;
|                 Complete := A
|               end   ¯ Complete ò  ;
| 
|             procedure FindS(var S: stateptrty;var Found:boolean) ;
|                 ¯****************************************************ò
|                 ¯*                                                  *ò
|                 ¯*  FindS                                           *ò
|                 ¯*                                                  *ò
|                 ¯*    THIS procedure ChECKS to SEE if THE GIVEN     *ò
|                 ¯* State ALreadY EXISTS. if SO IT UPDATES S to      *ò
|                 ¯* POinT to THE EXISTinG State. in THIS case Found  *ò
|                 ¯* IS set to TRUE                                   *ò
|                 ¯*                                                  *ò
|                 ¯*     in:                                          *ò
|                 ¯*                                                  *ò
|                 ¯*   OUT : S   POinTS to Found State                *ò
|                 ¯*        Found  TRUE if State IS Found             *ò
|                 ¯*                                                  *ò
|                 ¯****************************************************ò
| 
|             var
|                 Key   : integer ;
|                 X     : stateptrty  ;
| 
| 
| 
|                 function StateMatch(S1,S2:stateptrty) : boolean ;
|                     ¯***************************************************ò
|                     ¯*                                                 *ò
|                     ¯*  StateMatch                                     *ò
|                     ¯*                                                 *ò
|                     ¯*   THIS procedure ChECKS to SEE if THE GIVEN     *ò
|                     ¯* StateS Match                                    *ò
|                     ¯*                                                 *ò
|                     ¯*    in:  S1,S2 THE StateS to BE MatchED          *ò
|                     ¯*                                                 *ò
|                     ¯***************************************************ò
| 
|                 var
|                     X,X2    : tranptrty ;
|                     A,B  : integer   ;
|                     Match  : boolean  ;
| 
|                   begin
|                     ¯ StateMatch ò
|                     StateMatch := FALSE ;
|                     A := 0  ;
|                     X := S1@.FirstTran   ;
|                     while X <> NIL do
|                       begin
|                         A := A+1 ;
|                         X := X@.Next ;
|                       end ;
| 
|                     B := 0 ;
|                     X := S2@.FirstTran ;
|                     while X <> NIL do
|                       begin
|                         B := B+1 ;
|                         X := X@.Next ;
|                       end ;
|                     if A =B
|                     then
|                       begin
|                         X := S1@.FirstTran ;
|                         Match := TRUE ;
|                         while (X <> NIL) and Match do
|                           begin
|                             Match := FALSE ;
|                             X2 := S2@.FirstTran ;
|                             while (X2 <> NIL) and not Match do
|                               begin
|                                 if ConMatch(X,X2) then Match := TRUE ;
|                                 X2 := X2@.Next
|                               end ;
|                             X := X@.Next
|                           end ;
|                         StateMatch := Match
|                       end
|                   end   ¯ StateMatch ò   ;
| 
| 
| 
|               begin
|                 ¯ FindS ò
|                 if Trace
|                 then
|                   begin
|                     writeln(TTYOut,'FindS');Break
|                   end;
|                 Found := FALSE ;
|                 Key   := CHash(S) ;
|                 Key := Key mod STATETABSIZE ;
|                 X     := StateTab [Key ] ;
|                 while (X <> NIL) and (not Found) do
|                   begin
|                     if StateMatch(X,S)
|                     then
|                       begin
|                         Found := TRUE ;
|                         S     := X
|                       end ;
|                     X := X@.Nic
|                   end
|               end    ¯ FindS  ò ;
| 
| 
| 
| 
| 
|             procedure Links(From : stateptrty ;
|                 On   : tranptrty;
|                 Dest   : stateptrty  ) ;
|                 ¯**********************************************************ò
|                 ¯*                                                        *ò
|                 ¯*  Links                                                 *ò
|                 ¯*                                                        *ò
|                 ¯*    THIS procedure Links THE From and to StateS         *ò
|                 ¯* BOTHWAYS                                               *ò
|                 ¯*                                                        *ò
|                 ¯*    in :     From  State                                *ò
|                 ¯*               Dest  State                              *ò
|                 ¯*               On  TranSITIOn                           *ò
|                 ¯*                                                        *ò
|                 ¯**********************************************************ò
| 
|             var
|                 X,Y,Z   : tranptrty ;
| 
| 
| 
|               begin
|                 ¯ Links ò
|                 On@.NextState := Dest ;
|                 new(X)    ;
|                 with X@ do
|                   begin
|                     Next := NIL ;
|                     MarkE := FALSE;
|                     Pos  := On@.Pos ;
|                     NextState := From ;
|                     Rule   := On@.Rule
|                   end ;
|                 Y := Dest@.Back ;
|                 if Y= NIL then Dest@.Back := X
|                 else
|                   begin
|                     while Y <> NIL do
|                       begin
|                         Z := Y ;
|                         Y := Y@.Next
|                       end;
|                     Z@.Next := X
|                   end
| 
|               end   ¯ Links ò   ;
| 
| 
|             procedure EnterS ( From:stateptrty; On:tranptrty;Dest:stateptrty);
|                 ¯***************************************************ò
|                 ¯*                                                 *ò
|                 ¯*  EnterS                                         *ò
|                 ¯*                                                 *ò
|                 ¯*   THIS procedure EnterS A new State and then    *ò
|                 ¯* Links THE From and Dest StateS                  *ò
|                 ¯*                                                 *ò
|                 ¯*  I   : From      State                          *ò
|                 ¯*          Dest      State                        *ò
|                 ¯*                                                 *ò
|                 ¯*          On      TranSITIOn                     *ò
|                 ¯*                                                 *ò
|                 ¯***************************************************ò
| 
|             var
|                 Key  :  integer ;
|                 X,Z  : stateptrty  ;
| 
| 
| 
|               begin
|                 ¯ EnterS ò
|                 if Trace
|                 then
|                   begin
|                     writeln(TTYOut,'EnterS'); Break
|                   end;
|                 Key := CHash(Dest)  ;
|                 Key := Key  mod STATETABSIZE ;
|                 if CurrentState >= MAXSTATE then
|                   begin
|                     writeln(TTYOut,'toO MANY StateS');
|                     CurrentState := MAXSTATE ;
|                   end
|                 else                 CurrentState := CurrentState+1 ;
|                 NState [ CurrentState ] := Dest ;
|                 Dest@.State := CurrentState ;
|                 if StateTab [Key] = NIL then StateTab[Key] := Dest
|                 else
|                   begin
|                     X := StateTab [Key ] ;
|                     while X <> NIL do
|                       begin
|                         Z := X ;
|                         X := X@.Nic
|                       end ;
|                     Z@.Nic := Dest
|                   end ;
|                 Links( From,On,Dest)
|               end     ¯EnterS ò   ;
| 
| 
|           begin
|             ¯ GenS  ò
|             if Trace then
|               begin
|                 writeln(TTYOut,'GenS');
|                 Break
|               end ;
|             if Debug then if FSM then PrintState(S) ;
|             X := NextTran (S,NIL) ;
|             while X <> NIL do
|               begin
|                 Z := X@.Rule ;
|                 for I := 0 to X@.Pos
|                 do  Z := Z@.Next ;
|                 if Z <> NIL then
|                   begin
|                     mark(Heap) ;
|                     Y := Complete (S,X) ;
|                     FindS(Y,B) ;
|                     if B then
|                       begin
|                         release(Heap) ; ¯ NO new State WAS NEEDED ò
|                         Links (S,X,Y)
|                       end
|                     else
|                       begin
|                         EnterS(S,X,Y) ;
|                         if Y@.Kind =Inadequate then
|                           begin
|                             AddL(Y) ;
|                             if AllReduce then Y@.Kind:= Reduction ;
|                           end ;
|                         if Y@.Kind <> Reduction then
|                         GenS(Y,Lr0)
|                       end ;
|                   end ;
|                 X := NextTran(S,X)
|               end
|           end    ¯ GenS   ò   ;
| 
| 
| 
| 
| 
|       begin
|         if Trace then
|           begin
|             writeln(TTYOut, 'CFSM') ;
|             Break
|           end ;
|         Lr0 := TRUE ;
|         S   := CIS ; ¯ CREATE inITIAL State ò
|         GenS(S,Lr0) ;
|         if Debug then if IFSM then
|           begin
|             Sl1 := Inadeq ;
|             while Sl1 <> NIL do
|               begin
|                 S1 := Sl1@.CAR ;
|                 PrintState(S1);
|                 Sl1 := Sl1@.CDR ;
|               end ;
|           end ;
|       end   ¯ CFSM ò ;
| 
| 
| 
| 
|     procedure LaLr ( K: integer ; LrK : boolean ) ;
|         ¯************************************************ò
|         ¯*                                              *ò
|         ¯*  LaLr                                        *ò
|         ¯*                                              *ò
|         ¯*   THIS procedure ATTEMPTS to ResOLVE         *ò
|         ¯* ALL Inadequate StateS, USinG A               *ò
|         ¯* MAXIMUM of K Lookahead. IT SETS              *ò
|         ¯* LrK to FALSE if THIS IS not PosSIBLE         *ò
|         ¯* for THE GIVEN K                              *ò
|         ¯*                                              *ò
|         ¯*                                              *ò
|         ¯*    GLOBAL       in:                          *ò
|         ¯*                                              *ò
|         ¯*                                              *ò
|         ¯*                                              *ò
|         ¯*               OUT :                          *ò
|         ¯************************************************ò
|     var
|         Y : stateptrty ;
|         I : integer;
|         X,Z : statelistptr ;
| 
| 
| 
| 
|         function Disjoint( X,Y :stateptrty) : boolean ;
|             ¯*******************************************************ò
|             ¯*                                                     *ò
|             ¯*  Disjoint                                           *ò
|             ¯*                                                     *ò
|             ¯*     THIS function ChECKS to SEE if THE Lookahead    *ò
|             ¯* String of Y IS SUFFICIENt to ResOLVE State X        *ò
|             ¯* if SO IT RETURNS TRUE                               *ò
|             ¯*                                                     *ò
|             ¯*     in     :   X     Inadequate State               *ò
|             ¯*                Y     Lookahead String State         *ò
|             ¯*                                                     *ò
|             ¯*     ResULT      TRUE if Disjoint else FALSE         *ò
|             ¯*******************************************************ò
| 
|         var
|             Check : boolean ;
|             Id,Id2 : identptrty ;
|             S  : stateptrty ;
|             Q,R,T : tranptrty;
| 
| 
| 
|           begin
|             ¯ Disjoint ò
|             Disjoint := TRUE ;
|             Check := TRUE ;
|             T := Y@.FirstTran ;
|             while ( T <> NIL) and Check do
|               begin
|                 Id := Token(T@.Rule,T@.Pos);
|                 Q := X@.FirstTran ;
|                 while (Q <> NIL) and Check do
|                   begin
|                     Id2 := Token(Q@.Rule,Q@.Pos);
|                     if Id2<> NIL then
|                       begin
|                         if Id2=Id then Check := FALSE;
|                       end
| 
|                     else
|                       begin
|                         S := Q@.NextState ;
|                         if (S<> NIL) and(S<>Y)
|                         then
|                           begin
|                             R := S@.FirstTran ;
|                             while (R<> NIL) and Check do
|                               begin
|                                 if Token(R@.Rule,R@.Pos)=Id then
|                                     Check := FALSE;
|                                 R := R@.Next ;
|                               end ;
|                           end ;
|                       end ;
|                     Q := Q@.Next ;
|                   end ;
|                 T := T@.Next ;
|               end ;
|             Disjoint := Check ;
|           end   ¯ Disjoint  ò  ;
| 
| 
|         procedure Follow(A : stateptrty;B :tranptrty;C :stateptrty) ;forward;
| 
|         procedure  Resolve( Y : stateptrty ;  var B : boolean) ;
| 
|             ¯****************************************************ò
|             ¯*                                                   *ò
|             ¯*  Resolve                                          *ò
|             ¯*                                                   *ò
|             ¯*   THIS procedure ResolveS ANY InadeqUACIES        *ò
|             ¯* IT IS CALLED for EACh Inadequate State            *ò
|             ¯* if UNABLE to Resolve A State IT SETS B to FALSE   *ò
|             ¯*                                                   *ò
|             ¯*    in    Y   GIVEN State                          *ò
|             ¯*                                                   *ò
|             ¯*    OUT   B   set to FALSE if UNABLE to Resolve    *ò
|             ¯*                                                   *ò
|             ¯*****************************************************ò
| 
|         var
|             Id : identptrty ;
|             X,Z : statelistptr ;
|             I   : integer ;
|             T,U : tranptrty  ;
|             Q,S : stateptrty ;
| 
| 
| 
|           begin
|             ¯ Resolve ò
|             if Trace then
|               begin
|                 writeln(TTYOut,'Resolve');Break ;
|               end ;
|             T := Y@.FirstTran ;
|             while T <> NIL do
|               begin
|                 Id := Token( T@.Rule,T@.Pos) ;
|                 if Id = NIL then
|                   begin
|                     new(S) ;
|                     with S@ do
|                       begin
|                         FirstTran := NIL ;
|                         Back := NIL ;
|                         Nic  := NIL ;
|                         CurrentState := CurrentState+1 ;
|                         if CurrentState > MAXSTATE then
|                           begin
|                             writeln(TTYOut,' Too many states.') ;
|                             CurrentState := MAXSTATE ;
|                           end  ;
|                         State := CurrentState ;
|                         Kind := LAString ;
|                       end ;
|                     NState [ CurrentState ] := S ;
|                     CurrentVisit := 0;
|                     Follow (Y,T,S) ;
|                     T@.NextState := S ;
|                     if CurrentVisit >0 then
|                     for I := 1 to CurrentVisit do
|                       begin
|                         Visit[I]@.MarkE := FALSE ;
|                         Visit [I] := NIL ;
|                       end ;
|                     CurrentVisit := 0;
|                     if Debug and IFSM then
|                       begin
|                         writeln(TTYOut); writeln(TTYOut);
|                         writeln(TTYOut,'Inadequate State ') ;
|                         writeln(TTYOut);
|                         PrintState(Y) ;
|                         writeln(TTYOut);
|                         writeln(TTYOut,'Lookahead String') ;
|                         PrintState(Y) ;
|                       end ;
|                     if Disjoint (Y,S) then Y@.Kind := Lookahead
|                     else
|                       begin
|                         Y@.Kind := Inadequate ; ¯ Just in case it was set ò
|                                                 ¯ otherwise previously    ò
|                         B := FALSE ;
|                         Z := Conflict ;
|                         new(X) ;
|                         X@.CAR := S ;
|                         X@.CDR := NIL ;
|                         if Z=NIL then Conflict := X
|                         else
|                           begin
|                             while Z@.CDR <> NIL do
|                             Z := Z@.CDR ;
|                             Z@.CDR := X ;
|                           end ;
|                       end ;
|                   end ;
|                 T := T@.Next ;
|               end ;
|           end ¯ Resolve   ò ;
| 
| 
| 
| 
|         procedure Reverse (A:stateptrty; B :tranptrty;N:integer ;
|             S : stateptrty )   ;
|             ¯************************************************ò
|             ¯*                                               *ò
|             ¯* Reverse                                       *ò
|             ¯*                                               *ò
|             ¯*    THIS procedure EXECUTES THE Reduction and  *ò
|             ¯* MAKES THE APPrOPrIATE TranSITIOn              *ò
|             ¯*                                               *ò
|             ¯*   in    A   BASE State                        *ò
|             ¯*         B   Reduction                         *ò
|             ¯*         N   Number of BackUPS to GO           *ò
|             ¯*         S   LookSHead String State            *ò
|             ¯*                                               *ò
|             ¯*************************************************ò
| 
|         var
|             Id : identptrty ;
|             A1 : stateptrty ;
|             T : tranptrty ;
| 
| 
|             function MakeTran( A:stateptrty; B :tranptrty ) : stateptrty ;
|                 ¯******************************************************ò
|                 ¯*                                                    *ò
|                 ¯* MakeTran                                           *ò
|                 ¯*                                                    *ò
|                 ¯*    THIS function MAKES THE APPrOPrIATE TranSITIOn  *ò
|                 ¯* for THE GIVEN Reduction B and RETURNS THE ResULTANt*ò
|                 ¯* State                                              *ò
|                 ¯*                                                    *ò
|                 ¯*   in     A State                                   *ò
|                 ¯*          B GIVEN Reduction                         *ò
|                 ¯*                                                    *ò
|                 ¯*  ResULT  IS THE DestinATIOn State                  *ò
|                 ¯*                                                    *ò
|                 ¯******************************************************ò
| 
|             label
|                 1;
|             var
|                 X : tranptrty ;
|                 new : stateptrty ;
|                 Id : identptrty ;
| 
| 
| 
|               begin
|                 ¯ MakeTran ò
|                 new := NIL ;
|                 Id := B@.Rule@.XDef ;
|                 X := A@.FirstTran ;
|                 while X <> NIL do
|                   begin
|                     if Token(X@.Rule,X@.Pos)= Id
|                     then
|                       begin
|                         new := X@.NextState ;
|                         if new <> NIL then goto 1 ;
|                       end ;
|                     X := X@.Next ;
|                   end ;
|                 1:
|                 MakeTran := new ;
|               end ¯ MakeTran ò   ;
| 
| 
|           begin
|             ¯ Reverse  ò
|             if Trace then
|               begin
|                 writeln(TTYOut,'Reverse');Break ;
|               end ;
|             if N=0 then
|               begin
|                 A1 := MakeTran(A,B) ;
|                 if A1 = NIL then writeln(TTYOut,'**SySTEM Error** in Reverse')
|                 else
|                   begin
|                     T := A1@.FirstTran ;
|                     while T <> NIL do
|                       begin
| ¯suspect code:           Id := Token(T@.Rule,T@.Pos);           ò
| ¯                        if Id@.Kind <> NonTerm then             ò
|                         Follow(A1,T,S) ;
|                         T := T@.Next ;
|                       end ;
|                   end
|               end
|             else
|               begin
|                 T := A@.Back ;
|                 while T <> NIL do
|                   begin
|                     A1 := T@.NextState ;
|                     Reverse(A1,B,N-1,S) ;
|                     T := T@.Next ;
|                   end ;
|               end ;
|           end ¯ Reverse   ò  ;
| 
| 
|         procedure Follow ;
|             ¯***************************************************ò
|             ¯*                                                 *ò
|             ¯* Follow                                          *ò
|             ¯*                                                 *ò
|             ¯* THIS IS A forward procedure                     *ò
|             ¯*      THIS procedure inITIALIZES C with THE      *ò
|             ¯* Terminals THAT Follow                           *ò
|             ¯*                                                 *ò
|             ¯*   in   : A   BASE State                         *ò
|             ¯*          B    GIVEN TranSITIOn                  *ò
|             ¯*          C   Lookahead String State             *ò
|             ¯*                                                 *ò
|             ¯***************************************************ò
| 
|         var
|             Id  : identptrty ;
|             X   : stateptrty ;
|             P  : prodptrty ;
|             Pop : integer   ;
|             T   : tranptrty ;
| 
| 
| 
|             procedure AddLook ( S: stateptrty;Q : tranptrty);
|                 ¯*******************************************************ò
|                 ¯*                                                     *ò
|                 ¯*  AddLook                                            *ò
|                 ¯*                                                     *ò
|                 ¯*      THIS procedure ADDS THE GIVEN TranSITIOn       *ò
|                 ¯* to THE EXISTinG Lookahead String AS REPresENtED BY  *ò
|                 ¯*   S                                                 *ò
|                 ¯*                                                     *ò
|                 ¯*   in      S   Lookahead String State                *ò
|                 ¯*           Q   new TranSITIOn                        *ò
|                 ¯*                                                     *ò
|                 ¯*******************************************************ò
| 
|             var
|                 X : tranptrty ;
| 
|               begin
|                 ¯ AddLook ò
|                 new(X)   ;
|                 with X@ do
|                   begin
|                     Rule := Q@.Rule ;
|                     Pos  := Q@.Pos  ;
|                     MarkE := FALSE  ;
|                     Next  := NIL  ;
|                     NextState := NIL ;
|                   end ;
|                 AddT(S,X)  ;
|               end ¯ AddLook   ò  ;
| 
| 
| 
|           begin
|             ¯ Follow ò
|             if Trace then
|               begin
|                 writeln(TTYOut,'Follow');
|                 Break ;
|               end ;
|             Id := Token(B@.Rule,B@.Pos) ;
|             if not B@.MarkE then
|               begin
|                 B@.MarkE := TRUE ;
|                 CurrentVisit := CurrentVisit+1 ;
|                 if CurrentVisit > MAXVISIT then
|                 writeln(TTYOut,'OVERFLOW of Visit StateS')
|                 else Visit[CurrentVisit] := B ;
|                 if Id = NIL then
|                   begin
|                     Pop := 0 ;
|                     P := B@.Rule ;
|                     P := P@.Next ;
|                     while P <> NIL
|                     do
|                       begin
|                         Pop := Pop +1 ;
|                         P := P@.Next ;
|                       end ;
|                     if B@.NextState = NIL then Reverse(A,B,Pop,C)
|                     else
|                       begin
|                         X := B@.NextState ;
|                         T := X@.FirstTran ;
|                         while T <> NIL do
|                           begin
|                             AddLook(C,T) ;
|                             T := T@.Next ;
|                           end ;
|                       end ;
|                   end
|                 else
|                 if Id@.Kind = Term then AddLook(C,B) ;
|               end ;
|           end ¯ Follow ò   ;
| 
| 
|       begin
|         ¯  LaLr  ò
|         if Trace then
|           begin
|             writeln(TTYOut, 'LaLr') ;
|             Break ;
|           end ;
|         Z := Inadeq ;
|         X := Inadeq ;
|         LrK := TRUE ;
|         while X <> NIL do
|           begin
|             Y := X@.CAR ;
|             Resolve(Y,LrK) ;
|             if Y@.Kind = Lookahead
|             then if X= Inadeq then Inadeq := X@.CDR
|             else Z@.CDR := X@.CDR
|             else Z := X ;
|             X := X@.CDR ;
|           end ;
|         if not LrK then
|           begin
|             writeln(TTYOut);
|             writeln(TTYOut,'The grammar is not laLR(',K:1,')');
|             if IFSM then
|               begin
|                 I := B14 ;
|                 Ch := ChR(I) ;
|                 writeln(CrefPas,Ch) ;
|                 writeln(CrefPas,'                      Conflict States');
|                 writeln(CrefPas,'                      ===============');
|                 writeln(CrefPas);writeln(CrefPas);writeln(CrefPas);
|                 X := Inadeq ;
|                 while X <> NIL do
|                   begin
|                     PrintState(X@.CAR) ;
|                     X := X@.CDR ;
|                   end ;
|                 X := Conflict ;
|                 while X <> NIL do
|                   begin
|                     PrintState(X@.CAR) ;
|                     X := X@.CDR ;
|                   end ;
|               end ¯ IFSM< ò  ;
|           end ¯ LrKò   ;
| 
|       end ;
|     ¯  LaLr  ò
| 
| 
| 
|     procedure   Optim  ;
|         ¯************************************************ò
|         ¯*                                              *ò
|         ¯*        Optim              ;                  *ò
|         ¯*                                              *ò
|         ¯*                                              *ò
|         ¯*   THIS procedure OptimizeS THE State Tables  *ò
|         ¯*  GENERATED ALSO. THE OptimIZATIOn IS         *ò
|         ¯*  doNE USinG FinITE State TEChNIQUES in ordER *ò
|         ¯*  to Reduce THE Number of StateS.             *ò
|         ¯*    THE FollowinG OptimIZATIOnS ARE doNE      *ò
|         ¯*    A. REMOVAL of NOn Terminal TranSITIOnS    *ò
|         ¯*    B. REMOVAL of ChAin DEVIATIOnS            *ò
|         ¯*                                              *ò
|         ¯************************************************ò
|       begin
|         ¯  Optim  ò
|         writeln(TTYOut, 'Optim')
|       end   ;
| 
| 
| 
|     function FindRule(T: tranptrty) : integer ;
| 
|         ¯*****************************************************ò
|         ¯*                                                   *ò
|         ¯* FindRule                                          *ò
|         ¯*                                                   *ò
|         ¯*     THIS function RETURNS THE Rule Number of THE  *ò
|         ¯* GIVEN Production                                  *ò
|         ¯*                                                   *ò
|         ¯*     in : T  GIVEN TranSITIOn                      *ò
|         ¯*                                                   *ò
|         ¯*    OUT :                                          *ò
|         ¯*    ResULT   Rule NO. of Production                *ò
|         ¯*****************************************************ò
| 
|     label
|         1;
|     var
|         L :   listptrty ;
| 
|       begin
|         ¯ FindRule ò
|         FindRule := UNKNOWN ;
|         L := T@.Rule@.XDef@.Defin ;
|         if L= NIL  then writeln(TTYOut,'**SySTEM Error 2**') ;
|         while L<> NIL do
|           begin
|             if RuleTab[L@.CAR]=T@.Rule then
|               begin
|                 FindRule := L@.CAR ;
|                 goto 1
|               end ;
|             L := L@.CDR ;
|           end ;
|         1:
|       end ¯ FindRule  ò  ;
| 
| 
| 
|     procedure   OutT     ;
|         ¯************************************************ò
|         ¯*                                              *ò
|         ¯*     OutT                                     *ò
|         ¯*                                              *ò
|         ¯*   THIS procedure GENERATES THE PARSER Tables,*ò
|         ¯* Production Number Tables and THE SEMANtICS   *ò
|         ¯* Tables                                       *ò
|         ¯************************************************ò
| 
| 
| 
|         procedure GenTab ;
|             ¯***********************************************ò
|             ¯*                                             *ò
|             ¯* GenTab                                      *ò
|             ¯*                                             *ò
|             ¯*  THIS procedure GENERATES Tables in THE     *ò
|             ¯* REQUIRed forM VIZ MERGinG symbolS and THE   *ò
|             ¯* THE Action list WHEREVER PosSIBLE           *ò
|             ¯*                                             *ò
|             ¯***********************************************ò
|         label
|             1;
|         var
|             I,J  : integer ;
|             S : stateptrty ;
|             Entry : integer ;
|             Done : boolean ;
| 
| 
| 
| 
|             procedure EnterSeg(T,A : integer) ;
| 
|                 ¯************************************************ò
|                 ¯*                                              *ò
|                 ¯* EnterSeg                                     *ò
|                 ¯*                                              *ò
|                 ¯*   THIS procedure EnterS A symbol Action PAIR *ò
|                 ¯* into THE Table                               *ò
|                 ¯************************************************ò
| 
| 
| 
|               begin
|                 ¯ EnterSeg ò
|                 if Index >= MAXTABSIZE then writeln(TTYOut,'Overflow of Table')
|                 else Index := Index+1 ;
|                 Table [Index].Tran := T;
|                 Table [Index].Action := A ;
|               end ¯ EnterSeg ò   ;
| 
| 
| 
|             procedure MakeSeg (S :stateptrty) ;
|                 ¯*************************************************ò
|                 ¯*                                               *ò
|                 ¯* MakeSeg                                       *ò
|                 ¯*                                               *ò
|                 ¯*  THIS procedure COPIES A Segment I.E. A State *ò
|                 ¯* and forMATS into A symbol Action PAIR         *ò
|                 ¯*                                               *ò
|                 ¯*************************************************ò
|             label
|                 1;
|             var
|                 Act : integer ;
|                 Id : identptrty ;
|                 First : boolean ;
|                 K,LastCount,CurrCount : integer ;
|                 P : integer ;
|                 Last,T : tranptrty ;
| 
| 
| 
| 
| 
| 
|                 function Count (S :stateptrty) : integer ;
| 
|                     ¯*********************************************ò
|                     ¯*                                           *ò
|                     ¯* Count                                     *ò
|                     ¯*                                           *ò
|                     ¯*   THIS function RETURNS THE Number of     *ò
|                     ¯* UNIQUE TranSITIOnS of A GIVEN State       *ò
|                     ¯*********************************************ò
| 
|                 var
|                     Temp : integer ;
|                     Id : identptrty ;
|                     Q,T : tranptrty ;
|                   begin
|                     ¯ Count ò
|                     Temp := 0;
|                     T := NextTran(S,NIL);
|                     while T <> NIL do
|                       begin
|                         Id := Token(T@.Rule,T@.Pos);
|                         Q := T@.Next ;
|                         while Q <> NIL do
|                           begin
|                             if Token(Q@.Rule,Q@.Pos)=Id then Q@.MarkE := TRUE;
|                             Q := Q@.Next ;
|                           end ;
|                         Temp := Temp +1 ;
|                         T := NextTran(S,T) ;
|                       end ;
|                     Count := Temp ;
|                   end ¯ Count ò ;
| 
| 
| 
|                 procedure Expand ( P : tranptrty) ;
|                     ¯************************************************ò
|                     ¯*                                              *ò
|                     ¯* Expand                                       *ò
|                     ¯*                                              *ò
|                     ¯*    THIS procedure EXOandS A Lookahead String *ò
|                     ¯* A symbol Action list                         *ò
|                     ¯************************************************ò
| 
|                 var
|                     S : stateptrty ;
|                     PRule : integer ;
|                     T,Q : tranptrty ;
|                     Id : identptrty ;
|                   begin
|                     S := P@.NextState ;
|                     T := NextTran (S,NIL) ;
|                     PRule := P@.Rule@.Production ;
|                     while T <> NIL do
|                       begin
|                         Id := Token (T@.Rule ,T@.Pos) ;
|                         Q := T@.Next ;
|                         while Q <> NIL do
|                           begin
|                             if Token(Q@.Rule,Q@.Pos)=Id then Q@.MarkE := TRUE;
|                             Q := Q@.Next ;
|                           end ;
|                         EnterSeg(Id@.Code,-PRule-NOSCANCODE) ;
|                         T := NextTran(S,T) ;
|                       end ;
|                   end ¯ Expand ò  ;
| 
| 
| 
|               begin
|                 ¯ MakeSeg ò
|                 First := TRUE ;
|                 Segment[0].Tran := UNKNOWN ;
|                 Segment[0].Action := UNKNOWN ;
|                 P := UNKNOWN ;
| 
|                 SegIndex := -1 ;
|                 T :=S@.FirstTran ;
|                 while T <> NIL do
|                   begin
|                     ¯whileò
|                     if T@.NextState <> NIL then
|                       begin
|                         ¯COPYò
|                         Id := Token(T@.Rule,T@.Pos) ;
|                         if Id <> NIL then K := Id@.Code else K:=UNKNOWN;
|                         if T@.NextState@.Kind=LAString then
|                           begin
|                             ¯LAStringò
|                             if First then
|                               begin
|                                 ¯Firstò
|                                 First := FALSE;
|                                 Last := T ;
|                                 LastCount := Count(Last@.NextState) ;
|                                 goto 1 ;
|                               end ¯Firstò
|                             else
|                               begin
|                                 ¯not Firstò
|                                 CurrCount := Count(T@.NextState);
|                                 if CurrCount > LastCount+THRESHOLD then
|                                   begin
|                                     ¯SWAPò
|                                     Expand(Last) ;
|                                     Last := T ;
|                                     LastCount := CurrCount ;
|                                   end ¯SWAPò
|                                 else Expand(T) ;
|                                 goto 1 ;
|                               end ¯not Firstò
|                           end ¯ LAStringò
|                         else if T@.NextState@.Kind=Reduction then
|                         P := -T@.Rule@.Production
|                         else
|                         P := T@.NextState@.State ;
|                         if SegIndex >= MAXSEGMENT then
|                             writeln(TTYOut,'Segment Overflow!')
|                         else SegIndex := SegIndex+1;
|                         Segment[SegIndex].Tran := K ;
|                         Segment[SegIndex].Action := P ;
|                       end ¯COPY ò ;
|                     1: T := T@.Next ;
|                   end ¯whileò  ;
|                 if S@.Kind = Lookahead then
|                 if First then writeln(TTYOut,'System error in MAKESEG2')
|                          else Act := - Last@.Rule@.Production-NOSCANCODE ;
| 
|                 if S@.Kind= Reads then Act := ERRORCODE;
|                 if (S@.Kind=Reads) or (S@.Kind=Lookahead)
|                 then
|                   begin
|                     if SegIndex>= MAXSEGMENT then
|                         writeln(TTYOut,'*Segment Overflow!')
|                     else SegIndex := SegIndex+1 ;
|                     Segment[SegIndex].Tran := elseCode;
|                     Segment[SegIndex].Action := Act ;
|                   end ;
|               end ¯MakeSegò  ;
| 
| 
| 
| 
| 
| 
|             function SegMatch(Ind:integer) : integer ;
|                 ¯*****************************************************ò
|                 ¯*                                                   *ò
|                 ¯*  SegMatch                                         *ò
|                 ¯*                                                   *ò
|                 ¯*     THIS function RETURNS TRUE if THE Segment     *ò
|                 ¯* MatchES AN Entry in THE Table .if THERE IS NO     *ò
|                 ¯* Match IT RETURNS UNKNOWN                          *ò
|                 ¯*****************************************************ò
|             label
|                 1,2;
|             var
|                 I,K : integer ;
|                 Mate : integer ;
| 
| 
| 
|               begin
|                 ¯ SegMatchò
|                 SegMatch := UNKNOWN ;
|                 if Index > (SegIndex-Ind) then
|                 for Mate := 0 to Index-(SegIndex-Ind) do
|                   begin
|                     K := Mate ;
|                     for I := Ind to SegIndex do
|                       begin
|                        if Table[K].Tran=XCONTINUE
|                            then K := Table[K].Action;
|                         if (Segment[I].Tran <> Table[K].Tran)
|                         or (Segment[I].Action <> Table[K].Action) then goto 1;
|                         K := K+1;
|                       end ;
|                     SegMatch := Mate ; goto 2;
|                     1:
|                   end ¯ for ò ;
|                 2:
|               end  ¯ SegMatch ò  ;
| 
| 
| 
| 
| 
| 
| 
| 
|           begin
|             ¯ GenTab ò
|             Index := -1 ;
|             for I := 0 to CurrentState do
|               begin
|                 S := NState [I ];
|                 if (S@.Kind <> Reduction) and (S@.Kind <> LAString) then
|                   begin
|                         NewState[I] := Index+1 ;
|                     MakeSeg(S) ;
|                     Entry := SegMatch(0);
|                     if Entry <> UNKNOWN then NewState[I] := Entry
|                     else
|                       begin
|                         EnterSeg(Segment[0].Tran,Segment[0].Action) ;
|                         if SegIndex > 0 then
| 
|                         begin
|                         for J := 1 to SegIndex-1 do
|                           begin
|                             Entry := SegMatch(J);
|                             if Entry <> UNKNOWN then
|                               begin
|                                 EnterSeg(XCONTINUE,Entry);
|                                 goto 1 ;
|                               end
|                             else EnterSeg(Segment[J].Tran,Segment[J].Action);
|                           end ;
|                         EnterSeg(Segment[SegIndex].Tran,
|                                  Segment[SegIndex].Action);
|                         end ;
|                         1:
|                       end ;
|                   end ;
|               end  ¯ for ò ;
|             ¯ RENumber new StateS ò
|             for I := 0 to CurrentState do
|             if NState[I]@.Kind <> LAString then
|             NState[I] @.State := NewState[I] ;
|             for I := 0 to Index do
|             if (Table[I].Action >=0) and (Table[I].Action <=CurrentState)
|             and (Table[I].Tran <> XCONTINUE) then
|             Table[I].Action := NewState[Table[I].Action ];
|           end ¯ GenTab ò   ;
| 
| 
| 
|         procedure OutTab ;
|         ¯***********************************************ò
|         ¯*                                             *ò
|         ¯* OutTab                                      *ò
|         ¯*                                             *ò
|         ¯*    THIS procedure GENERATES TabPas          *ò
|         ¯* THE Tables                                  *ò
|         ¯***********************************************ò
| 
| var
|     I,K,T,A : integer ;
|     DoSymbolic : boolean;
|     X : identptrty;
|     Id : word;
| 
| 
| 
|  begin  ¯ OutTab ò
|         I := B14;
|         Ch := ChR(I);
|         writeln(TabPas,Ch);
|         writeln(TabPas,XCONTINUE,' ',elseCode,' ',ERRORCODE,' ',NOSCANCODE);
|         writeln(TabPas);
| 
|         writeln(TabPas,ERRORCODE);
|         writeln(TabPas,MaxCode);
|         writeln(TabPas,MaxPop);
|         writeln(TabPas,MaxProdNo);
|         writeln(TabPas,Index);
|         writeln(TabPas,elseCode);
|         writeln(TabPas,-1); ¯PARTITIONò
|         writeln(TabPas);
|         writeln(TabPas);
| 
|                 ¯ GENERATE labelSò
| 
|         for K := 0 to NAMETABSIZE do
|         begin
|                 X := NameTab[K];
|                 while X<> NIL do
|                 begin
|                    if X@.Kind in  [Lab]
|                         then writeln(TabPas,X@.ExternalName);
|                    X := X@.Nic;
|                 end ;
|         end ;
|         writeln(TabPas,-1) ; ¯ PARTò
|         writeln(TabPas);writeln(TabPas);writeln(TabPas);
| 
| 
|                 ¯ GENERATE Table arraySò
| 
|         for I := 0 to Index do
|         begin
|             T := Table[I].Tran ;
|             A := Table[I].Action;
|             write(TabPas, I, ' ');
|             if (T >= 0) and (T < MaxVocSize) then begin
|                 DoSymbolic := Symbolic and Terminals and
|                                 (SymbolName[T]@.Kind = Term);
|                 DoSymbolic := DoSymbolic or (
|                                 Symbolic and NonTerminals and
|                                 (SymbolName[T]@.Kind = NonTerm));
|                 DoSymbolic := DoSymbolic or (SymbolName[T]@.Spid = Res);
|             end else
|                 DoSymbolic := FALSE;
|             if DoSymbolic then
|                 write(TabPas, SymbolName[T]@.ExternalName)
|             else
|                 write(TabPas, T);
|             writeln(TabPas, ' ', A);
|         end ;
|         writeln(TabPas,-1);
|         writeln(TabPas);
| 
|                 ¯ GENERATE Pop and SEMANtICSò
| 
|         DoSymbolic := Symbolic and NonTerminals;
| 
|         for I := 1 to ProdNo do
|         begin
| 
|             T := PopTab[I] -1;
|             A := RuleTab[I]@.XDef@.Code;
|             X := RuleTab[I]@.Action;
|             if X = NIL then Id := 'NULL           '
|                 else Id :=X@.ExternalName;
|             write(TabPas,I,' ', T, ' ');
|             if DoSymbolic then
|                 write(TabPas, RuleTab[i]@.XDef@.ExternalName)
|             else
|                 write(TabPas, A);
|             writeln(TabPas,' ',Id);
|         end ;
| 
|         writeln(TabPas,-1) ; ¯ PARTò
| 
|         writeln(TabPas);
|    end ¯OutTabò  ;
| 
| 
| 
| 
| 
| 
| 
|       begin
|         ¯  OutT  ò
|         writeln(TTYOut,' Generating Tables...') ;
|         GenTab ;
|         if FSM or tables then    ¯ always want tables ò
|         PrintTab ;   ¯ even when you don't want the to see the FSM -hde '83ò
|         OutTab;
|       end   ;
| 
| 
| 
|     procedure   OutFreq          ;
|         ¯************************************************ò
|         ¯*                                              *ò
|         ¯*    OutFreq                                   *ò
|         ¯*                                              *ò
|         ¯*     THIS procedure OUTPUTS ALL STATISTICS    *ò
|         ¯*  ConCERNinG THE PrOGRAM, to FILNAM.CRL       *ò
|         ¯*     THE FollowinG WILL BE inCLUDED           *ò
|         ¯*   1. Frequency of Terminals, NOn Terminals.  *ò
|         ¯************************************************ò
|       begin
|         ¯  OutFreq  ò
|         writeln(TTYOut,'OutFreq')
|       end   ;
| 
| 
| 
|   begin
|     ¯  main  ò
|     InitSp;           ¯ initialize some data ò
|     InitOptions ;     ¯initialize options to defaults ò
|     InitGlob;         ¯initialize global variables ò
|     mark(HeapBot) ;
|     open( TTYOut, 'TTY:', [ OpenOutput ] );
|     InitP          ;  ¯  Initialize tables as read. ò
|     if not FatalError then
|         Terminal       ;  ¯  Read terminals ò
|     if not FatalError then begin
|         ReadG          ;  ¯  Read grammar ò
|         writeln(TTYOut,' There are ', maxprodno:2,' rules.');
|     end;
|     if Grammar or Terminals and not FatalError then
|       begin
|         if Grammar then  PrintG ;
|         PrintCref ;
|       end ;
|     if ErrorFlag or FatalError then
|         writeln(TTYOut,'Error in the productions - NO tables generated.')
|     else
|     if Lr0 then
|       begin
|         ¯ Lr0 ò
|         CFSM(Lr0) ;
|         if (not Lr0) and Look
|         then
|           begin
|             LrK := TRUE ;
|             LaLr(MaxK,LrK) ;
|           end ;
|         if LrK or Lr0 then
|           begin
|             if Optimize then Optim ;
|             if Tables or PN then OutT ;
|           end ;
|         if FSM then OutFSM ;
|       end   ¯ Lr0 ò ;
|     if Frequency then  OutFreq ;
|     mark(HeapTop) ;
| ¯   writeln(TTYOut,'Storage used: ',HeapBot-HeapTop : 5) ;         ò
| ¯ the above line is commented out because pointers aren't integers
|     (in PASCALVS), and also, it is not TRUE since other marks and
|     releases are done in the Rest of the code
| ò
|     if FatalError then
|         SetReturnCode(2)
|     else if ErrorFlag then
|         SetReturnCode(1);
| 
|   end.
| 
> Member PATPAS
| (*$M-*)
| program patpas;
| ¯
|     This program is a backend to PAT, and constructs the pascal file
|     implementing the grammar specified to PAT.
| 
|     We read two files, FILE.tab and FILE.patpas.  The .tab file is one
|     of the PAT output files.  The patpas file contains bits and pieces
|     of what the user wants in the final pascal file, including the
|     semantic actions.
| 
|     We also attempt to read FILE.ter, and create CONSTs to define the
|     output of the INSYMBOL procedure symbolically.
| ò
| 
| const
|     SYMBOLSIZE = 32;
|     BUFFERSIZE = 200;
|     DEBUGMAX = 4001;    ¯ number of TERM/NONTERM symbols we can save ò
|     OURFLAG = '¯ This is a flag that this file was created by PATPAS ò';
|     MAXNUMBEROFSTATEMENTS = 100; ¯ This is the number of statements
|               we allow in InitProcedure's before seperating them up ò
| 
| type
|     symbol = packed array [1..SYMBOLSIZE] of char;
| 
|     TheirStates = ( Initializing,
|                     GlobalConst,
|                                  DefSymbolSize, DefSymbol,
|                                  GlobalType, GlobalVar, GlobalInit,
|                     InSymbol,
|                     LocalConst, LocalType, LocalVar, LocalInit,
|                     Action, Main,
|                     Finished );
| 
| var
|     DoDebug,                        ¯ output Debugging code? ò
|     TerExists,                      ¯ does foo.TER exist? ò
|     HadError    : boolean;
| 
|     TTYout,
|     Us,
|     Ter,
|     Them    : text;
| 
|     TheirBuffer : packed array [1..BUFFERSIZE] of char;
| 
|     TheirState : TheirStates;
| 
|     FileName : packed array [1..16] of char;
| 
|     DebugTable : packed array [1..DEBUGMAX] of symbol; ¯ symbolic names ò
|     DebugLowest,                ¯ lowest entry in table used, or 0 ò
|     DebugHighest : integer;     ¯ highest entry in table used, or 1 ò
| 
|     LowerCaseLetters,
|     WhiteSpace : set of char;
| 
| 
| ¯ The following are the procedures that are system specific.
|     They will need to be changed to run on other systems.
|  ò
| 
| procedure InitProcedure;
| var
|     i,
|     retcode : integer;
| %include CMS
| begin
|     TheirState := Initializing;
| 
|     LowerCaseLetters := [ 'a', 'b', 'c', 'd', 'e', 'f',
|                     'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
|                     'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ];
|     WhiteSpace := [ ' ', chr(12), chr(9) ];
| 
|     DoDebug := TRUE;
| 
|     for i := 1 to DEBUGMAX do
|         DebugTable[i] := ' ';
| 
|     ¯ open the terminal for error output ò
|     cms( 'FILEDEF STDERR TERMINAL', retcode );  ¯ bind STDERR to tty ò
|     rewrite( TTYout, 'DDNAME=STDERR' );
| end;
| 
| 
| procedure GetFileName;
| var
|     i : integer;
| begin
|     i := 1;
|     token( i, parms, filename );
| end;
| 
| 
| procedure OpenFiles;
| var
|     BaseName,
|     TabName,
|     STabName,
|     PatpasName,
|     SPatpasName,
|     TerName,
|     STerName,
|     PascalName,
|     SPascalName  :  string(30);
| 
|     Temporary : packed array [1..200] of char;
| 
| function DoesExist( const Name : string ) : boolean;
| 
| %include CMS
| 
| var
|     retcode : integer;
| begin
|     cms( 'SET CMSTYPE HT', retcode );   ¯ turn off error messages ò
| 
|     cms( 'STATE ' ×× Name, retcode );   ¯ does file exist? ò
| 
|     if retcode = 0 then
|         DoesExist := TRUE
|     else
|         DoesExist := FALSE;
| 
|     cms( 'SET CMSTYPE RT', retcode );   ¯ turn back on error messages ò
| end;
| 
| 
| begin
|     BaseName := trim(ltrim(compress(str(FileName))));
|     TabName := BaseName ×× '.TAB.*';
|     STabName := BaseName ×× ' TAB *';
|     PatpasName := BaseName ×× '.PATPAS.*';
|     SPatpasName := BaseName ×× ' PATPAS *';
|     TerName := BaseName ×× '.TER.*';
|     STerName := BaseName ×× ' TER *';
|     PascalName := BaseName ×× '.PASCAL.A';
|     SPascalName := BaseName ×× ' PASCAL A';
| 
|     if DoesExist(STabName) then begin
| 
|         reset( Us, 'NAME=' ×× TabName );
| 
|         if DoesExist(SPatpasName) then
|             reset( Them, 'NAME=' ×× PatpasName )
|         else
|             TheirState := Finished;
| 
|         TerExists := DoesExist(STerName);
|         if TerExists then
|             reset( Ter, 'NAME=' ×× TerName );
| 
|         if DoesExist(SPascalName) then begin
|             reset( output, 'NAME=' ×× PascalName );
|             readln( output, temporary );
|             if temporary <> OURFLAG then begin
|                 writeln( TTYout, SPascalName, ' already exists, and does' );
|                 writeln( TTYout, 'not appear to have been created by PATPAS.' );
|                 writeln( TTYout, 'No action taken.' );
|                 HadError := TRUE;
|             end
|         end;
| 
|         if not HadError then
|             rewrite( output, 'NAME=' ×× PascalName );
| 
|     end else begin
|         writeln( TTYout, STabName, ' does not exist.  No action taken.' );
|         HadError := TRUE;
|     end;
| end;
| 
| 
| procedure SetReturnCode( I : integer );
| ¯ In CMS, error code is propagatable back to caller, so let
|     them know...
| ò
| begin
|     retcode(i);     ¯ CMS Pascal/VS primitive ò
| end;
| 
| 
| ¯ IsEqual - does a case independant compare of the
|             two symbols
| ò
| function IsEqual( Field1, Field2 : symbol ) : boolean;
| var
|     i : integer;
| 
| function UpperCase( Ch : char ) : char;
| begin
|     if ch in LowerCaseLetters then
|         UpperCase := chr( ord(ch) + ord('A')-ord('a') )
|     else
|         UpperCase := Ch;
| end;
| 
| 
| begin
|     IsEqual := TRUE;
|     if Field1 <> Field2 then begin
|         for i := 1 to SYMBOLSIZE do begin
|             if Field1[i] <> Field2[i] then
|                 if UpperCase(Field1[i]) <> UpperCase(Field2[i]) then
|                     IsEqual := FALSE;
|         end;
|     end;
| end;
| 
| function GetOurNumber : integer;
| var
|     Found : boolean;
|     Result : integer;
| begin
|     Found := FALSE;
| 
|     while not ( Found or eof(Us) ) do
|         if eoln(Us) then
|             readln(Us)
|         else if Us@ in WhiteSpace then
|             get(Us)
|         else begin
|             read( Us, Result );
|             Found := True
|         end;
| 
|     if found then
|         GetOurNumber := Result
|     else
|         GetOurNumber := -1;
| end;
| 
| 
| function GetSymbol( var AFile : text ) : symbol;
| var
|     Quoting,                    ¯ true if unbalanced single quote ò
|     Found : boolean;
|     Temp : integer;
|     Result : symbol;
| begin
|     Found := FALSE;
| 
|     while not ( Found or eof(AFile) ) do
|         if eoln(AFile) then
|             readln(AFile)
|         else if AFile@ = ' ' then
|             get(AFile)
|         else begin
|             Found := TRUE;
|             Temp := 1;
|             Quoting := FALSE;
|             while ( Temp <= SYMBOLSIZE ) and
|                   ((AFile@ <> ' ') or (Quoting)) and
|                    not eof(AFile) and
|                    not eoln(AFile) do begin
|                 Result[Temp] := AFile@;
|                 if AFile@ = '''' then
|                     Quoting := not Quoting;
|                 get(AFile);
|                 Temp := Temp+1;
|             end;
|             for Temp := Temp to SYMBOLSIZE do
|                 Result[Temp] := ' ';
|         end;
| 
|     if found then
|         GetSymbol := Result
|     else
|         GetSymbol := '-1';
| end;
| 
| 
| procedure WriteSymbol( OurSymbol : symbol );
| var
|     k, j : integer;
| begin
|     k := 0;
|     for j := SYMBOLSIZE downto 1 do
|         if OurSymbol[j] <> ' ' then
|             k := max( j, k );
| 
|     if (k <> 0) then
|         write(OurSymbol:k);
| end;
| 
| 
| procedure TheirError;
| begin
|     writeln( TTYout, 'The following line was not understood:' );
|     writeln( TTYout, TheirBuffer );
| 
|     HadError := TRUE;
| end;
| 
| 
| 
| procedure GetTheirLine;
| var
|     CtlRecord : boolean;
|     Index : integer;
| 
| procedure SetTheirState;
| var
|     Result1, Result2 : symbol;
| 
| function GetTheirSymbol : symbol;
| var
|     ResultIndex : integer;
|     Result : symbol;
| begin ¯ GetTheirSymbol ò
| 
|     Result := '';
| 
|     while ( Index <= BufferSize ) and ( TheirBuffer[Index] = ' ' ) do
|         Index := Index + 1;
| 
|     ResultIndex := 1;
| 
|     while ( ResultIndex <= SymbolSize ) and
|           ( TheirBuffer[Index] <> ' ' ) do begin
|         Result[Resultindex] := TheirBuffer[Index];
|         ResultIndex := ResultIndex+1;
|         Index := Index+1;
|     end;
| 
|     GetTheirSymbol := Result;
| end; ¯ GetTheirSymbol ò
| 
| 
| 
| begin ¯ SetTheirState ò
|     Index := 3;
| 
|     Result1 := GetTheirSymbol;
| 
|     if IsEqual( Result1,'GLOBAL' ) or IsEqual( Result1,'LOCAL' ) then
|         Result2 := GetTheirSymbol;
| 
|     if IsEqual( Result1, 'GLOBAL') then begin
|         if IsEqual( Result2, 'CONST') then TheirState := GlobalConst
|         else if IsEqual( Result2, 'TYPE') then TheirState := GlobalType
|         else if IsEqual( Result2, 'VAR') then TheirState := GlobalVar
|         else if IsEqual( Result2, 'INIT') then TheirState := GlobalInit
|         else TheirError
|     end else if IsEqual( Result1, 'SYMBOLSIZE') then TheirState := DefSymbolSize
|     else if IsEqual( Result1, 'SYMBOL') then TheirState := DefSymbol
|     else if IsEqual( Result1, 'INSYMBOL') then TheirState := InSymbol
|     else if IsEqual( Result1, 'LOCAL') then begin
|         if IsEqual( Result2, 'CONST') then TheirState := LocalConst
|         else if IsEqual( Result2, 'TYPE') then TheirState := LocalType
|         else if IsEqual( Result2, 'VAR') then TheirState := LocalVar
|         else if IsEqual( Result2, 'INIT') then TheirState := LocalInit
|         else TheirError
|     end else if IsEqual( Result1, 'ACTIONS') then TheirState := Action
|     else if IsEqual( Result1, 'MAIN') then TheirState := Main
|     else TheirError;
| end; ¯ SetTheirState ò
| 
| 
| begin ¯ GetTheirLine ò
| 
|     if eof( Them ) then
|         TheirState := Finished
|     else
|         repeat begin
|             readln( Them, TheirBuffer );
|             CtlRecord := (TheirBuffer[1] = '%') and (TheirBuffer[2] = '%');
|             if CtlRecord then
|                 SetTheirState;
|         end until (not CtlRecord) or eof(Them);
| 
|     if CtlRecord then
|         TheirState := Finished;
| end; ¯ GetTheirLine ò
| 
| 
| procedure InitTheirFIle;
| begin
|     while TheirState = Initializing do
|         GetTheirLine
| end;
| 
| procedure DoTheir( DesiredState : TheirStates );
| begin
|     while TheirState = DesiredState do begin
|         writeln( TheirBuffer );
|         GetTheirLine
|     end;
| end;
| 
| 
| procedure DoOurFlag;
| begin
|     writeln( OURFLAG )      ¯ Try to prevent overwriting a pascal file ò
| end;
| 
| 
| procedure DoOurGlobalConsts;
| var
|     Equal,
|     Name : symbol;
|     NameValue,
|     Temp : integer;
| begin
|     write( 'program ' );    ¯ write program heading ò
| 
|     for Temp := 1 to 16 do
|         if Filename[Temp] <> ' ' then
|             write( FileName[Temp] );
| 
|     writeln( ';' );
|     writeln( '¯     Global constants used by the parse  ò');
|     writeln;
|     writeln( 'const' );
|     writeln;
|     writeln( '    ContCode = ', GetOurNumber,
|              '; ¯ Code for CONTINUE in SymList ò' );
|     writeln( '    ElseCode = ', GetOurNumber,
|              '; ¯ Code for ELSE in SymList ò' );
|     writeln( '    ErrorCode = ', GetOurNumber,
|              '; ¯ Code for ERROR in Action list ò' );
|     writeln( '    ScanCode = ', GetOurNumber,
|              '; ¯ Code for SCAN in SymList ò' );
|     writeln;
|     writeln( '    MaxAction = ', GetOurNumber,
|              '; ¯ Max code used in Action ò' );
|     writeln( '    MaxNonTerm = ', GetOurNumber,
|              '; ¯ Number of symbols ò' );
|     writeln( '    MaxPop = ', GetOurNumber,
|              '; ¯ Maximum number of pops ò' );
|     writeln( '    MaxProd = ', GetOurNumber,
|              '; ¯ Number of productions ò' );
|     writeln( '    MaxStack = ', '100',
|              '; ¯ Depth of parse stack ò' );
|     writeln( '    MaxState = ', GetOurNumber,
|              '; ¯ Highest index of parser tables ò' );
|     writeln( '    MaxVoc = ', GetOurNumber,
|              '; ¯ Size of vocabulary ò' );
|     writeln;
| 
|     DebugHighest := 0;
|     DebugLowest := DEBUGMAX+1;
|     if TerExists then begin
|         while not eof(Ter) do begin
|             Name := GetSymbol(Ter);
|             Equal := GetSymbol(Ter);
|             readln( Ter, NameValue );
|             if (NameValue <= DEBUGMAX) and (NameValue > 0) then begin
|                 DebugTable[NameValue] := Name;
|                 DebugHighest := max( NameValue, DebugHighest );
|                 DebugLowest := min( NameValue, DebugLowest );
|             end;
| 
|             if NameValue <> -1 then begin
|                 write('    ');
|                 WriteSymbol(Name);
|                 writeln('  =  ', NameValue:1, ';');
|             end;
|         end;
|     end;
| 
|     DebugLowest := min(DebugHighest, DebugLowest);
|     if DoDebug then begin
|         writeln;
|         writeln;
|         writeln('    DEBUGMAX = ', DebugHighest:1, ';');
|         writeln('    DEBUGMIN = ', DebugLowest:1 , ';');
|         writeln('    DEBUGSIZE = 32;' );
|         writeln('    HIGHESTPRINTABLE = 256;' );
|     end;
| 
| 
|     if GetOurNumber <> -1 then begin
|         writeln( TTYout, 'Badly formed .TAB file.' );
|         HadError := TRUE;
|     end;
| end;
| 
| 
| 
| procedure DoOurSymbolSize;
| begin
|     writeln;
|     writeln( '    SYMBOLSIZE = 32;           ¯ size of User Symbol ò' );
| end;
| 
| 
| procedure DoOurGlobalTypes;
| var
|     Token : Symbol;
| begin
|     writeln;
|     writeln;
|     writeln( 'type' );
|     writeln;
|     writeln( '¯ Labels representing semantic actions ò' );
|     writeln( '    SemSet = (' );
|     writeln( '               ', 'NULL' );
|     Token := GetSymbol(Us);
|     while Token <> '-1' do begin
|         writeln( '                ,  ', Token );
|         Token := GetSymbol(Us);
|     end;
|     writeln( '             );' );
| 
| end;
| 
| 
| 
| procedure DoOurSymbol;
| begin
|     writeln;
|     writeln( '    symbol = packed array[1..SYMBOLSIZE] of char;' );
| end;
| 
| 
| procedure DoOurGlobalVars;
| begin
| writeln;
| writeln;
| writeln( 'var' );
| writeln;
| writeln( '    IntValue,             ¯ Value destined for IntStack ò' );
| writeln( '    Currentstate,         ¯ The state of the Parse machine ò' );
| writeln( '    SP,                   ¯ Stack Index ò' );
| writeln( '    Token : integer;      ¯ Code to scanner from parser ò'     );
| ¯ no IF around this variable - could be set by user program ò
| writeln( '    Debug,          ¯ Can be set TRUE to do debugging ò' );
| writeln( '    Match,          ¯ True if a matching transition found ò' );
| writeln( '    Parse,          ¯ True if parse needs to be continued ò' );
| writeln( '    Scan : boolean; ¯ True if next symbol needs be scanned ò');
| writeln( '    SymValue : symbol;    ¯ Value destined for SymStack ò' );
| writeln;
| writeln( '¯ Arrays used by the Parser ò' );
| writeln;
| writeln( '    Action : array [0 .. MaxState] of integer;' );
| writeln( '    SymList : array [0 .. MaxState] of integer;' );
| writeln( '    LHS : array [0 .. MaxProd] of integer;' );
| writeln( '    Pop : array [0 .. MaxProd] of integer;' );
| writeln( '    Semantics : array [0 .. Maxprod] of SemSet;' );
| writeln( '    PStack : array [0 .. MaxStack] of integer',
|          ';  ¯ Parse Stack ò' );
| if DoDebug then begin
| writeln( '    PATBlanks : packed array [1..50] of char;' );
| writeln( '    DebugTable : packed array [DEBUGMIN..DEBUGMAX]' );
| writeln( '                 of packed array [1..DEBUGSIZE] of char;' );
| writeln( '    Printables : set of char;' );
| end; ¯DoDebugò
| writeln( '    SymStack : array [0 .. MaxStack] of symbol',
|          ';  ¯ User symbol stack ò' );
| writeln( '    IntStack : array [0 .. MaxStack] of integer',
|          ';  ¯ User integer stack ò' );
| end;
| 
| 
| procedure DoOurGlobalInits;
| var
|     NumberOfStatements,
|     NumberOfInitProcedures,
|     Index : integer;
|     OurSymbol : symbol;
| 
| procedure Statement( var NumberOfStatements, NumberOfInitProcedures
|                             : integer );
| begin
|     NumberOfStatements := NumberOfStatements+1;
|     if NumberOfStatements > MAXNUMBEROFSTATEMENTS then begin
|         NumberOfStatements := 0;
|         if NumberOfInitProcedures <> 0 then
|             writeln('end;');
|         NumberOfInitProcedures := NumberOfInitProcedures+1;
|         writeln;
|         writeln;
|         writeln;
|         writeln('procedure InitProcedure', NumberOfInitProcedures:1, ';' );
|         writeln('begin');
|     end;
| end;
| 
| 
| 
| begin
|     NumberOfInitProcedures := 0;
|     NumberOfStatements := MAXNUMBEROFSTATEMENTS+1;
|     Statement(NumberOfStatements, NumberOfInitProcedures);
|     Index := GetOurNumber;
|     while Index <> -1 do begin
|         write( '    SymList[', Index:3, '] := ' );
|         OurSymbol := GetSymbol(Us);
|         if OurSymbol[1] = '''' then begin
|             write('ord(');
|             WriteSymbol(OurSymbol);
|             write(')');
|         end else
|             WriteSymbol(OurSymbol);
|         writeln( ';    Action[', Index:3, '] := ', GetOurNumber:6, ';' );
|         Statement(NumberOfStatements, NumberOfInitProcedures);
|         Index := GetOurNumber;
|     end;
|     writeln;
|     Statement(NumberOfStatements, NumberOfInitProcedures);
| 
|     Index := GetOurNumber;
|     while Index <> -1 do begin
| 
|         write  ( '    Pop[', Index:3, '] := ', GetOurNumber:2,
|                  ';   LHS[', Index:3, '] := ' );
|         WriteSymbol(GetSymbol(Us));
|         write  ( ';   Semantics[', Index:3, '] := ' );
|         WriteSymbol(GetSymbol(Us));
|         writeln( ';' );
| 
|         Statement(NumberOfStatements, NumberOfInitProcedures);
|         Index := GetOurNumber;
|     end;
| 
|     if DoDebug then begin
|         ¯ initialize the Debug Symbol table ò
|         writeln( '    PATBlanks := '' '';' );
|         for Index := DebugLowest to DebugHighest do begin
|             if DebugTable[Index] <> ' ' then begin
|                 write( '    DebugTable[', Index:1, '] :=  ''' );
|                 WriteSymbol(DebugTable[Index]);
|                 writeln( ''';' );
|                 Statement(NumberOfStatements, NumberOfInitProcedures);
|             end;
|         end;
|         writeln(
| '   Printables := [ '' '', ''!'', ''"'', ''#'', ''$'', ''%'', ''&'', '''''''','
| );      writeln(
| '                   ''('', '')'', ''*'', ''+'', '','', ''-'', ''.'', ''/'','
| );      writeln(
| '                   ''0'', ''1'', ''2'', ''3'', ''4'', ''5'', ''6'', ''7'','
| );      writeln(
| '                   ''8'', ''9'', '':'', '';'', ''<'', ''='', ''>'', ''?'','
| );      writeln(
| '                   ''@'', ''A'', ''B'', ''C'', ''D'', ''E'', ''F'', ''G'','
| );      writeln(
| '                   ''H'', ''I'', ''J'', ''K'', ''L'', ''M'', ''N'', ''O'','
| );      writeln(
| '                   ''P'', ''Q'', ''R'', ''S'', ''T'', ''U'', ''V'', ''W'','
| );      writeln(
| '                   ''X'', ''Y'', ''Z'', ''['', ''Ö'', '']'', ''^'', ''_'','
| );      writeln(
| '                   ''`'', ''a'', ''b'', ''c'', ''d'', ''e'', ''f'', ''g'','
| );      writeln(
| '                   ''h'', ''i'', ''j'', ''k'', ''l'', ''m'', ''n'', ''o'','
| );      writeln(
| '                   ''p'', ''q'', ''r'', ''s'', ''t'', ''u'', ''v'', ''w'','
| );      writeln(
| '                   ''x'', ''y'', ''z'', ''¯'', ''×'', ''ò'', ''~''     ];'
| );
| 
|     end; ¯DoDebugò
| 
| 
|     writeln( 'end;' );
| 
|     writeln;
|     writeln;
|     writeln;
|     writeln('procedure InitProcedure;');
|     writeln('begin');
| 
|     for Index := 1 to NumberOfInitProcedures do
|         writeln('    InitProcedure', Index:1, ';' );
| 
|     writeln('    Debug := FALSE;' );
|     writeln('end;');
| end;
| 
| 
| 
| procedure DoOurRoutines;
| begin
|     writeln;
|     writeln;
|     writeln(   'function GetIndex( Index : integer ) : integer;' );
|     writeln(   'begin' );
|     writeln(   '    if Index+sp-1 < MAXSTACK then' );
|     writeln(   '        GetIndex := Index+sp-1' );
|     writeln(   '    else' );
|     writeln(   '        GetIndex := MAXSTACK-1' );
|     writeln(   'end;' );
|     writeln;
|     writeln;
|     writeln(   'function GetInt( Index : integer ) : integer;' );
|     writeln(   'begin' );
|     writeln(   '    if Index+sp-1 < MAXSTACK then' );
|     writeln(   '        GetInt := IntStack[Index+sp-1]' );
|     writeln(   '    else' );
|     writeln(   '        GetInt := IntStack[MAXSTACK-1]' );
|     writeln(   'end;' );
|     writeln;
|     writeln;
|     writeln(   'function GetSym( Index : integer ) : symbol;' );
|     writeln(   'begin' );
|     writeln(   '    if Index+sp-1 < MAXSTACK then' );
|     writeln(   '        GetSym := SymStack[Index+sp-1]' );
|     writeln(   '    else' );
|     writeln(   '        GetSym := SymStack[MAXSTACK-1]' );
|     writeln(   'end;' );
| end;
| 
| 
| procedure DoOurLocalConsts;
| begin
| writeln( 'procedure LRParse ;' );
| writeln( '    ¯****************************************************ò' );
| writeln( '    ¯*                                                  *ò' );
| writeln( '    ¯*   laLR Parse                                     *ò' );
| writeln( '    ¯*                                                  *ò' );
| writeln( '    ¯*      This is the parser driver. It uses the      *ò' );
| writeln( '    ¯* the tables generated by PAT. The driver itself   *ò' );
| writeln( '    ¯* is language independent. The only portion        *ò' );
| writeln( '    ¯* that needs to be entered is the semantics as     *ò' );
| writeln( '    ¯* indicated.for more details on the parsing method *ò' );
| writeln( '    ¯* see the reference manual for PAT.                *ò' );
| writeln( '    ¯*                                                  *ò' );
| writeln( '    ¯*                                                  *ò' );
| writeln( '    ¯*   Global                                         *ò' );
| writeln( '    ¯*     in/out :  SP  stack pointer for parser       *ò' );
| writeln( '    ¯*               CurrentState                       *ò' );
| writeln( '    ¯*               Scan indicates if next symbol      *ò' );
| writeln( '    ¯*                    needs to be scanned           *ò' );
| writeln( '    ¯*               Parse  true while parsing          *ò' );
| writeln( '    ¯*               Token  for making transition       *ò' );
| writeln( '    ¯*               Action     parser table            *ò' );
| writeln( '    ¯*               SymList    parser table            *ò' );
| writeln( '    ¯*               Pop        parser table            *ò' );
| writeln( '    ¯*               LHS        parser table            *ò' );
| writeln( '    ¯*               Semantics  parser table            *ò' );
| writeln( '    ¯*                                                  *ò' );
| writeln( '    ¯*  Functions used                                  *ò' );
| writeln( '    ¯*                                                  *ò' );
| writeln( '    ¯*     InSymbol  scans the next symbol and must     *ò' );
| writeln( '    ¯*               token to the required code         *ò' );
| writeln( '    ¯*                                                  *ò' );
| writeln( '    ¯*     Error     This routine does error recovery   *ò' );
| writeln( '    ¯*         ##### user needs to write this as reqd   *ò' );
| writeln( '    ¯*                                                  *ò' );
| writeln( '    ¯*     #### other user defined semantic routines    *ò' );
| writeln( '    ¯****************************************************ò' );
| writeln;
| writeln;
| end;
| 
| 
| procedure DoOurLocalTypes;
| begin
| end;
| 
| 
| procedure DoOurLocalVars;
| begin
| writeln( 'var' );
| writeln;
| writeln( '    j : integer ;       ¯ Local control VAR              ò' );
| writeln( '    Act : integer ;     ¯ Action from Action array       ò' );
| writeln( '    Tran : integer ;    ¯ Transition code from SymList ò' );
| writeln( '    Next : integer ;    ¯ saves the Next token ò' );
| writeln;
| writeln;
| 
| end;
| 
| 
| procedure DoOurLocalInits;
| begin
| if DoDebug then begin
| writeln(
| 'procedure TokenWrite( Token : integer );' );
| writeln(
| '¯ Write out the Token as nicely as possible... ò' );
| writeln(
| 'var' );
| writeln(
| '   i,' );
| writeln(
| '   j : integer; ' );
| writeln(
| 'begin' );
| writeln(
| '   if (Token >= DEBUGMIN) and (Token <= DEBUGMAX) then begin' );
| writeln(
| '       if DebugTable[Token] = '' '' then begin' );
| writeln(
| '           if Token <= HighestPrintables then begin' );
| writeln(
| '               if chr(Token) in Printables then' );
| writeln(
| '                   write('''''''', chr(Token), '''''''')' );
| writeln(
| '               else' );
| writeln(
| '                   write(Token:1)' );
| writeln(
| '           end else' );
| writeln(
| '               write(Token:1)' );
| writeln(
| '       end else begin' );
| writeln(
| '           j := 0;' );
| writeln(
| '           for i := DEBUGSIZE downto 1 do' );
| writeln(
| '               if DebugTable[Token] <> '' '' then' );
| writeln(
| '                   j := max( i, j );' );
| writeln(
| '           write(DebugTable[Token]:j);' );
| writeln(
| '       end;' );
| writeln(
| '   end else begin' );
| writeln(
| '       if Token = ContCode then' );
| writeln(
| '           write(''ContCode'')' );
| writeln(
| '       else if Token = ElseCode then' );
| writeln(
| '           write(''ElseCode'')' );
| writeln(
| '       else if Token = ErrorCode then' );
| writeln(
| '           write(''ErrorCode'')' );
| writeln(
| '       else if Token = ScanCode then' );
| writeln(
| '           write(''ScanCode'')' );
| writeln(
| '       else begin' );
| writeln(
| '           if (Token <= HighestPrintables) and (Token >= 0) then begin' );
| writeln(
| '               if chr(Token) in Printables then begin' );
| writeln(
| '                   write('''''''', chr(Token), '''''''')' );
| writeln(
| '               end else' );
| writeln(
| '                   write(Token:1)' );
| writeln(
| '           end else' );
| writeln(
| '               write(Token:1);' );
| writeln(
| '       end;' );
| writeln(
| '   end;' );
| writeln(
| 'end;' );
| writeln;
| writeln;
| writeln;
| writeln(
| '¯ DebugOut - do what is needed for debug ò' );
| writeln(
| 'procedure DebugOut;' );
| writeln(
| 'begin' );
| writeln(
| '   write  (PATBlanks:min(sp, 50));' );
| writeln(
| '   TokenWrite(Token);' );
| writeln(
| '   writeln;' );
| writeln(
| 'end;' );
| end; ¯DoDebugò
| writeln( 'begin' );
| writeln( '     ¯ LR Parse        ò' );
| writeln;
| writeln;
| writeln( '    sp := 0;' );
| writeln( '    InSymbol ;' );
| if DoDebug then begin
| writeln( '    if Debug then' );
| writeln( '        DebugOut;' );
| end; ¯DoDebugò
| writeln( '    CurrentState := 0;' );
| writeln( '    Scan := TRUE ;' );
| writeln( '    Parse := TRUE ;' );
| writeln( '    Match := FALSE ;' );
| writeln;
| writeln( '    ¯************************************************ò' );
| writeln( '    ¯*  User Defined Initialization for Semantics   *ò' );
| writeln( '    ¯************************************************ò' );
| writeln;
| end;
| 
| 
| 
| procedure DoOurBeforeActions;
| begin
| writeln( '    repeat' );
| writeln( '       ¯ Parse loopò' );
| writeln( '        j := CurrentState;' );
| writeln( '        repeat' );
| writeln( '                          ¯ Search for Matching Token ò' );
| writeln( '            Match := FALSE;' );
| writeln( '            Tran := symlist [j] ;' );
| writeln( '            if (Tran=Token) OR (Tran=ElseCode) then begin' );
| writeln( '                                            ¯ Match ò' );
| writeln( '                Match := TRUE;' );
| writeln( '                Act := Action[j] ;' );
| writeln( '                if Act <> ErrorCode then begin' );
| writeln( '                                            ¯ Read or Reduce ò' );
| writeln( '  ');¯              if Act > -ScanCode then begin' );     ò
| writeln( '                                            ¯ Process ò' );
| writeln( '                    PStack[sp] := CurrentState;' );
| writeln;
| writeln( '                    IntStack[sp] := IntValue;' );
| writeln( '                    SymStack[sp] := SymValue;' );
| writeln;
| writeln;
| writeln( '  ' );         ¯    endò¯ Process ò¯;' );ò
| writeln( '                    if Act >=0 then begin' );
| writeln( '                                            ¯ Read ò' );
| writeln( '                        CurrentState :=Act ;' );
| writeln;
| writeln( '                        if sp >= MaxStack then begin' );
| writeln( '                                           ¯ Overflow ò' );
| writeln( '                            writeln(Output,',
|          '''Parse Stack Overflow'');' );
| writeln( '                            Parse := FALSE ;' );
| writeln( '                        end ¯ Overflowò else' );
| writeln( '                            sp := sp+1;' );
| writeln( '                        if Scan then begin' );
| writeln( '                            InSymbol;' );
| if DoDebug then begin
| writeln( '                            if Debug then' );
| writeln( '                                DebugOut; ' );
| end; ¯DoDebugò
| writeln( '                        end else begin' );
| writeln( '                                   ¯ NO Scanò' );
| writeln( '                            Scan := TRUE;' );
| writeln( '                            Token := Next ;' );
| writeln( '                        end ¯ NO Scan ò ;' );
| writeln( '                    end ¯ READ ò else begin' );
| writeln( '                                   ¯ Reduce ò' );
| writeln( '                        if Act <= -ScanCode then begin' );
| writeln( '                                   ¯ Set NO Scan ò' );
| writeln( '                            Act := Act + ScanCode ;' );
| writeln( '                            Scan := FALSE ;' );
| writeln( '                            sp := sp-1 ',
|          '; ¯One extra Pop for' );
| writeln( '                                       ',
|          '  NO Scan Reductionsò' );
| writeln( '                            Next := Token ; ¯ Save it ò' );
| writeln( '                        end ;' );
| writeln( '                                          ¯ Set NO Scan ò' );
| writeln( '                        Act := - Act ; ¯ Make it positiveò' );
| writeln( '                        sp := sp - Pop[Act] ; ¯ Pop stackò' );
| writeln( '                        CurrentState := PStack[sp];' );
| writeln( '                        Token := LHS[Act] ;' );
| if DoDebug then begin
| writeln( '                        if Debug then' );
| writeln( '                            DebugOut;' );
| end; ¯DoDebugò
| writeln;
| writeln( '       ¯ Semantic Action for each reduction ò' );
| writeln( '       ¯------------------------------------ò' );
| writeln;
| writeln;
| writeln;
| writeln( '                        case Semantics[Act] of' );
| writeln;
| end;
| 
| 
| 
| 
| procedure DoOurAfterActions;
| begin
| writeln;
| writeln( '                        end ¯ case ò;' );
| writeln;
| writeln( '                    end ¯ Reduce ò ;' );
| writeln( '                end ¯ Read or Reduceò else begin' );
| writeln( '                                             ¯ Error ò' );
| writeln( '                    writeln(Output,''Error'');' );
| writeln( '                    Parse := FALSE;' );
| writeln( '                end  ¯ Error ò ;' );
| writeln( '            end ¯ Match ò else' );
| writeln( '                if Tran = ContCode then' );
| writeln( '                    j := Action[j]' );
| writeln( '                else' );
| writeln( '                    j := j+1;' );
| writeln;
| writeln( '        until   Match ;' );
| writeln;
| writeln( '    until not Parse ;' );
| writeln;
| writeln( 'end   ¯ LR Parse ò ;' );
| writeln;
| writeln;
| writeln;
| writeln( '   ¯ M A I N ò' );
| end;
| 
| 
| procedure DoSymbolSize;
| begin
|     if TheirState = DefSymbolSize then
|         DoTheir(DefSymbolSize)
|     else
|         DoOurSymbolSize;
| end;
| 
| 
| procedure DoSymbol;
| begin
|     if TheirState = DefSymbol then
|         DoTheir(DefSymbol)
|     else
|         DoOurSymbol;
| end;
| 
| 
| 
| begin
| 
|     InitProcedure;
| 
|     GetFileName;
|     OpenFiles;
| 
|     if not HadError then begin
| 
|         InitTheirFile;
|         DoOurFlag;
| 
|         DoOurGlobalConsts;
|         DoTheir(GlobalConst);
| 
|         DoSymbolSize;
| 
|         DoOurGlobalTypes;
| 
|         DoSymbol;
| 
|         DoTheir(GlobalType);
|         DoOurGlobalVars;
|         DoTheir(GlobalVar);
|         DoOurGlobalInits;
|         DoTheir(GlobalInit);
| 
|         DoOurRoutines;
| 
|         DoTheir(InSymbol);
| 
|         DoOurLocalConsts;
|         DoTheir(LocalConst);
|         DoOurLocalTypes;
|         DoTheir(LocalType);
|         DoOurLocalVars;
|         DoTheir(LocalVar);
|         DoOurLocalInits;
|         DoTheir(LocalInit);
| 
|         DoOurBeforeActions;
| 
|         DoTheir(Action);
| 
|         DoOurAfterActions;
| 
|         DoTheir(Main);
|     end;
| 
|     if HadError then
|         SetReturnCode(1);
| 
| end.
> Member PCROSS
| PROGRAM pcross(input, output) ;
| (*$N+       ***********
| PCROSS is a cross-referencing program for PASCAL source files,
| useful also to reformat programs (indentation, upper-lower case)
| and to find omitted or excessive BEGINS and ENDS.
| 
| comments, gripes and bugs to A.ARMANDO
| 
| subtopics:
|         INPUT AND OUTPUT
|         HOW TO USE IT
|         SWITCHES
|         READING THE OUTPUT
| <INPUT AND OUTPUT>
| INPUT:
| -----
| through the file OLDSOURCE, a PASCAL source program file.
| 
| OUTPUT:
| ------
| through NEWSOURCE:
|         a copy of your input file, unnumbered, prettyprinted
|         (proper indentation according to the statement nesting,
|          newline on standard places in the program, management of upper
|          and lower case according to the list of reserved words, etc.)
| 
| and trough  CROSSLIST:
|         (a) a prettyprinted version of the program, showing in the left
|             margin the relations between BEGIN..END pairs,THEN..ELSE
|             pairs, etc.
|         (b) a cross reference of all the identifiers
|         (c) a report of procedure and function declaration nesting.
| 
| By default, PCROSS will change all reserved words and strings to upper
| case, comments and everything else to lower case. There are switches
| available to change this condition.
| <HOW TO USE IT>
| You can:
|         (a) use the /CREF switch when @EXECUTEing your program
|              or calling @PASCAL, or
|         (b) call it directly by typing @PCROSS.
| 
| In the first case, PCROSS will be called immediately after compilation;
|     You will have to type the file names, though. We are working to fix
|     that detail soon. Two sample calls are:
| 
|         @pcross                         AND     @exec myprog/cref
|         OLDSOURCE= myprog.pas/nocross             (*COMPILER STUFF HERE*)
|         NEWSOURCE= myprog.pas                   OLDSOURCE= myprog.pas
|         CROSSLIST=                              NEWSOURCE=
|                                                 CROSSLIST=
| 
| The left one calls it directly. The effect is the prettyprinting of the
| program file itself. The right one is a call through the compiler, which
| will use the default options.
| 
| The program parameters all have dafault values, but they can be modified
| if desired, by the use of switches. See the subtopic SWITCHES.
| See the subtopic SWITCHES.
| <SWITCHES>
|                                         Brackets indicate optional.
|                                         <n> stands for an integer number.
|                                         <L> stands for a letter.
| 
|    Switch          Meaning                                      Default.
| 
|         FILES.
|                  <n> is the sum of:
|                        1   source program listing
|                        2   listing of identifiers
|                        4   listing of proc-func
|                            declaration nesting.
|                        8   listing of proc-func call nesting.
| 
|         PAGE AND LINE FORMAT
|                 margin every fifth line                        on
| 
|         STATEMENT FORMAT
|                   begin..end block is indented n spaces further.
|                 if it is there, the block will not be indented,
|                   but the begin and end statements will be
|                   exdented n spaces.                           0
|                  after begin, end, then, else, repeat, etc.)   off
|                  comment from old standards to
|                  '('-'*' and '*'-')'                           on
| 
|         UPPER AND LOWER CASE
|                        note: the possible values for <l> are:
|                                u means upper case
|                                l means lower case.
| 
| <READING THE OUTPUT>
| 
| The cross-reference file CROSSLIST contains 4 parts:
| 
| 1. THE PROGRAM LISTING:
|         the letters and numbers in the left margin indicate the presence
|         of reserved words which have to match. (BEGIN-END, etc.) The two
|         words that match accorde with the scope rules will have the
|         same number. The first one (e. g., BEGIN) will appear at left, and
|         the second one (e.g., END) at right, inside the margin. The meaning
|         of the letters is:
|                 B  Begin        E end
|                 I  If           T  Then         S Else
|                 L  Loop         X  Exit         E End
|                 C  Case         E  End
|                 R  Repeat       U  Until
| 
| 2. THE CROSS REFERENCE LISTING OF IDENTIFIERS:
|         It is ordered alphabetically. For each identifier it contains:
|             a. A 'P' or 'F' if it is a procedure or function, respectively.
|             b. The name of the identifier, up to 10 symbols.
|             c. The line numbers in which it occur. Those lines in which
|                   it is declared are marked with a D; those in which it
|                   occurs more than once are marked with an M (Multiple).
| 
| 3. THE NESTING OF PROCEDURE-FUNCTION DECLARATION:
|         It describes the static links. The scope is shown by indentation.
|         Each line describes a procedure or function and contains:
|             a. The name.
|             b. an (M), (P) or (F) if it is the main program, a procedure
|                   or a function, respectively.
|             c. If there are more than one procedure-function with the same
|                   name (in different scopes, which is perfectly valid, but
|                   a horrible thing to do), a D  (for DOUBLE) appears next,
|                   and the rest of the information in this and the next part
|                   of the listing contains data on both (or all of them, if
|                   there are more than one.).
|             d. If it is an external procedure, an E will appear next.
|             e. The line number where the header appeared.
|             f. The line number of the BEGIN statement.
|             g. The line number of the END statement.
| 
| 4. THE NESTING OF PROCEDURE-FUNCTION CALLS:
|         It describes the dynamic links. Calling depth is indicated by
|         indenting. The format of each line is the same as in the previous
|         report, except for the following:
|             a. Lines are numbered.
|             b. A procedure can be called from more than one place. To avoid
|                 repeating the list of proc-funcs called by it,an asterisk
|                 is printed after the name to indicate that it has already
|                 been 'described'. Instead of the line numbers for its
|                 appearence in the program, that for its appearence in this
|                 part of the listing is given, so that you can refer to it.
| *************)
| 
| 
| 
| (******************************************************************************)
| 
| 
| 
| (*$T-,R100   *)
| (*PROGRAM WHICH CREATES A CROSS REFERENCE LISTING WITH SIMULTANEOUS
|  FORMATTING OF A PASCAL PROGRAM.       WRITTEN BY MANUEL MALL.*)
| 
| 
| 
| 
| (*          INDEX           *)
| 
| 
| 
| (**) (*DECLARATIONS*)
| (**)     (*INITPROCEDURES*)
| (**)     (*CHECKOPTIONS[*) (*SETSWITCH*)
| (**)     (*PAGE AND LINE CONTROL*) (*HEADER*) (*NEWPAGE*) (*NEWLINE*)
| (**)     (*BLOCK[*) (*OUTPUT PROCEDURES:*) (*ERROR*) (*WRITELINE[*) (*USETABS*)
| (*]*) (*SETLASTSPACES*)
| (**)        (*INPUT PROCEDURES:*) (*INSYMBOL[*) (*READBUFFER*)
| (**)            (*RESWORD*) (*FINDNAME*) (*PARENTHESE*)
| (**)            (*DOCOMMENT*) (*]INSYMBOL*)
| (**)        (*"PARSING" PROCEDURES:*) (*RECDEF[*) (*CASEDEF*) (*PARENTHESE*) (*]
| *)
| (**)        (*STATEMENT[*) (*AND ITS PARTS*) (*]*)
| (**)     (*]BLOCK*)
| (**)     (*PRINT_XREF_LIST[*) (*CHECKPAGE*) (*WRITEPROCNAME*) (*WRITELINENR*) (*
| DUMPCALL*)
| (**)     (*]PRINT_XREF_LIST*)
| (**) (*MAIN PROGRAM*)
| (*DECLARATIONS*)
| 
|     (**********************************************************************
|      *
|      *
|      *       PROGRAM WHICH CREATES A CROSS REFERENCE LISTING
|      *       AND A NEW, REFORMATTED VERSION OF A PASCAL PROGRAM.
|      *
|      *       INPUT:  PASCAL SOURCE FILE.
|      *       OUTPUT: NEW REFORMATTED SOURCE FILE AND
|      *               CROSS-REFERENCE LISTING.
|      *
|      *       AUTHOR: MANUEL MALL (1974).
|      *
|      *       MODIFIED AT STANFORD UNIVERSITY BY LARRY PAULSON.
|      *                       + NOT AS MANY FORCED NEWLINES.
|      *                       + THE REPORT ON PROCEDURE CALLS WAS CANCELLED.
|      *
|      *       MODIFIED AT STANFORD UNIVERSITY BY ARMANDO R. RODRIGUEZ. 24-MAR-78.
|      *                       + A NEW SET OF SWITCH OPTIONS.
|      *                       + SOME NEW ERRORS ARE REPORTED.
|      *
|      *       SEE THE PROCEDURE CHECKOPTIONS FOR THE AVAILABLE SWITCHES.
|      *
|      *       MODIFIED AT STANFORD UNIVERSITY BY ARMANDO R. RODRIGUEZ. 6-JUL-88.
|      *               + ACCEPT COMMENTS BETWEEN '%' AND BACKLASH  AND BETWEEN '/*
| ' AND '*/'.
|      *               + MARK 'P' OR 'F' IN FRONT OF THE PROC-FUNC NAMES.
|      *               + MARK 'D' FOR DECLARATIONS AND 'M' FOR MULTIPLE OCCURRENCE
| S.
|      *               + SWITCH CLEAN/NOCLEAN TO STANDARIZE COMMENTS.
|      *               + LISTING OF PROC-FUNC CALL NESTING.
|      *               + REPORT THE LINE NUMBERS OF BEGIN AND END OF BODY OF PROCE
| DURES.
|      *          THINGS TO BE FIXED, OR DOCUMENTED:
|      *                  + IF THERE ARE TWO PROCS WITH ONE NAME, IT MIXES THEM.
|      *                  + IF A PROC NAME IS USED AS A VAR LATER, IT WILL BE SEEN
|      *                      AS A PROC FOR CALL-NESTING.
|      *                  + MAKE IT SMART ENOUGH TO AVOID CREATING STRUCTURES
|      *                      THAT WON'T BE USED, WHEN CROSS IS NOT 15.
|      *                  + MAKE IT RUN FASTER IN GENERAL. (TRY SPECIFICALLY I/O).
|      *
|      *
|      ***********************************************************************)
| 
| 
| 
| 
| "**********************************************************************
|  *                                                                    *
|  *                                                                    *
|  *   PCROSS is now  modified  to  run  under  the  Stanford  PASCAL   *
|  *   system.   The  various  option switches for the program should   *
|  *   now be specified in special comments of the following form:      *
|  *                                                                    *
|  *     (*%X+,F+,N-,R+,I-,C+,... other comments *)                     *
|  *                                                                    *
|  *     where:                                                         *
|  *                                                                    *
|  *     X+/- --> generate/do not generate a cross reference table,     *
|  *     F+/- --> generate/do not generate a reformatted listing,       *
|  *     N+/- --> allow/do not allow nesing of comments,                *
|  *     R+/- --> use upper/lower case in printing the reserved words , *
|  *     I+/- --> use upper/lower case in printing the identifieres,    *
|  *     C+/- --> use upper/lower case in printing comments.            *
|  *                                                                    *
|  *                                                                    *
|  *                                                                    *
|  *   PCROSS in general, and its reformating function in particular,   *
|  *   can be fairly time consuming and it  is  known  to  have  some   *
|  *   problems.                                                        *
|  *                                                                    *
|  *                                                                    *
|  *                                                                    *
|  *                               Sassan Hazeghi                       *
|  *                                                                    *
|  *                               Stanford Linear Accelerator Center   *
|  *                               P. O. Box 4349                       *
|  *                               Stanfor, CA 94305.                   *
|  *                                                                    *
|  *                               Jan. 22 1979.                        *
|  *                                                                    *
|  *                                                                    *
|  **********************************************************************"
| 
| 
| 
| 
| ##  LABEL  444;
| 
| CONST
|     version ='PCROSS: VERSION OF 4-aug-78 AT STANFORD UNIVERSITY';
|     maxline = 55;                         (*MAXIMUM NUMBER OF LINES PER PAGE, IG
| NORING HEADER*)
|     oldwidth =200;                        (*MAXIMUM LENGTH OF INPUT LINES*)
|     max_line_count = 7777(*B*);           (*LIMIT OF LINES/EDIT-PAGE*)
|     max_page_count = 77(*B*);             (*LIMIT OF EDIT-PAGES*)
|     (*          MAX_LINE_COUNT AND MAX_PAGE_COUNT SHOULD NOT NEED MORE THAN 18 B
| ITS TOTAL*)
|     ht = 9 (*11B*);                      (*ASCII HORIZONTAL TAB*)
|     ff = 12 (*14B*);                     (*ASCII FORM FEED*)
|     cr = 13 (*15B*);                     (*ASCII CARRIAGE RETURN*)
|     blanks = '          ';               (*FOR EDITING PURPOSES*)
|     dots = '  .   .   .   .   .   .   .   .   .   .';
|         (*'  .   .   .   .   .   .   .   .   .   .   .   .   .   .'; *)
| 
| TYPE
|     pack6 = PACKED ARRAY[1..6] OF char;
|     pack9 = PACKED ARRAY[1..9] OF char;
| 
|     errkinds = (begerrinblkstr,enderrinblkstr,missgenduntil,missgthen,missgof,
| missgexit,
|                 missgrpar,missgquote,linetoolong,missgmain,missgpoint);
|     lineptrty = @line;
|     listptrty = @list;
|     procstructy = @procstruc;
|     calledty = @called;
| 
|     linenrty = 0..max_line_count;
|     pagenrty = 0..max_page_count;
| 
|     symbol = (labelsy,constsy,typesy,varsy,programsy,             (*DECSYM*)
|               functionsy,proceduresy,initprocsy,                  (*PROSYM*)
|               endsy,untilsy,elsesy,thensy,exitsy,ofsy,dosy,eobsy, (*ENDSYMBOLS*)
|               beginsy,casesy,loopsy,repeatsy,ifsy,                (*BEGSYM*)
|               recordsy,forwardsy,gotosy,othersy,intconst,ident,strgconst,
| externsy,langsy,forsy,whilesy,
|               rbracket,rparent,semicolon,point,lparent,lbracket,colon,eqlsy,
| otherssy(*DELIMITER*),
| ###           letterup, letterlo, digit,quotech, dquotech, spacech,
| ###           dollarch, undsch, skipch ) ;
| 
|     line = PACKED RECORD
|                       (*DESCRIPTION OF THE LINE NUMBER*)
|                       linenr : linenrty;            (*LINE NUMBER*)
|                       pagenr : pagenrty;            (*PAGE NUMBER*)
|                       contlink : lineptrty;         (*NEXT LINE NUMBER RECORD*)
|                       declflag: char;               (*'D' IF DECLARATION, 'M' IF
|  MULTIPLE OCCURRENCE, BLANK OTHERWISE*)
|                   END;
| 
|     list = PACKED RECORD
|                       (*DESCRIPTION OF IDENTIFIERS*)
|                       name : alfa;                  (*NAME OF THE IDENTIFIER*)
|                       llink ,                       (*LEFT SUCCESSOR IN TREE*)
|                       rlink : listptrty;            (*RIGHT SUCCESSOR IN TREE*)
|                       first ,                       (*POINTER TO FIRST LINE NUMB
| ER RECORD*)
|                       last  : lineptrty;            (*POINTER TO LAST LINE NUMBE
| R RECORD*)
|                       externflag: char;             (*'E' IF EXTERNAL, 'F' IF FO
| RWARD,
|                                                      'D' IF TWO PROCS WITH THE S
| AME NAME, BLANK OTHERWISE*)
|                       profunflag : char;            (*'P' IF PROCEDURE NAME, 'F'
|  IF FUNCTION, BLANK OTHERWISE*)
|                       procdata: procstructy;
|                   END;
| 
| 
|     procstruc = PACKED RECORD
|                            (*DESCRIPTION OF THE PROCEDURE NESTING*)
|                            procname : listptrty;    (*POINTER TO THE APPROPRIATE
|  IDENTIFIER*)
|                            nextproc : procstructy;  (*POINTER TO THE NEXT ELEMEN
| T*)
|                            linenr,                  (*LINE NUMBER OF THE PROCEDU
| RE DEFINITION*)
|                            begline,                 (*LINE NUMBER OF THE BEGIN S
| TATEMENT*)
|                            endline: linenrty;       (*LINENUMBER OF THE END STAT
| EMENT*)
|                            pagenr ,                 (*PAGE NUMBER OF THE PROCEDU
| RE DEFINITION*)
|                            begpage,                 (*PAGE NUMBER OF THE BEGIN S
| TATEMENT*)
|                            endpage,                 (*PAGE NUMBER OF THE END STA
| TEMENT*)
|                            proclevel: pagenrty;     (*NESTING DEPTH OF THE PROCE
| DURE*)
|                            firstcall: calledty;     (*LIST OF PROCEDURES CALLED
| BY THIS ONE*)
|                            printed: boolean;        (*TO AVOID LOOPS IN THE CALL
| -NEST LIST*)
|                        END;
| 
|     called = PACKED RECORD
|                         nextcall : calledty;
|                         whom : procstructy;
|                     END;
| 
| VAR
|     (*                    INPUT CONTROL*)
|     i,                                    (*INDEX VARIABLE*)
|     bufflen,                              (*LENGTH OF THE CURRENT LINE IN THE IN
| PUT BUFFER*)
|     buffmark,                             (*LENGTH OF THE ALREADY PRINTED PART O
| F THE BUFFER*)
|     bufferptr,                            (*POINTER TO THE NEXT CHARACTER IN THE
|  BUFFER*)
|     syleng,                               (*LENGTH OF THE LAST READ IDENTIFIER O
| R LABEL*)
| 
|     (*                    NESTING AND MATCHING CONTROL*)
|     bmarknr,                              (*NUMBER FOR MARKING OF 'BEGIN', 'LOOP
| ' ETC.*)
|     emarknr,                              (*NUMBER FOR MARKING OF 'END', 'UNTIL'
|  ETC.*)
|     level,                                (*NESTING DEPTH OF THE CURRENT PROCEDU
| RE*)
|     variant_level,                        (*NESTING DEPTH OF VARIANTS*)
|     blocknr,                              (*COUNTS THE STATEMENTS 'BEGIN', 'CASE
| ', 'LOOP', 'REPEAT', 'IF'*)
|     errcount,                              (*COUNTS THE ERRORS ENCOUNTERED*)
| 
|     (*                    FORMATTING*)
|     maxch,                                (*PAGE WIDTH IN COLS FOR CROSSLIST*)
|     increment,                            (*LINE NUMBER INCREMENT*)
|     indentbegin,                          (*INDENTATION AFTER A BEGIN*)
|     begexd,                               (*EXDENTATION FOR BEGIN-END PAIRS*)
|     feed,                                 (*INDENTATION BY PROCEDURES AND BLOCKS
| *)
|     spaces,                               (*INDENTATION FOR THE FORMATTING*)
|     lastspaces,                           (*ONE-TIME OVERRIDING VALUE FOR SPACES
| *)
|     goodversion,                          (*keeps the value of the version optio
| n*)
|     pagecnt,                              (*COUNTS THE FILE PAGES*)
|     pagecnt2,                             (*COUNTS THE PRINT PAGES PER FILE PAGE
| *)
|     maxinc,                               (*GREATEST ALLOWABLE LINE NUMBER*)
|     reallincnt,                           (*COUNTS THE LINES  PER PRINT PAGE*)
|     linecnt : integer;                    (*COUNTS THE LINES  PER FILE PAGE*)
| 
|     rtime: ARRAY[0..3] OF integer;        (*CPU TIME REPORT*)
| 
|     procstrucdata : RECORD
|                         (*NEXT PROCEDURE TO BE PUT IN NESTING LIST*)
|                         exists : boolean;
|                         item : procstruc;
|                     END;
| 
|     flagger : ARRAY [-1..202] OF boolean; (*INDICATOR FOR UPPER AND LOWER CASE P
| RINTING*)
|     buffer  : ARRAY [-1..202] OF char;    (*INPUT BUFFER*)
|     (*          BUFFER HAS 2 EXTRA POSITIONS ON THE LEFT AND ONE ON THE RIGHT*)
| 
| ##  tabs: ARRAY [1..17] OF (*ascii*) char;   (*A STRING OF TABS FOR FORMATTING*)
| 
|     linenb : PACKED ARRAY [1..5] OF char; (*SOS-LINE NUMBER*)
| ## "date_text,time_text: alfa;"           (*HEADING DATE AND TIME*)
|     prog_name,                            (*NAME OF CURRENT PROGRAM*)
|     sy      : alfa;                       (*LAST SYMBOL READ*)
|     syty    : symbol;                     (*TYPE OF THE LAST SYMBOL READ*)
| 
|     (*                    SWITCHES*)
|     renewing,                             (*SET IF THE NEWLSOURCE FILE IS BEING
| WRITTEN*)
|     crossing,                             (*SET IF THE CROSSLIST FILE IS BEING W
| RITEN*)
|     refing,                               (*SET IF THE REFERENCES WILL BE PRINTE
| D*)
|     decnesting,                           (*SET IF THE PRO-FUNC DECLARATION LIST
| ING WILL BE PRINTED*)
|     callnesting,                          (*SET IF THE PRO-FUNC CALL NESTING WIL
| L BE PRINTED*)
|     doting,                               (*SET IF DOTED LINES WILL BE PRINTED A
| T LEFT MARGIN*)
|     forcing,                              (*SET IF THEN, ELSE, DO, REPEAT WILL F
| ORCE NEWLINE*)
| nestcomments,                             (*ACCEPT NESTED COMMENTS*)
|     cleaning,                             (*SET IF COMMENTS WILL BE STANDARIZD*)
|     rescase,                              (*SET IF RESERVED WORDS WILL UPSHIFT*)
|     nonrcase,                             (*SET IF NONRESERVED WORDS WILL UPSHIF
| T*)
|     comcase,                              (*SET IF COMMENTS WILL UPSHIFT*)
|     strcase,                              (*SET IF STRINGS WILL UPSHIFT*)
|     thendo,                               (*SET WHENEVER 'SPACES := SPACES+DOFEE
| D' IS EXECUTED*)
|     anyversion,                           (*set if goodversion > 9*)
| 
|     (*                    OTHER CONTROLS*)
|     fwddecl,                              (*SET TRUE BY BLOCK AFTER 'FORWARD', '
| EXTERN'*)
|     oldspaces,                            (*SET WHEN LASTSPACES SHOULD BE USED*)
|     eoline,                               (*SET AT END ON INPUT LINE*)
|     gotoinline,                           (*SET IF A HORRENDOUS GOTO STATEMENT I
| N THIS LINE*)
|     declaring,                            (*SET WHILE PARSING DECLARATIONS*)
|     programpresent,                       (*SET AFTER PROGRAM ENCOUNTERED*)
|     nobody,                               (*SET IF NO MAIN BODY IS FOUND*)
|     eob     : boolean;                    (*EOF-FLAG*)
| 
|                         (**)
|     ch,                                   (*LAST READ CHARACTER*)
|     bmarktext,                            (*CHARACTER FOR MARKING OF 'BEGIN' ETC
| .*)
|     emarktext: char;                      (*CHARACTER FOR MARKING 'END' ETC.*)
| 
|     (*                    SETS*)
|     delsy : ARRAY [CHAR"' '..'_'"] OF symbol; (*TYPE ARRAY FOR DELIMITER CHARS*)
| #   resnum: ARRAY[char] OF integer;       (*INDEX OF THE FIRST KEYWORD BEGINNING
|  WITH THE INDEXED LETTER*)
|     reslist : ARRAY [1..46] OF alfa;      (*LIST OF THE RESERVED WORDS*)
|     ressy   : ARRAY [1..46] OF symbol;    (*TYPE ARRAY OF THE RESERVED WORDS*)
| ## "alphanum,                             (*CHARACTERS FROM 0..9 AND A..Z*)
|     digits,                               (*CHARACTERS FROM 0..9*)
| ##  letters : SET OF char; "              (*CHARACTERS FROM A..Z*)
|     relevantsym,                          (*START SYMBOLS FOR STATEMENTS AND PRO
| CEDURES*)
|     prosym,                               (*ALL SYMBOLS WHICH BEGIN A PROC.*)
|     decsym,                               (*ALL SYMBOLS WHICH BEGIN DECLARATIONS
| *)
|     begsym,                               (*ALL SYMBOLS WHICH BEGIN COMPOUND STA
| TEMENTS*)
|     endsym  : SET OF symbol;              (*ALL SYMBOLS WHICH TERMINATE  STATEME
| NTS OR PROCEDURES*)
| 
|     (*                    POINTERS AND FILES*)
|     listptr, heapmark : listptrty;        (*POINTER INTO THE BINARY TREE OF THE
| IDENTIFIER*)
|     firstname : ARRAY [char    ] OF listptrty;    (*POINTER TO THE ROOTS OF THE
| TREE*)
|     procstrucf,                           (*POINTER TO THE FIRST ELEMENT OF THE
| PROCEDURE CALLS LIST*)
|     procstrucl : procstructy;             (*POINTER TO THE LAST ELEMENT OF THE P
| ROCEDURE CALLS LIST*)
|     workcall: calledty;
|     link_name,
|     new_name, cross_name: pack9;          (*USED TO GET THE PARAMETER FILES*)
|     old_dev,link_device,
|     new_dev,cross_dev:pack6;
|     old_prot,old_ppn,
|     new_prot,new_ppn,cross_prot,cross_ppn: integer;
|     programname,oldfileid,newfileid,crossfileid: alfa;
| ##  TTY,
|     OLDSOURCE,NEWSOURCE,CROSSLIST: text;  (*FILES PROCESSED BY THIS PROGRAM*)
| 
|     (*INITPROCEDURES*)
| 
| # PROCEDURE init0; "INITPROCEDURE;"
|     BEGIN (*CONSTANTS*)
|     eob := false;
|     maxch:=114;
| ##  increment:= "100" 1;
|     feed:=4;
|     indentbegin:=0;
| ##  nestcomments := true ;
| ##  cleaning := true ;
|     begexd:=0;
|     rescase:=true;
|     nonrcase:=false;
|     comcase:=false;
|     strcase:=true;
|     renewing:=true;
|     crossing:=true;
| ##  refing:= true (*false*);
| ##  decnesting:= true (*false*);
| ##  callnesting:=true  (*false*);
| ##  doting:=false (*true*);
|     nobody := false;
|     anyversion := false;
|     goodversion := -1;
|     new_name:='         ';
|     cross_name:='         ';
|     programname:='PCROSS    ';
|     oldfileid:='OLDSOURCE ';
|     newfileid:='NEWSOURCE ';
|     crossfileid:='CROSSLIST ';
|     END (*CONSTANTS*);
| 
| 
| #  procedure init1; "INITPROCEDURE;"
|     BEGIN (*RESERVED WORDS*)
|     resnum['A'] :=  1;    resnum['B'] :=  3;    resnum['C'] :=  4;
|     resnum['D'] :=  6;    resnum['E'] :=  9;    resnum['F'] := 13;
|     resnum['G'] := 18;    resnum['H'] := 19;    resnum['I'] := 19;
| ##  resnum[succ('I')] := 22;
|     resnum['J'] := 22;    resnum['K'] := 22;    resnum['L'] := 22;
|     resnum['M'] := 24;    resnum['N'] := 25;    resnum['O'] := 27;
|     resnum['P'] := 30;    resnum['Q'] := 33;    resnum['R'] := 33;
| ##  resnum[succ('R')] := 35 ;
|     resnum['S'] := 35;    resnum['T'] := 36;    resnum['U'] := 39;
|     resnum['V'] := 40;    resnum['W'] := 41;    resnum['X'] := 43;
|     resnum['Y'] := 43;    resnum['Z'] := 43;    resnum[succ('Z')] := 43;
| 
|     reslist[ 1] :='AND       '; ressy [ 1] := othersy;
|     reslist[ 2] :='ARRAY     '; ressy [ 2] := othersy;
|     reslist[ 3] :='BEGIN     '; ressy [ 3] := beginsy;
|     reslist[ 4] :='CASE      '; ressy [ 4] := casesy;
|     reslist[ 5] :='CONST     '; ressy [ 5] := constsy;
|     reslist[ 6] :='DO        '; ressy [ 6] := dosy;
|     reslist[ 7] :='DIV       '; ressy [ 7] := othersy;
|     reslist[ 8] :='DOWNTO    '; ressy [ 8] := othersy;
|     reslist[ 9] :='END       '; ressy [ 9] := endsy;
|     reslist[10] :='ELSE      '; ressy [10] := elsesy;
| 
| ##  reslist[11] :='EXIT____  '; ressy [11] := exitsy;
|     reslist[12] :='EXTERN    '; ressy [12] := externsy;
|     reslist[13] :='FOR       '; ressy [13] := forsy;
|     reslist[14] :='FILE      '; ressy [14] := othersy;
|     reslist[15] :='FORWARD   '; ressy [15] := forwardsy;
|     reslist[16] :='FUNCTION  '; ressy [16] := functionsy;
|     reslist[17] :='FORTRAN   '; ressy [17] := langsy;
|     reslist[18] :='GOTO      '; ressy [18] := gotosy;
|     reslist[19] :='IF        '; ressy [19] := ifsy;
|     reslist[20] :='IN        '; ressy [20] := othersy;
| 
|     reslist[21] :='INITPROCED'; ressy [21] := initprocsy;
|     reslist[22] :='LOOP____  '; ressy [22] := loopsy;
|     reslist[23] :='LABEL     '; ressy [23] := labelsy;
|     reslist[24] :='MOD       '; ressy [24] := othersy;
|     reslist[25] :='NOT       '; ressy [25] := othersy;
|     reslist[26] :='NIL       '; ressy [26] := othersy;
|     reslist[27] :='OR        '; ressy [27] := othersy;
|     reslist[28] :='OF        '; ressy [28] := ofsy;
|     reslist[29] :='OTHERS    '; ressy [29] := otherssy;
|     reslist[30] :='PACKED    '; ressy [30] := othersy;
| 
|     reslist[31] :='PROCEDURE '; ressy [31] := proceduresy;
|     reslist[32] :='PROGRAM   '; ressy [32] := programsy;
|     reslist[33] :='RECORD    '; ressy [33] := recordsy;
|     reslist[34] :='REPEAT    '; ressy [34] := repeatsy;
|     reslist[35] :='SET       '; ressy [35] := othersy;
|     reslist[36] :='THEN      '; ressy [36] := thensy;
|     reslist[37] :='TO        '; ressy [37] := othersy;
|     reslist[38] :='TYPE      '; ressy [38] := typesy;
|     reslist[39] :='UNTIL     '; ressy [39] := untilsy;
|     reslist[40] :='VAR       '; ressy [40] := varsy;
| 
|     reslist[41] :='WHILE     '; ressy [41] := whilesy;
|     reslist[42] :='WITH      '; ressy [42] := othersy;
|     END;
| 
| 
| # procedure init2; "INITPROCEDURE;"
|     BEGIN (*SETS*)
| ## "digits := ['0'..'9'];
|     letters := ['A'..'Z'];
| ##  alphanum := ['0'..'9','A'..'Z'] (*LETTERS OR DIGITS*); "
|     decsym := [labelsy,constsy,typesy,varsy,programsy];
|     prosym := [functionsy..initprocsy];
|     endsym := [functionsy..eobsy];      (*PROSYM OR ENDSYMBOLS*)
|     begsym := [beginsy..ifsy];
|     relevantsym := [labelsy..initprocsy (*DECSYM OR PROSYM*),beginsy,forwardsy,
| externsy,eobsy];
|     END (*SETS*);
| 
| 
| PROCEDURE init;
|     BEGIN
| #   init0 ;
| #   init1 ;
| #   init2 ;
| #   rtime[0]:=clock(1);
|     new(heapmark);    (*THE HEAP IS DEALLOCATED AFTER EACH PROGRAM*)
|     workcall := NIL;
|     i := 0;
|     bufflen := 0;
|     buffmark := 0;
|     bufferptr := 2;
|     variant_level := 0;
|     reallincnt:= 0;
|     linecnt :=0;
|     blocknr := 0;
|     level := 0;
|     pagecnt := 1;
|     pagecnt2 := 0;
|     errcount := 0;
|     eoline := true;
|     gotoinline := false;
|     programpresent := false;
|     procstrucdata.exists := false;
|     oldspaces := false;
|     declaring := false;
|     bmarktext := ' ';
|     emarktext := ' ';
|     sy := blanks;   prog_name := blanks;
| #  "date(date_text);  time(time_text);"
|     FOR ch := chr(0) to chr(255) DO
|         firstname [ch] := NIL;
|     FOR ch := ' ' TO 'Z' DO
|         delsy [ch] := othersy;
| ###   FOR ch := 'A' TO 'I' DO    delsy[ch] := letterup ;
| ###   FOR ch := 'J' TO 'R' DO    delsy[ch] := letterup ;
| ###   FOR ch := 'S' TO 'Z' DO    delsy[ch] := letterup ;
| ###   FOR ch := 'a' TO 'i' DO    delsy[ch] := letterlo ;
| ###   FOR ch := 'j' TO 'r' DO    delsy[ch] := letterlo ;
| ###   FOR ch := 's' TO 'z' DO    delsy[ch] := letterlo ;
| ###   FOR ch := '0' TO '9' DO    delsy[ch] := digit ;
| ###   delsy['"']  := dquotech;
| ###   delsy['#']  := skipch ;
| ###   delsy['$']  := dollarch ;
| ###   delsy[''''] := quotech ;
| ###   delsy['_']  := undsch ;
|     delsy [' '] := spacech;
|     delsy ['('] := lparent;
|     delsy [')'] := rparent;
|     delsy ['['] := lbracket;
|     delsy [']'] := rbracket;
|     delsy [';'] := semicolon;
|     delsy ['.'] := point;
|     delsy [':'] := colon;
|     delsy ['='] := eqlsy;
|     FOR i := -1 TO 201 DO
|         buffer [i] := ' ';
|     i := 0;
|     new (firstname['M']);
|     listptr := firstname ['M'];
|     WITH firstname ['M']@ DO
|         BEGIN
|         name := 'MAIN.     ';
|         llink := NIL;
|         rlink := NIL;
|         profunflag := 'M';
|         new (first);
|         last := first;
|         WITH last@ DO
|             BEGIN
|             linenr := 1;
|             pagenr:=1;
|             contlink := NIL;
|             END;
|         END;
|     new (procstrucf);
|     WITH procstrucf@ DO
|         BEGIN
|         procname := firstname ['M'];
|         nextproc := NIL;
|         linenr   := 1;
|         pagenr:=1;
|         proclevel:= 0;
|         firstcall := NIL;
|         END;
|     procstrucl := procstrucf;
|     ch := ' ';
|     FOR i := 1 TO 17 DO
| ##      tabs [i] := "chr (ht)" ' ';
| #   linenb := '-----' ;
|     END (*INIT*);
|     (*CHECKOPTIONS[*) (*SETSWITCH*)
| 
|     (*---------------------------------------------------------------------
|      !  CHECKS THE PRESENCE OF SWITCHES WITH THE FILE NAMES.
|      !
|      !  VALID SWITCHES ARE:                     BRACKETS INDICATE OPTIONAL.
|      !                                          <N> STANDS FOR AN INTEGER NUMBER
| .
|      !                                          <L> STANDS FOR A LETTER.
|      !
|      !  SWITCH          MEANING                                         DEFAULT.
|      !
|      !           FILES.
|      !   /[NO]NEW        WRITTING OF THE NEWSOURCE FILE                 ON
|      !   /[NO]CROSS[:<N>]  WRITTING OF THE CROSSLIST FILE.              ON,15
|      !                    <N> IS THE SUM OF:
|      !                          1   SOURCE PROGRAM LISTING
|      !                          2   LISTING OF IDENTIFIERS
|      !                          4   LISTING OF PROC-FUNC
|      !                              DECLARATION NESTING.
|      !                          8   LISTING OF PROC-FUNC CALL NESTING.
|      !   /version:<n>    behave as if conditionally compiling %<n>
|      !                     comments.                                    -1
|      !
|      !           PAGE AND LINE FORMAT
|      !   /WIDTH:<N>      PAGE WIDTH FOR CROSSLIST. (MINIMUM: 40)        132
|      !   /INDENT:<N>     INDENTATION BETWEEN LEVELS.                    4
|      !   /INCREMENT:<N>  LINE NUMBER INCREMENT                          100
|      !   /[NO]DOTS       PUT AS A GUIDE A DOTTED LINE AT THE LEFT
|      !                   MARGIN EVERY FIFTH LINE                        ON
|      !
|      !           STATEMENT FORMAT
|      !   /BEGIN:[-]<N>   IF THE [-] IS NOT THERE, THE CONTENTS OF A
|      !                     BEGIN..END BLOCK IS INDENTED N SPACES FURTHER.
|      !                   IF IT IS THERE, THE BLOCK WILL NOT BE INDENTED,
|      !                     BUT THE BEGIN AND END STATEMENTS WILL BE
|      !                     EXDENTED N SPACES.                           0
|      !   /[NO]FORCE      FORCES NEWLINE IN STANDARD PLACES. (BEFORE AND
|      !                    AFTER BEGIN, END, THEN, ELSE, REPEAT, ETC.)   OFF
|      !   /[NO]CLEAN      CONVERTS THE SYMBOLS FOR BEGIN AND END OF
|      !                    COMMENT FROM OLD STANDARDS TO '('-'*' AND '*'-')'
| ON
|      !
|      !           UPPER AND LOWER CASE
|      !                          NOTE: THE POSSIBLE VALUES FOR <L> ARE:
|      !                                  U MEANS UPPER CASE
|      !                                  L MEANS LOWER CASE.
|      !
|      !   /RES:<L>        CASE USED FOR RESERVED WORDS.                  U
|      !   /NONRES:<L>     SAME FOR NON-RESERVED WORDS.                   L
|      !   /COMM:<L>       SAME FOR COMMENTS.                             L
|      !   /STR:<L>        SAME FOR STRINGS.                              U
|      !   /CASE:<L>       RESETS ALL THE DEFAULTS TO <L>.
| OFF
|      !
|      +--------------------------------------------------------------------*)
| 
| PROCEDURE checkoptions;
|     VAR
|         try: integer;
| 
|     PROCEDURE setswitch(opt:alfa;VAR switch:boolean);
|         VAR
|             i: integer;
|         BEGIN (*SETSWITCH*)
| ##(*    getoption(opt,i);   *)  i := ord('l') ;
|         IF i=ord('L') THEN
|             switch:=false
|         ELSE
|             IF i=ord('U') THEN
|                 switch:=true;
|         END (*SETSWITCH*);
| 
|     PROCEDURE showthemall (i: integer);
|         BEGIN
|         writeln (tty,'(',i:3,')',oldfileid,',',programname);
|         writeln (tty, new_name,',',new_prot,',',new_ppn,',',new_dev,',',
| newfileid,',',programname);
|         writeln (tty, cross_name,',',cross_prot,',',cross_ppn,',',cross_dev,',',
| crossfileid,',',programname);
|         writeln (tty);
| ##       (* break(tty); *)
|         END;
| 
|     BEGIN (*CHECKOPTIONS*)
|     ###########(*##############
|     getparameter(oldsource,oldfileid,programname,true);
|     IF NOT option('NONEW     ') THEN
|       parnameget(new_name,new_prot,new_ppn,new_dev,newfileid,programname,false);
|     IF NOT option('NOCROSS   ') THEN
|         parnameget(cross_name,cross_prot,cross_ppn,cross_dev,crossfileid,program
| name,false);
| 
|     IF NOT option('NONEW     ') THEN
|         begin
|         IF (new_name = '         ') AND (new_dev = 'dsk   ') THEN
|             BEGIN
|             getstatus(oldsource, new_name,old_prot,old_ppn,old_dev);
|             new_name[7]:='N';
|             new_name[8]:='E';
|             new_name[9]:='W';
|             END;
|         startfile(newsource,new_name,new_prot,new_ppn,new_dev,false,newfileid);
|         end;
| 
|     IF NOT option('NOCROSS   ') THEN
|         begin
|         IF (cross_name = '         ') AND (cross_dev = 'dsk   ') THEN
|             BEGIN
|             getstatus(oldsource, cross_name,old_prot,old_ppn,old_dev);
|             cross_name[7]:='C';
|             cross_name[8]:='R';
|             cross_name[9]:='L';
|             END;
|         startfile(crosslist,cross_name,cross_prot,cross_ppn,cross_dev,false,cros
| sfileid);
|         end;
| ######################*)##############
| 
| ##  renewing:= true "NOT option('NONEW     ')" ;
| 
| ##  crossing:= true "NOT option('NOCROSS   ')" ;
|     IF crossing THEN
|         BEGIN
| ##(*    getoption('CROSS     ',try);     *) try  := 0 ;
|         IF try = 0 THEN
|             try:=15;
|         callnesting:=try > 7;
|         decnesting:=(try MOD 8) > 3;
|         refing:= (try MOD 4) > 1;
|         crossing:=(try MOD 2) = 1;
|         END;
| 
| ##(*if option('version   ') then    *)
|         begin
| ##(*    getoption('version   ',goodversion);  *)  goodversion := 15 ;
|         if goodversion > 9 then
|             begin
|             goodversion := -1;
|             anyversion := true;
|             end;
|         end;
| 
| ##(*IF option('WIDTH     ') THEN  *)
|         BEGIN
| ##(*    getoption('WIDTH     ',maxch);  *)  maxch := 90 ;
|         IF maxch < 40 THEN
|             maxch:=40;
|         maxch:=maxch-18;
|         END;
| 
| #################(*##################
|     IF option('INDENT    ') THEN
|         BEGIN
| ##(*    getoption('INDENT    ',feed);                 *)
|         IF feed < 0 THEN
|             feed:=4;
|         END;
| 
|     IF option('INCREMENT ') THEN
|         BEGIN
| ##(*    getoption('INCREMENT ',increment);            *)
|         IF increment < 0 THEN
| ##          increment:= "100" 1;
|         END;
| 
|     doting:=NOT option('NODOTS    ');
| 
|     IF option('BEGIN     ') THEN
|         BEGIN
| ##(*    getoption('BEGIN     ',indentbegin);          *)
|         IF indentbegin < 0 THEN
|             BEGIN
|             begexd:=-indentbegin;
|             indentbegin:=0;
|             END;
|         END;
| 
|     forcing:=option('FORCE     ');
| 
|     cleaning := NOT option('NOCLEAN   ');
| 
|     IF option('CASE      ') THEN
|         BEGIN
|         setswitch('CASE      ',rescase);
|         nonrcase:=rescase;
|         comcase:=rescase;
|         strcase:=rescase;
|         END;
| 
|     setswitch('RES       ',rescase);
|     setswitch('NONRES    ',nonrcase);
|     setswitch('COMM      ',comcase);
|     setswitch('STR       ',strcase);
| #################*)##################
|     END (*CHECKOPTIONS*);
|     (*PAGE AND LINE CONTROL*) (*HEADER*) (*NEWPAGE*) (*NEWLINE*)
| 
| PROCEDURE header (name: alfa);
|     (*PRINT TOP OF FORM AND HEADER ON LIST OUTPUT*)
|     VAR
|         position: integer;
| 
|     BEGIN (*HEADER*)
|     pagecnt2 := pagecnt2 + 1;
|     reallincnt := 0;
|     IF crossing THEN
|         BEGIN
|         page(crosslist); " writeln(crosslist) ;"
| ##      write (crosslist, 'Page':9, pagecnt:4, '-', pagecnt2:3 ", ' ':15");
|         position := 84;
|         IF maxch < 84 THEN
|             BEGIN
|             reallincnt:=1;
|             writeln(crosslist);
|             position := 42;
|             END;
|         write(crosslist,'   [', prog_name,']', time"_text":50, date"_text");
|         IF (name <> blanks) AND (maxch < position + 25) THEN
|             BEGIN
|             reallincnt := reallincnt + 1;
|             writeln (crosslist);
|             position := 0;
|             END;
|         writeln (crosslist, ' ': maxch - position, name);
|         writeln(crosslist);
|         END;
|     END (*HEADER*);
| 
| 
| PROCEDURE newpage;
|     BEGIN (*NEWPAGE*)
|     pagecnt2 := 0;
|     pagecnt := pagecnt + 1;
|     IF renewing THEN
| ##    (*write(newsource, chr(cr), chr(ff));*)    writeln(newsource) ;
|     header (blanks);
|     IF eoln (oldsource) THEN
|         readln(oldsource);
|     linecnt := 0;
|     reallincnt := 0;
|     IF prog_name <> blanks  THEN
|         write(tty, pagecnt:3,'..');
| ##   (* break(tty); *)
|     END (*NEWPAGE*);
| 
| 
| PROCEDURE newline;
|     BEGIN
|     IF reallincnt = maxline THEN
|         header (blanks);
|     linecnt := linecnt + 1;
|     reallincnt := reallincnt + 1;
| ##  if crossing then write(crosslist, ' ':5);
| ##  if renewing then write(newsource, ' ':5) ;
|     END;
|     (*BLOCK[*) (*OUTPUT PROCEDURES:*) (*ERROR*) (*WRITELINE[*) (*USETABS*) (*]*)
|  (*SETLASTSPACES*)
| 
| 
| PROCEDURE block;
|     VAR
|         curproc : listptrty;        (*ZEIGER AUF DIE PROZEDUR IN DEREN ANWEISUNG
| STEIL DAS PROGRAMM SICH BEFINDET*)
|         itisaproc : boolean;        (*TRUE WHEN THE WORD PROCEDURE IS FOUND*)
|         locprocstl: procstructy;
| 
| 
|     PROCEDURE error (errnr : errkinds);
|         BEGIN (*ERROR*)
|         errcount := errcount+1;
|         reallincnt := reallincnt + 1; (*COUNT THE LINE OF THE ERROR MESSAGE ON T
| HE LPT: FILE*)
|         IF crossing THEN
|             BEGIN
|             write (crosslist, ' ':17,' *??* ');
|             CASE errnr OF
|                 begerrinblkstr   : write(crosslist, sy,' ? ? ? : ERROR IN BLOCK'
| ,'STRUCTURE. POSSIBLY A MISSING BEGIN.');
|                 enderrinblkstr   : write(crosslist, sy,' ? ? ? : ERROR IN BLOCK'
| ,'STRUCTURE. POSSIBLY A MISSING END.');
|                 missgenduntil : write(crosslist, 'MISSING ''END'' OR ''UNTIL'' '
| ,'NUMBER ',emarknr : 4);
|                 missgthen     : write(crosslist, 'MISSING ''THEN'' NUMBER ',
| emarknr : 4);
|                 missgof       : write(crosslist, 'MISSING ''OF'' TO ''CASE'' '
| ,'NUMBER ',bmarknr : 4);
|                 missgexit     : write(crosslist, 'MISSING ''EXIT'' IN ''LOOP'' '
| ,emarknr : 4);
|                 missgrpar     : write(crosslist, 'MISSING RIGHT PARENTHESIS OR '
| ,'BRACKET');
|                 missgquote    : write(crosslist, 'MISSING CLOSING QUOTE ON THIS'
| ,' LINE');
|                 linetoolong:
|                           IF renewing THEN
|                               write(crosslist,'NEXT LINE IS TOO LONG. IT WILL '
| ,'BE BROKEN AT COLUMN',
|                                     oldwidth:4,' IN NEWSOURCE.');
|                 missgmain     : write(crosslist, 'WARNING: THIS FILE HAS NO '
| ,'MAIN BODY');
|                 missgpoint    : write(crosslist,'MISSING CLOSING POINT AT END '
| ,'OF PROGRAM.');
|                 END;
|             writeln(crosslist,' *??*');
|             END;
|         writeln(tty);
|         write(tty, ' ERROR AT ', linecnt*increment: 5, '/', pagecnt:2,
|                     ord(errnr):12);
|         END (*ERROR*) ;
| 
| 
|     PROCEDURE writeline (position (*LETZTES ZU DRUCKENDES ZEICHEN IM PUFFER*):
| integer);
|         VAR
|             i, j, tabcnt, maxchar: integer;    (*MARKIERT ERSTES ZU DRUCKENDES Z
| EICHEN*)
| 
| 
|         PROCEDURE usetabs(lastspaces: integer;crossing,renewing:boolean);
|             VAR
|                 lspaces: integer;
|             BEGIN (*USETABS*)
|             (*USE TABS AND SPACES TO MAKE INDENTATION*)
|             tabcnt := lastspaces DIV 8;
|             lspaces := lastspaces MOD 8;
|             IF renewing THEN
|                 BEGIN
|                 write(newsource, tabs:tabcnt*8);
|                 write(newsource, ' ': lspaces);
|                 END;
|             IF crossing THEN
|                 IF doting AND ((reallincnt MOD 5) = 4) THEN
|                     BEGIN
| ##                  write(crosslist, ' ', dots: lastspaces - 1);
|                     IF lastspaces > 0 THEN
|                         write (crosslist, ' ');
|                     END
|                 ELSE
|                     BEGIN
|                     write(crosslist, tabs: tabcnt*8);
|                     write (crosslist, ' ': lspaces);
|              (*+++  IF lastspaces > 7 THEN              (*COMPENSATE FOR THE FIR
| ST TAB*)
|                         write (crosslist, '  ');    +++*)
|                     END;
|             END (*USETABS*);
| 
|         BEGIN (*WRITELINE*)
|         position := position - 2;
|         IF position > 0 THEN
|             BEGIN
|             i := buffmark + 1;
|             WHILE (buffer [i] = ' ') AND (i <= position) DO
|                 i := i + 1;
|             buffmark := position;
|             WHILE (buffer [position] = ' ') AND (i < position) DO
|                 position := position - 1;
|             IF i <= position THEN
|                 BEGIN
|                 IF NOT programpresent THEN
|                     BEGIN
|                     programpresent := true;
|                     header (blanks);
|                     END;
|                 newline;
|                 IF crossing THEN
|                     BEGIN
|                     IF gotoinline THEN
|                         BEGIN
|                         write(crosslist, '****GOTO****');
|                         gotoinline := false;
|                         bmarktext:=' ';
|                         emarktext:=' ';
|                         END
|                     ELSE
|                         BEGIN
|                         IF bmarktext <> ' ' THEN
|                             BEGIN
|                             write (crosslist, bmarktext, bmarknr : 4, ' ');
|                             bmarktext := ' ';
|                             END
|                         ELSE
|                             write(crosslist,'      ');
|                         IF emarktext <> ' ' THEN
|                             BEGIN
|                             write (crosslist,emarktext,emarknr : 4,' ');
|                             emarktext := ' ';
|                             END
|                         ELSE
|                             write (crosslist,'      ');
|                         END;
|                     write (crosslist, linecnt * increment : 5,' ');
|                     END;
|                 IF NOT oldspaces THEN
|                     lastspaces := spaces;
|                 usetabs(lastspaces,crossing,renewing);
|                 maxchar:=maxch+i-lastspaces-1;
|                 FOR j := i TO position DO
|                     BEGIN
|                     IF crossing AND (j > maxchar) THEN
|                         BEGIN
|                         writeln(crosslist);
|                         IF reallincnt = maxline THEN
|                             header (blanks);
|                         reallincnt:=reallincnt+1;
|                         usetabs(lastspaces+18+feed,crossing,false);
|                         maxchar:=maxch+j-lastspaces-1;
|                         END;
| ##                  IF (NOT flagger[j]) AND (* ('A' <= buffer[j]) AND
| ###                  (buffer[j] <= 'Z') *) (delsy[buffer[j]] = letterup) THEN
|                         BEGIN
|                         IF crossing THEN
| ###                         write(crosslist,chr(ord(buffer[j])-64(*+40B*)));
|                         IF renewing THEN
| ###                         write(newsource,chr(ord(buffer[j])-64(*+40B*)));
|                         END
|                     ELSE
| ##                  IF flagger[j] AND (delsy[buffer[j]] = letterlo)  then
| 
|                         BEGIN
|                         IF crossing THEN
| ###                         write(crosslist,chr(ord(buffer[j])+64(*+40B*)));
|                         IF renewing THEN
| ###                         write(newsource,chr(ord(buffer[j])+64(*+40B*)));
|                         END
|                     ELSE
|                         BEGIN
|                         IF crossing THEN
|                             write (crosslist, buffer [j]);
|                         IF renewing THEN
|                             write(newsource, buffer[j]);
|                         END;
|                     END;
|                 IF crossing THEN
|                     writeln(crosslist);
|                 IF renewing THEN
|                     writeln(newsource);
|                 IF ((linenb = '     ') AND (position = bufflen)) OR (maxinc <=
| linecnt) THEN
|                     newpage;
|                 END;
|             END;
|         lastspaces := spaces;
|         oldspaces := false;
|         thendo := false;
|         END (*WRITELINE*) ;
| 
| 
|     PROCEDURE setlastspaces(i: integer);
|         BEGIN
|         oldspaces := true;
| ##      lastspaces := 0 ;  if i > 0 then  lastspaces := i ;   (*max(0,i);*)
|         END;
|         (*INPUT PROCEDURES:*) (*INSYMBOL[*) (*READBUFFER*)
| 
|     PROCEDURE insymbol ;
|         LABEL 1;
|         VAR
|             oldspacesmark,            (*ALTER ZEICHENVORSCHUB BEI FORMATIERUNG V
| ON KOMMENTAREN*)
|             i: integer;
| 
| 
| 
|         PROCEDURE readbuffer;
|             (*READS A CHARACTER FROM THE INPUT BUFFER*)
| 
| 
|             PROCEDURE readline;
|                 (*HANDLES LEADING BLANKS AND BLANK LINES, READS NEXT NONBLANK LI
| NE
|                  (WITHOUT LEADING BLANKS) INTO BUFFER*)
|                 LABEL 111 ;
|                 VAR
|                     ch : char;
|                 BEGIN (*READLINE*)
|                 (*ENTERED AT THE BEGINNING OF A LINE*)
|                 REPEAT
|                     WHILE eoln (oldsource) AND NOT eof (oldsource) DO
|                         BEGIN
|                         (*IS THIS A PAGE MARK?*)
| ##                     "getlinenr (oldsource,linenb);"
|                         readln(oldsource);
|                         IF (linenb = '     ') AND programpresent THEN
|                             newpage
|                         ELSE
|                             IF programpresent THEN
|                                 BEGIN
|                                 (*HANDLE BLANK LINE*)
|                                 newline;
|                                 IF crossing THEN
|                                     writeln (crosslist,"chr(ht)"' ':12,linecnt *
|  increment : 5);
|                                 IF renewing THEN
|                                     writeln(newsource);
|                                 IF maxinc <= linecnt THEN
|                                     newpage;
|                                 END;
|                         END;
|                     read(oldsource, ch);
|                 UNTIL (ch <> ' ') OR (eof (oldsource));
|                 bufflen := 0;
|                 (*READ IN THE LINE*)
| ##            (*LOOP *)  repeat
|                     bufflen := bufflen + 1;
|                     buffer [bufflen] := ch;
|                     flagger[bufflen]:=nonrcase;
| ##            (*EXIT*) IF (eoln (oldsource) OR (bufflen = oldwidth))
|                          THEN GOTO 111 ;
|                     read(oldsource, ch);
|                   (*END*) UNTIL FALSE ;
|               111:
|                 buffer[bufflen+1] := ' '; (*SO WE CAN ALWAYS BE ONE CHAR AHEAD*)
|                 IF NOT eoln (oldsource) THEN
|                     error(linetoolong)
|                 ELSE
|                     IF NOT eof (oldsource) THEN
|                         BEGIN
| ##                     "getlinenr (linenb);"
|                         readln(oldsource);
|                         END;
|                 bufferptr := 1;
|                 buffmark := 0;
|                 END (*READLINE*) ;
| 
|             BEGIN (*READBUFFER*)
|             (*IF READING PAST THE EXTRA BLANK ON THE END, GET A NEW LINE*)
|             IF eoline THEN
|                 BEGIN
|                 writeline (bufferptr);
|                 ch := ' ';
|                 IF eof (oldsource) THEN
|                     eob := true
|                 ELSE
|                     readline;
|                 END
|             ELSE
|                 BEGIN
|                 ch := buffer [bufferptr];
|                 bufferptr := bufferptr + 1;
|                 END;
|             eoline := bufferptr = bufflen + 2;
|             END (*READBUFFER*) ;
| 
|             (*RESWORD*) (*FINDNAME*) (*PARENTHESE*)
| 
|         FUNCTION resword: boolean ;
|             (*DETERMINES IF THE CURRENT IDENTIFIER IS A RESERVED WORD*)
| ##          LABEL 222 ;
|             VAR
|                 i,j: integer;  lid : alfa ;
|             BEGIN (*RESWORD*)
| ##          resword:= false; lid := sy ;
| ##          for i := 1 to 10 do
| ##            if delsy[lid[i]] = letterlo then lid[i] := chr( ord(lid[i]) +64) ;
| ##          FOR i:=resnum[lid[1]] TO resnum[succ(lid[1])] - 1
|             DO
| ##              IF reslist[ i ] = lid THEN
|                     BEGIN
|                     resword := true;
|                     syty := ressy [i];
| ##               (* i:=resnum[succ(sy[1])]; ** BUG 1 **   *)
|                     FOR j:=bufferptr-syleng-1 TO bufferptr-2 DO
|                         flagger[j]:=rescase;
| ##                   GOTO 222;
|                     END;
| ##          222:
|             END (*RESWORD*) ;
| 
| 
| ##      PROCEDURE findname "(curproc: listptrty)" (*does not seem to be used*);
|             VAR
|                 lptr: listptrty;        (*ZEIGER AUF DEN VORGAENGER IM BAUM*)
|                 bptr,
|                 zptr : lineptrty;       (*ZEIGER AUF DIE VORLETZTE ZEILENNUMMER
| IN EINER KETTE*)
|                 found,                  (*SET AFTER IDENTIFIER IS FOUND*)
|                 right: boolean;         (*MERKVARIABLE FUER DIE VERZWEIGUNG IM B
| AUM*)
|                 indexch : char;         (*INDEXVARIABLE FUER DAS FELD DER STARTZ
| EIGER (FIRSTNAME)*)
| 
|             BEGIN (*FINDNAME*)
|             indexch := sy [1];
|             listptr := firstname [indexch];
|             (*SEARCH IN THE TREE FOR THE IDENTIFIER*)
|             found := false;
|             WHILE NOT found AND (listptr <> NIL) DO
|                 BEGIN
|                 lptr:= listptr;
|                 IF sy = listptr@.name THEN
|                     BEGIN
|                     found := true;
| ##                  IF"(listptr@.profunflag IN ['P', 'F'])"(NOT declaring) AND
| ##                    ((listptr@.profunflag = 'P')OR(listptr@.profunflag = 'F'))
|                       THEN
|                         BEGIN
|                         new (workcall);
|                         workcall@.whom := listptr@.procdata;
|                         workcall@.nextcall := NIL;
|                         END;
|                     zptr := listptr@.last;
|                     IF (zptr@.linenr <> linecnt+1) OR (zptr@.pagenr <> pagecnt)
| THEN
|                         BEGIN
|                         new (listptr@.last);
|                         WITH listptr@.last@ DO
|                             BEGIN
|                             linenr := linecnt + 1;
|                             pagenr := pagecnt;
|                             contlink := NIL;
|                             IF declaring THEN
|                                 declflag := 'D'
|                             ELSE
|                                 declflag := ' ';
|                             END;
|                         zptr@.contlink := listptr@.last;
|                         END
|                     ELSE
|                         zptr@.declflag := 'M';
|                     END
|                 ELSE
|                     IF sy > listptr@.name THEN
|                         BEGIN
|                         listptr:= listptr@.rlink;
|                         right:= true;
|                         END
|                     ELSE
|                         BEGIN
|                         listptr:= listptr@.llink;
|                         right:= false;
|                         END;
|                 END;
|             IF NOT found THEN
|                 BEGIN (*UNKNOWN IDENTIFIER*)
|                 new (listptr);
|                 WITH listptr@ DO
|                     BEGIN
|                     name := sy;
|                     llink := NIL;
|                     rlink := NIL;
|                     profunflag := ' ';
|                     externflag := ' ';
|                     procdata := NIL;
|                     END;
|                 IF firstname [indexch] = NIL THEN
|                     firstname [indexch] := listptr
|                 ELSE
|                     IF right THEN
|                         lptr@.rlink := listptr
|                     ELSE
|                         lptr@.llink := listptr;
|                 WITH listptr@ DO
|                     BEGIN
|                     new (first);
|                     WITH first@ DO
|                         BEGIN
|                         linenr := linecnt + 1;
|                         pagenr := pagecnt;
|                         contlink := NIL;
|                         IF declaring THEN
|                             declflag := 'D'
|                         ELSE
|                             declflag := ' ';
|                         END;
|                     last := first ;
|                     END;
|                 END;
|             END (*FINDNAME*) ;
| 
|         PROCEDURE insertcall;
|             VAR
|                 thiscall: calledty;
|                 repeated,               (*SET IF SY IS A PROC-NAME AND IS ALREAD
| Y IN THE CALL SEQUENCE*)
|                 finished: boolean;      (*SET WHEN DONE CHECKING THE CALL SEQUEN
| CE*)
| 
|             BEGIN (*INSERTCALL*)
|             IF locprocstl@.firstcall = NIL THEN
|                 locprocstl@.firstcall := workcall
|             ELSE
|                 BEGIN
|                 thiscall := locprocstl@.firstcall;
|                 repeated := false;
|                 finished := false;
|                 WHILE (NOT finished) AND (NOT repeated) DO
|                     IF thiscall@.whom@.procname@.name = workcall@.whom@.procname
| @.name THEN
|                         repeated := true
|                     ELSE
|                         IF thiscall@.nextcall = NIL THEN
|                             finished := true
|                         ELSE
|                             thiscall := thiscall@.nextcall;
|                 IF NOT repeated THEN
|                     thiscall@.nextcall := workcall;
|                 END;
|             workcall := NIL;
|             END (*INSERTCALL*);
| 
| 
|         PROCEDURE parenthese (which: symbol);
|             (*HANDLES THE FORMATTING OF PARENTHESES, EXCEPT THOSE IN VARIANT PAR
| TS OF RECORDS*)
|             VAR
|                 oldspacesmark : integer;        (*ALTER ZEICHENVORSCHUB BEI FORM
| ATIERUNG VON KLAMMERN*)
|             BEGIN (*PARENTHESE*)
|             IF variant_level = 0 THEN
|                 BEGIN
|                 oldspacesmark := spaces;
|                 IF NOT oldspaces THEN
|                     setlastspaces (spaces);
|                 spaces := lastspaces + bufferptr - buffmark - 2;
|                 (*SKIP STUFF UNTIL WE SEEM TO BE OUT OF THE EXPRESSION*)
|                 IF declaring THEN
|                     REPEAT
|                         insymbol;
|                         CASE syty OF
|                             colon: declaring := false;
|                             semicolon: declaring := true;
|                             END;
|                     UNTIL syty IN [externsy..rparent,labelsy..typesy,initprocsy
| ..exitsy,dosy..forwardsy]
|                 ELSE
|                     REPEAT
|                         insymbol
|                     UNTIL syty IN [externsy..rparent,labelsy..typesy,initprocsy
| ..exitsy,dosy..forwardsy];
|                 spaces := oldspacesmark;
|                 oldspaces := true;
|                 IF syty = which THEN
|                     insymbol
|                 ELSE
|                     error(missgrpar);
|                 END;
|             END (*PARENTHESE*) ;
|             (*DOCOMMENT*) (*]INSYMBOL*)
| 
| 
|         PROCEDURE docomment (dellength: integer; firstch, secondch: char;
| cleaning: boolean);
| ##        var temposp : boolean ;
| 
|             PROCEDURE expand (here: integer; firstch, secondch: char);
|                 VAR
|                     i: integer;
| 
|                 BEGIN (*EXPAND*)
|                 bufferptr := here + 2;
|                 bufflen := bufflen + 1;
|                 FOR i := bufflen + 1 DOWNTO here + 2 DO
|                     buffer [i] := buffer [i-1];
|                 buffer [here] := firstch;
|                 buffer [here + 1] := secondch;
|                 END (*EXPAND*);
|             PROCEDURE dumpit;
|                 VAR i: integer;
|                 BEGIN
|                 write (tty, '<');
|                 FOR i := 1 TO bufflen DO
|                     write (tty, buffer[i]);
|                 writeln (tty);
|                 writeln (tty,'<',' ':bufferptr -1, '@');
|                 END;
| 
|             BEGIN (* DOCOMMENT *)
|             oldspacesmark := spaces;
|             IF oldspaces THEN
|                 spaces := lastspaces
|             ELSE
|                 lastspaces := spaces;
|             spaces := spaces + bufferptr - 1;
|             oldspaces := true;
|             IF dellength = 2 THEN
|                 BEGIN
|                 IF cleaning THEN BEGIN
|                     buffer [bufferptr - 1] := '(';
|                     buffer [bufferptr] := '*';
|                     END;
| ##              readbuffer ;  flagger[bufferptr] := comcase ; readbuffer ;
|                 (* skip over comment beginning bracket *)
| ##              if ch = '%' then
| ##              REPEAT  readbuffer;  flagger[bufferptr] := comcase;
| ##                IF ch <> '*' THEN
| ##                  BEGIN
| ##                  IF ch = 'X' THEN
| ##                    BEGIN readbuffer;  crossing := ch = '+'  END
| ##                  ELSE IF ch = 'F' THEN
| ##                    BEGIN readbuffer; renewing := ch = '+';  END
| ##                  ELSE IF ch = 'R' THEN
| ##                    BEGIN readbuffer; rescase := ch = '+' END
| ##                  ELSE IF ch = 'C' THEN
| ##                    BEGIN  readbuffer ;  comcase := ch = '+' ;  END
| ##                  ELSE IF ch = 'N' THEN
| ##                    BEGIN  readbuffer ;  nestcomments := ch ='+'  END
| ##                  ELSE IF ch='I' THEN
| ##                    BEGIN  readbuffer ;  nonrcase := ch = '+' END
| ##                  (*ELSE IF ch = 'S' THEN
| ##                      BEGIN  readbuffer ;  SAVEREGS := ch <> '-'  END
| ##                      ELSE IF ch = 'F' THEN
| ##                      BEGIN readbuffer ;  SAVEFPRS := ch <> '-' ;
| ##                      END  *) ;
| ##                  readbuffer
| ##                END
| ##              UNTIL ch <> ',' ;
| ##
| ##          (*  REPEAT   *)
| ##              WHILE NOT((ch = secondch) AND (buffer[bufferptr-2] = firstch)
| ##                        OR eob)  DO
| ##                  begin
| ##                  if nestcomments then
| ##                    if (ch = '(') and (buffer[bufferptr] = '*') then
| ##                      begin
| ##                      temposp := oldspaces ;
| ##                      docomment(2, '*', ')', false) ;
| ##                      oldspaces := temposp;
| ##                      readbuffer;
| ##                      end;
| ##
|                     flagger[bufferptr]:=comcase;
|                     readbuffer;
| ##
| ##                  end (* while .. *) ;
| ##          (*  UNTIL (ch = secondch) AND (buffer[bufferptr-2] = firstch) OR eob
| ;           *)
|                 IF cleaning THEN
|                     BEGIN
|                     buffer [bufferptr - 2] := '*';
|                     buffer [bufferptr - 1] := ')';
|                     END;
|                 END
|             ELSE
|                 BEGIN
|                 IF cleaning THEN
|                     expand (bufferptr - 1,'(','*');
|                 REPEAT
|                     flagger[bufferptr]:=comcase;
|                     readbuffer;
|                 UNTIL (ch = firstch) OR eob;
|                 IF cleaning THEN
|                     expand (bufferptr - 1, '*', ')');
|                 END;
|             spaces := oldspacesmark;
|             oldspaces := true;
|             END (*DOCOMMENT*);
| 
|         BEGIN (*INSYMBOL*)
|         syleng := 0;
|        "WHILE (ch IN ['_', '(', ' ', '$', '?', '!', '@', '%', '/', '\']) AND NOT
|  eob  DO"
| ###     WHILE ((delsy[ch] in [spacech, dquotech, skipch, lparent])
| ###           AND (NOT eob)) DO
| ##   (* WHILE  ( (ch = '_') OR (ch = '(') OR (ch = ' ') OR (ch = '$') OR
| ##              (ch = '?') OR (ch = '!') OR (ch = '@') OR (ch = '%') OR
| ##              (ch = '/') OR (ch = '\') OR (ch = '#') OR (ch = '"') )
| ##              AND (NOT eob)  DO  *)
|             BEGIN
|             IF (ch = '(') AND (buffer[bufferptr] = '*') THEN
|                 docomment (2,'*',')', false)
|             ELSE
| ##           (* IF (ch = '/') AND (buffer[bufferptr] = '*') THEN
|                     docomment (2,'*','/',cleaning)
| ##              ELSE   *)
| ##                  IF ch = '"' then  docomment(1, '"', ' ', cleaning)
| ##                  ELSE  IF ch = '#' THEN buffer[bufferptr-1] := ' '
| ##                  (*ELSE
|                     IF ch = '%' THEN
| ##                    IF   (buffer[bufferptr] >= '0') AND
| ##                         (buffer[bufferptr] <= '9') then
|                             if anyversion OR (ord(buffer[bufferptr]) - ord ('0')
|  = goodversion) then
|                                 bufferptr := bufferptr + 1
|                             else
|                                 docomment (1,'\','\',cleaning)
|                         else
| ##                      docomment (1,'\','\',cleaning)    *)
| ##                  ELSE  IF ch = '#' THEN buffer[bufferptr-1] := ' '
|                     ELSE
| ##                      IF (ch = '(') (* OR (ch = '/') *) THEN
|                             GOTO 1;
|             readbuffer;
|             END;
| ##    " CASE ch OF
|             'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
|             'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
|             'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
| ##          'Z':"
| ##   (*  IF (ch >= 'A') AND (ch <= 'Z')  THEN  *)
| ###
| ###    CASE delsy[ch] OF
| ###
| ###    letterup, letterlo :
|               BEGIN
|               syleng := 0;
|               sy := '          ';
|               REPEAT
|                   syleng := syleng + 1;
|                   IF syleng <= 10 THEN
|                       sy [syleng] := ch;
|                   readbuffer;
| ##       (*   UNTIL NOT (((ch >= '0') AND (CH <= '9')) OR
| ##                      ((ch >= 'A') AND (ch <= 'Z')) OR (ch = '_'));*)
| ###           UNTIL NOT(delsy[ch] IN [letterup, letterlo, digit,
| ###                                   dollarch, undsch]) ;
|               IF NOT resword THEN
|                   BEGIN
|                   syty := ident ;
| ##                findname"(curproc)";
|                   END
| ##            END ;
| ##    (* ELSE IF  (ch >= '0') AND (ch <= '9') THEN *)
| ##        " '0', '1', '2', '3', '4', '5', '6', '7', '8',
|             '9':"
| 
| ##          digit :
|               BEGIN
|               REPEAT
|                   syleng := syleng + 1;
|                   readbuffer;
|               UNTIL NOT (('0' <= ch) AND (ch <= '9'));
|               syty := intconst;
|               IF ch = 'B' THEN
|                   BEGIN
|                   flagger[bufferptr-1]:=true;
|                   readbuffer;
|                   END
|               ELSE
|                   BEGIN
|                   IF ch = '.' THEN
|                       BEGIN
|                       REPEAT
|                           readbuffer
|                       UNTIL NOT (('0' <= ch) AND (ch <= '9'));
|                       syty := othersy; syleng := 0; (*REALS CAN'T BE LABELS*)
|                       END;
|                   IF ch = 'E' THEN
|                       BEGIN
|                       readbuffer;
|                       IF (ch = '+') OR (ch = '-') THEN
|                           readbuffer;
|                       WHILE ('0' <= ch) AND (ch <= '9') DO
|                           readbuffer;
|                       syty := othersy; syleng := 0; (*REALS CAN'T BE LABELS*)
|                       END;
|                   END;
| ##            END  ;
| ##     (* ELSE IF ch = ''''  THEN  *)
| ###       quotech :
|                BEGIN
|                syty := strgconst;
|                REPEAT
| ###             (* flagger[bufferptr]:=strcase; *)
| ###                (*this ensures that Strings will not be up/low shifted*)
| ###                flagger[bufferptr]:= delsy[buffer[bufferptr]] = letterup ;
|                    readbuffer;
|                UNTIL (ch = '''') OR eob OR eoline;
|                IF ch <> '''' THEN
|                    error(missgquote);
|                readbuffer;
| ##             END ;
| ##    (*  ELSE IF ch = '"' THEN
|               BEGIN
|               REPEAT
|                   readbuffer
| ##            UNTIL NOT ((ch >= '0') AND (ch <= '9')) "(digits + ['A'..'F']))";
|               syty := intconst;
| ##            END     *)
| ##     (* ELSE IF ch = ' ' THEN *)
| 
| ###    spacech : syty := eobsy ;   (*END OF FILE*)
| ##     (* ELSE   *)  (*OTHERS*)
| 
| ###    othersy, lparent, rparent, lbracket, rbracket,
| ###    semicolon, point, colon, eqlsy :
|                  BEGIN
|         1:
|                  syty := delsy [ch];
|                  readbuffer;
|                  IF (syty = colon) AND (ch = '=') THEN
|                      BEGIN
|                      workcall := NIL;
|                      syty := othersy;
|                      readbuffer;
|                      END
|                  ELSE
|                      IF syty IN [lparent, lbracket] THEN
|                          IF syty = lparent THEN
|                              parenthese (rparent)
|                          ELSE
|                              parenthese (rbracket);
|                  END ;
| ##            END;  (* CASE delsy[ch] OF *)
|         IF workcall <> NIL THEN
|             insertcall;
|         END (*INSYMBOL*) ;
| 
|         (*"PARSING" PROCEDURES:*) (*RECDEF[*) (*CASEDEF*) (*PARENTHESE*) (*]*)
| 
|     PROCEDURE recdef;
|         VAR
|             oldspacesmark  : integer;         (*ALTER ZEICHENVORSCHUB BEI FORMAT
| IERUNG VON RECORDS*)
| 
| 
|         PROCEDURE casedef;
|             VAR
|                 oldspacesmark  : integer;       (*ALTER ZEICHENVORSCHUB BEI FORM
| ATIERUNG VON VARIANT PARTS*)
| 
| 
|             PROCEDURE parenthese;
|                 (*HANDLES THE FORMATTING OF PARENTHESES INSIDE VARIANT PARTS*)
|                 VAR
|                     oldspacesmark : integer;      (*SAVED VALUE OF 'SPACES'*)
|                 BEGIN (*PARENTHESE*)
|                 oldspacesmark := spaces;
|                 IF NOT oldspaces THEN
|                     setlastspaces (spaces);
|                 spaces := spaces + bufferptr - 2;
|                 declaring := true;
|                 insymbol;
|                 REPEAT
| ##              IF  NOT (syty IN [casesy, recordsy, semicolon, lparent,
| ##                           eqlsy, colon])  THEN  insymbol
| ##              ELSE
|                     CASE syty OF
|                         casesy  : casedef;
|                         recordsy : recdef;
|                         semicolon, lparent:
|                                          BEGIN
|                                          declaring := true;
|                                          insymbol;
|                                          END;
|                         eqlsy, colon:
|                                    BEGIN
|                                    declaring := false;
|                                    insymbol;
|                                    END;
| ##                     "OTHERS:  insymbol"
|                         END;
|                     (*UNTIL WE APPARENTLY LEAVE THE DECLARATION*)
|                 UNTIL syty IN [strgconst..whilesy,rparent,labelsy..exitsy,dosy..
| beginsy,
|                                loopsy..forwardsy];
|                 spaces := oldspacesmark;
|                 oldspaces := true;
|                 IF syty = rparent THEN
|                     insymbol
|                 ELSE
|                     error(missgrpar);
|                 END (*PARENTHESE*) ;
| 
|             BEGIN (*CASEDEF*)
|             variant_level := variant_level+1;
|             oldspacesmark := spaces;
|             IF NOT oldspaces THEN
|                 setlastspaces (spaces);
|             spaces := bufferptr - buffmark + lastspaces - syleng + 3;
|             declaring := true;
|             insymbol;
|             declaring := false;
|             REPEAT
|                 IF syty = lparent THEN
|                     parenthese
|                 ELSE
|                     insymbol
|             UNTIL syty IN [untilsy..exitsy,labelsy..endsy,rparent,dosy..beginsy]
| ;
|             spaces := oldspacesmark;
|             variant_level := variant_level-1;
|             END (*CASEDEF*) ;
| 
|         BEGIN (*RECDEF*)
|         oldspacesmark := spaces;
|         setlastspaces(spaces);
|         spaces := bufferptr - buffmark + spaces - syleng - 2 + feed;
|         declaring := true;
|         insymbol;
|         REPEAT
| ##          IF  NOT(syty IN [casesy, recordsy, semicolon, lparent,
| ##                       eqlsy, colon])  THEN  insymbol
| ##          ELSE
|             CASE syty OF
|                 casesy   : casedef;
|                 recordsy : recdef;
|                 semicolon, lparent:
|                                  BEGIN
|                                  declaring := true;
|                                  insymbol;
|                                  END;
|                 eqlsy, colon:
|                            BEGIN
|                            declaring := false;
|                            insymbol;
|                            END;
| ##            " OTHERS   : insymbol "
|                 END;
|         UNTIL syty IN [untilsy..exitsy,labelsy..endsy,dosy..beginsy];
|         oldspaces := true;
|         lastspaces := spaces - feed;
|         spaces := oldspacesmark;
|         IF syty = endsy THEN
|             begin
|             declaring := true;
|             insymbol;
|             end
|         ELSE
|             error(missgenduntil);
|         END (*RECDEF*) ;
|         (*STATEMENT[*) (*AND ITS PARTS*) (*]*)
| 
| 
|     PROCEDURE statement;
|         VAR
|             oldspacesmark,           (*SPACES AT ENTRY OF THIS PROCEDURE*)
|             curblocknr : integer;     (*CURRENT BLOCKNUMBER*)
| 
| 
|         PROCEDURE endedstatseq(endsym: symbol;  markch: char);
|             BEGIN
|             statement;
|             WHILE syty = semicolon DO
|                 BEGIN
|                 insymbol;
|                 statement;
|                 END;
|             WHILE NOT (syty IN [endsym,eobsy,proceduresy,functionsy]) DO
|                 BEGIN
|                 error(enderrinblkstr);
|                 IF NOT (syty IN begsym) THEN
|                     insymbol;
|                 statement;
|                 WHILE syty = semicolon DO
|                     BEGIN
|                     insymbol;
|                     statement;
|                     END;
|                 END;
|             IF forcing THEN
|                 writeline(bufferptr-syleng);
|             emarktext := markch;
|             emarknr := curblocknr;
|             IF (endsym = endsy) THEN
|                 IF indentbegin = 0 THEN
|                     setlastspaces(spaces-begexd)
|                 ELSE
|                     setlastspaces(spaces-indentbegin)
|             ELSE
|                 setlastspaces(spaces - feed);
|             IF syty <> endsym THEN
|                 error(missgenduntil);
|             END (*ENDEDSTATSEQ*);
| 
| 
|         PROCEDURE compstat;
|             BEGIN (*COMPSTAT*)
|             IF indentbegin = 0 THEN
|                 IF NOT oldspaces THEN
|                     setlastspaces (spaces-begexd)
|                 ELSE
|                     IF NOT oldspaces THEN
|                         setlastspaces (spaces - indentbegin);
|             bmarktext := 'B';
|             insymbol;
|             IF forcing THEN
|                 writeline(bufferptr-syleng);
|             endedstatseq(endsy, 'E');
|             IF syty = endsy THEN
|                 BEGIN
|                 insymbol ;
|                 writeline(bufferptr-syleng);
|                 END;
|             END (*COMPSTAT*) ;
| 
| 
|         PROCEDURE casestat;
|             LABEL 333 ;
|             VAR
|                 oldspacesmark : integer;        (*SAVED VALUE OF 'SPACES'*)
| 
|             BEGIN (*CASESTAT*)
|             bmarktext := 'C';
|             IF NOT oldspaces THEN
|                 setlastspaces (spaces-feed);
|             insymbol;
|             statement;
|             IF syty = ofsy THEN
|                 writeline (bufferptr)
|             ELSE
|                 error (missgof);
| ##        " LOOP " REPEAT
|                 REPEAT
|                     REPEAT
|                         insymbol
|                     UNTIL syty IN [colon,functionsy..eobsy];
|                     IF syty = colon THEN
|                         BEGIN
|                         oldspacesmark := spaces;
|                         lastspaces := spaces;
|                         spaces := bufferptr - buffmark + spaces - 4;
|                         oldspaces := true;
|                         thendo := true;
|                         insymbol;
|                         statement;
|                         spaces := oldspacesmark;
|                         END;
|                 UNTIL syty IN endsym;
| ##        " EXIT"IF syty IN [endsy,eobsy,proceduresy,functionsy] THEN GOTO 333;
|                 error (enderrinblkstr);
| ##              UNTIL FALSE "END";
| ##        333:
|             writeline(bufferptr-syleng);
|             emarktext := 'E';
|             emarknr := curblocknr;
|             IF syty = endsy THEN
|                 BEGIN
|                 insymbol ;
|                 writeline(bufferptr-syleng);
|                 END
|             ELSE
|                 error (missgenduntil);
|             END (*CASESTAT*) ;
| 
| 
|         PROCEDURE loopstat;
|             BEGIN (*LOOPSTAT*)
|             bmarktext := 'L';
|             IF NOT oldspaces THEN
|                 setlastspaces (spaces - feed);
|             insymbol;
|             writeline(bufferptr-syleng);
|             statement;
|             WHILE syty = semicolon DO
|                 BEGIN
|                 insymbol;
|                 statement;
|                 END;
|             IF syty = exitsy THEN
|                 BEGIN
|                 writeline(bufferptr-syleng);
|                 oldspaces := true;
|                 lastspaces := spaces-feed;
|                 emarktext := 'X';
|                 emarknr := curblocknr;
|                 insymbol; insymbol;
|                 END
|             ELSE
|                 error(missgexit);
|             endedstatseq(endsy, 'E');
|             IF syty = endsy THEN
|                 BEGIN
|                 insymbol ;
|                 writeline(bufferptr-syleng);
|                 END;
|             END (*LOOPSTAT*) ;
| 
| 
|         PROCEDURE ifstat;
|             VAR
|                 oldspacesmark: integer;
| 
|             BEGIN
|             oldspacesmark := spaces;
|             bmarktext := 'I';
|             IF NOT oldspaces THEN
|                 setlastspaces (spaces - feed);
|             (*DON'T INDENT THE 'IF'*)
|             (*MAKE 'THEN' AND 'ELSE' LINE UP WITH 'IF' UNLESS ON SAME LINE*)
|             spaces := lastspaces + bufferptr - buffmark + feed - 4;
|             insymbol;
|             statement; (*WILL EAT THE EXPRESSION AND STOP ON A KEYWORD*)
|             IF syty = thensy THEN
|                 BEGIN
|                 IF NOT oldspaces THEN
|                     setlastspaces (spaces-feed);
|                 emarktext := 'T';
|                 emarknr := curblocknr;
|                 IF forcing THEN
|                     writeline(bufferptr)
|                 ELSE
|                     thendo := true;
|                 (*SUPPRESS FURTHER INDENTATION FROM A 'DO'*)
|                 insymbol;
|                 statement;
|                 END
|             ELSE
|                 error (missgthen);
|             IF syty = elsesy THEN
|                 BEGIN
|                 writeline(bufferptr-syleng);
|                 emarktext := 'S';
|                 emarknr := curblocknr;
|                 IF NOT oldspaces THEN
|                     setlastspaces (spaces-feed);
|                 IF forcing THEN
|                     writeline(bufferptr)
|                 ELSE
|                     thendo := true;
|                 insymbol;
|                 statement;
|                 END;
|             oldspaces := true; (*PRESERVE INDENTATION OF STATEMENT*)
|             writeline(bufferptr-syleng);
|             spaces := oldspacesmark;
|             END (*IFSTAT*) ;
| 
| 
|         PROCEDURE labelstat;
|             BEGIN (*LABELSTAT*)
|             lastspaces := level * feed;
|             oldspaces := true;
|             insymbol;
|             writeline(bufferptr-syleng);
|             END (*LABELSTAT*) ;
| 
| 
|         PROCEDURE repeatstat;
|             BEGIN
|             bmarktext := 'R';
|             IF NOT oldspaces THEN
|                 setlastspaces (spaces - feed);
|             insymbol;
|             endedstatseq(untilsy, 'U');
|             IF syty = untilsy THEN
|                 BEGIN
|                 insymbol;
|                 statement;
|                 writeline(bufferptr-syleng);
|                 END;
|             END (*REPEATSTAT*) ;
| 
|         BEGIN (*STATEMENT*)
|         oldspacesmark := spaces; (*SAVE THE INCOMING VALUE OF SPACES TO BE ABLE
| TO RESTORE  IT*)
|         IF syty = intconst THEN
|             BEGIN
|             insymbol;
|             IF syty = colon THEN
|                 labelstat;
|             END;
|         IF syty IN begsym THEN
|             BEGIN
|             blocknr := blocknr + 1;
|             curblocknr := blocknr;
|             bmarknr := curblocknr;
|             IF NOT thendo THEN
|                 BEGIN
|                 writeline(bufferptr-syleng);
|                 IF (syty <> beginsy) THEN
|                     spaces := spaces + feed
|                 ELSE
|                     spaces:=spaces + indentbegin;
|                 END;
|             CASE syty OF
|                 beginsy : compstat;
|                 loopsy  : loopstat;
|                 casesy  : casestat;
|                 ifsy    : ifstat;
|                 repeatsy: repeatstat
|                 END;
|             END
|         ELSE
|             BEGIN
|             IF forcing THEN
|                 IF syty IN [forsy,whilesy] THEN
|                     writeline(bufferptr-syleng);
|             IF syty = gotosy THEN
|                 gotoinline:=true;
|             WHILE NOT (syty IN [semicolon,functionsy..recordsy]) DO
|                 insymbol;
|             IF syty = dosy THEN
|                 BEGIN
|                 IF NOT thendo THEN
|                     BEGIN
|                     setlastspaces(spaces);
|                     spaces := spaces + feed;
|                     IF NOT forcing THEN
|                         thendo := true;
|                     END;
|                 insymbol;
|                 statement;
|                 writeline(bufferptr-syleng);
|                 END;
|             END;
|         spaces := oldspacesmark;
|         END (*STATEMENT*) ;
| 
|         (*]BLOCK*)
| 
|     BEGIN (*BLOCK*)
|     REPEAT
|         insymbol
|     UNTIL syty IN relevantsym;
|     level := level + 1;
|     curproc := listptr;
|     spaces := level * feed;
|     (*HANDLE NESTING LIST*)
|     locprocstl := procstrucf;
| ##IF procstrucdata.exists then      (*** BUG 2 ***)
|     WITH procstrucdata, item, procname@ DO
| ##    (*IF exists THEN*)
|             BEGIN
|             IF procdata <> NIL THEN
|                 BEGIN
|                 IF externflag = 'F' THEN
|                     procdata := NIL
|                 ELSE
|                     IF externflag = ' ' THEN
|                         externflag := 'D';
|                 locprocstl := procdata;
|                 END;
|             IF procdata = NIL THEN
|                 BEGIN
|                 IF (syty IN [forwardsy,externsy]) THEN
|                     IF syty = externsy THEN
|                         externflag := 'E'
|                     ELSE
|                         externflag := 'F';
|                 new(procstrucl@.nextproc);
|                 procstrucl := procstrucl@.nextproc;
|                 procdata := procstrucl;
|                 procstrucl@ := item;
|                 locprocstl := procstrucl;
|                 END;
|             procstrucdata.exists := false
|             END;
|     REPEAT
|         fwddecl := false;
|         WHILE syty IN decsym DO
|             BEGIN
|             writeline(bufferptr-syleng);
|             setlastspaces(spaces-feed);
|             IF syty = programsy THEN
|                 BEGIN
|                 insymbol;
|                 prog_name := sy;
|                 procstrucf@.procname := listptr;
|                 listptr@.procdata := procstrucf;
|                 listptr@.profunflag := 'M';
|                 writeln(tty);
|                 write(tty,'1', version:8,new_name:7,' [',prog_name,']  1..');
|                 IF pagecnt > 1 THEN
|                     FOR i := 2 TO pagecnt DO
|                         write (tty, i:3,'..');
| ##               (* break(tty); *)
|                 declaring := false;
|                 END
|             ELSE
|                 BEGIN
|                 declaring := true;
|                 IF forcing THEN
|                     writeline(bufferptr);
|                 END;
|             REPEAT
|                 insymbol;
|                 CASE syty OF
|                     semicolon, lparent : declaring := true;
|                     eqlsy, colon : declaring := false;
|                     recordsy: recdef;
|                     END;
|             UNTIL syty IN relevantsym;
|             END;
|         WHILE syty IN prosym DO
|             BEGIN
|             writeline(bufferptr-syleng);
|             setlastspaces(spaces-feed);
|             IF syty <> initprocsy THEN
|                 BEGIN
|                 itisaproc := syty = proceduresy;
|                 declaring := true;
|                 insymbol;
|                 IF itisaproc THEN
|                     listptr@.profunflag := 'P'
|                 ELSE
|                     listptr@.profunflag := 'F';
|                 WITH procstrucdata, item DO
|                     BEGIN
|                     exists := true;
|                     procname := listptr;
|                     nextproc := NIL;
|                     linenr := linecnt+1;
|                     pagenr := pagecnt;
|                     proclevel := level;
|                     printed := false;
|                     firstcall := NIL;
|                     END;
|                 END;
|             block;
|             IF syty = semicolon THEN
|                 insymbol;
|             END;
|         (*FORWARD AND EXTERNAL DECLARATIONS MAY COME BEFORE 'VAR', ETC.*)
|     UNTIL NOT fwddecl;
|     IF forcing THEN
|         writeline(bufferptr-syleng);
|     level := level - 1;
|     spaces := level * feed;
|     IF NOT (syty IN [beginsy,forwardsy,externsy,eobsy,langsy]) THEN
|         BEGIN
|         IF (level = 0) AND (syty = point) THEN
|             nobody := true
|         ELSE
|             error (begerrinblkstr);
|         WHILE NOT (syty IN [beginsy,forwardsy,externsy,eobsy,langsy,point]) DO
|             insymbol
|         END;
|     IF syty = beginsy THEN
|         BEGIN
|         declaring := false;
|         locprocstl@.begline := linecnt + 1;
|         locprocstl@.begpage := pagecnt;
|         statement;
|         locprocstl@.endline := linecnt + 1;
|         locprocstl@.endpage := pagecnt;
|         END
|     ELSE
|         IF NOT nobody THEN
|             BEGIN
|             fwddecl := true;
|             insymbol;
|             IF syty = langsy THEN
|                 insymbol
|             END;
|     IF programpresent AND (level = 0) THEN
|         BEGIN
|         IF nobody THEN
|             BEGIN
|             error (missgmain);
|             errcount := errcount - 1;
|             END;
|         IF syty <> point THEN
|             BEGIN
|             error(missgpoint);
|             REPEAT (*SKIP TEXT UNTIL END OF FILE OR END OF PROGRAM HIT*)
|                 REPEAT
|                 insymbol UNTIL (syty = endsy) OR (syty = eobsy);
|                 IF syty = endsy THEN
|                     insymbol;
|             UNTIL (syty = point) OR (syty = eobsy);
|             END;
|         writeline(bufflen+2);
|         writeln(tty);
|         writeln(tty);
| ##      writeln (tty,errcount:4,' ERROR(S) DETECTED');    (* break(tty); *)
|         END;
|     END (*BLOCK*) ;
| 
| PROCEDURE print_xref_list;
|     VAR
|         pred : listptrty;
|         indexch : char;         (*LAUFVARIABLE FUER DAS FELD 'FIRSTNAME' ZUM AUS
| DRUCKEN*)
|         listpgnr : boolean;     (*TRUE IF THE SOURCE CONTAINS A PAGE MARK*)
|         itemlen: integer;        (*LENGTH OF A PRINTED LINENUMBER, 9 OR 12*)
|         thiscall : calledty;
|         oldcrossing: boolean;
| 
| 
|     PROCEDURE checkpage(heading: boolean);
|         BEGIN
|         IF reallincnt = maxline THEN
|             BEGIN
|             IF heading THEN
|                 header (listptr@.name)
|             ELSE
|                 header (blanks);
|             END;
|         reallincnt:=reallincnt+1;
|         END(*CHECKPAGE*);
| 
|     PROCEDURE writeprocname (procstrucl: procstructy; depth: integer; mark: char
| ; numbering: boolean);
|         BEGIN (*WRITEPROCNAME*)
|         writeln(crosslist);
|         checkpage(false);
|         WITH procstrucl@, procname@ DO
|             BEGIN
|             IF numbering THEN
| ##              write (crosslist, linecnt * increment:6, '  ')
| ##          ELSE write(crosslist, linenr*increment:6, '  ') ;
| ##       (* IF depth > 2 THEN
|                 write (crosslist, '. ',dots:depth-2)
|             ELSE
| ##              write (crosslist, '.':depth);  *)
| ##          write  (crosslist, ' ': depth*3, name: 10, ' ':25-depth*3,
|                     ' (', profunflag, ')', mark:2, externflag:2
| ##                  ",chr(ht), linenr * increment : 8");
| ##          IF numbering then  write(crosslist, linenr*increment:10) ;
|             IF listpgnr OR (pagenr > 1) THEN
|                 write(crosslist, ' / ',pagenr : 1);
|             IF (mark = ' ') AND NOT ((externflag = 'E') OR
| ##                                   (externflag = 'F')) THEN
|                 BEGIN
|                 write (crosslist, begline * increment: 10);
|                 IF listpgnr THEN
|                     write (crosslist, ' / ', begpage: 1);
| ##              write (crosslist, endline * increment: 7);
|                 IF listpgnr THEN
|                     write (crosslist, ' / ', endpage:1);
|                 END;
|             END;
|         END (*WRITEPROCNAME*);
| 
|     PROCEDURE writelinenr (spaces : integer);
| 
|         VAR
|             link : lineptrty; (*ZEIGER ZUM DURCHHANGELN DURCH DIE VERKETTUNG DER
|  ZEILENNUMMERN*)
|             maxcnt,             (*MAXIMUM ALLOWABLE VALUE OF COUNT*)
|             count : integer;  (*ZAEHLT DIE GEDRUCKTEN ZEILENNUMMERN PRO ZEILE*)
|         BEGIN (*WRITELINENR*)
|         count := 0;
|         maxcnt := (maxch+20 - spaces) DIV itemlen; (*ITEMS ARE ITEMLEN CHARS EAC
| H*)
|         link := listptr@.first;
|         REPEAT
|             IF count = maxcnt THEN
|                 BEGIN
|                 writeln(crosslist);
|                 checkpage(true);
|                 write (crosslist, ' ' : spaces);
|                 count := 0;
|                 END;
|             count := count + 1;
|             write (crosslist, link@.linenr * increment : 6);
|             IF listpgnr THEN
|                 write(crosslist, '/',link@.pagenr : 2);
|             write (crosslist,link@.declflag,'  ');
|             link := link@.contlink;
|         UNTIL link = NIL;
|         END (*WRITELINENR*) ;
| 
|     PROCEDURE dumpcall (thisproc: procstructy; depth: integer);
|         VAR
|             thiscall: calledty;
| 
|         BEGIN (*DUMPCALL*)
|         linecnt := linecnt + 1;
|         WITH thisproc@ DO
|             IF printed THEN
|                 writeprocname (thisproc, depth,'*', true)
|             ELSE
|                 BEGIN
|                 writeprocname (thisproc, depth, ' ', true);
|                 printed := true;
|                 linenr := linecnt;
|                 pagenr := pagecnt;
|                 thiscall := firstcall;
|                 WHILE thiscall <> NIL DO
|                     BEGIN
| ##                  dumpcall (thiscall@.whom, depth + "4"1);
|                     thiscall := thiscall@.nextcall;
|                     END;
|                 END;
|         END (*DUMPCALL*);
|         (*]PRINT_XREF_LIST*)
| 
|     BEGIN (*PRINT_XREF_LIST*)
|     oldcrossing := crossing;
|     crossing := true;
|     listpgnr := pagecnt > 1;
|     IF listpgnr THEN
|         itemlen := 12
|     ELSE
|         itemlen := 9;
|     WITH firstname ['M']@ DO  (*DELETE 'MAIN'*)
|         IF rlink = NIL THEN
|             firstname ['M'] := llink
|         ELSE
|             BEGIN
|             listptr := rlink;
|             WHILE listptr@.llink <> NIL DO
|                 listptr := listptr@.llink;
|             listptr@.llink := llink;
|             firstname ['M'] := rlink;
|             END;
|     indexch := 'a';
|     WHILE (indexch < 'Z') AND (firstname [indexch] = NIL) DO
|         indexch := succ (indexch);
|     IF firstname [indexch] <> NIL THEN
|         BEGIN
|         IF refing THEN
|             BEGIN
|             pagecnt := pagecnt + 1;
|             pagecnt2 := 0;
|             header (blanks);
|             writeln (crosslist,
|                      ' CROSS REFERENCE LISTING OF IDENTIFIERS   ':46) ;
|             writeln (crosslist,
|                      ' **************************************   ':46) ;
|             reallincnt:= reallincnt + 3;
|             FOR indexch := indexch TO 'Z' DO
|                 WHILE firstname [indexch] <> NIL DO
|                     BEGIN
|                     listptr := firstname [indexch];
|                     WHILE listptr@.llink <> NIL DO
|                         BEGIN
|                         pred := listptr;
|                         listptr := listptr@.llink;
|                         END;
|                     IF listptr = firstname [indexch] THEN
|                         firstname [indexch] := listptr@.rlink
|                     ELSE
|                         pred@.llink := listptr@.rlink;
|                     writeln(crosslist);
|                     checkpage(true);
|                     write (crosslist, listptr@.profunflag, listptr@.name : 11);
|                     writelinenr (12);
|                     END;
| ##          writeln(crosslist) ;
|             END;
| 
|         IF procstrucl <> procstrucf THEN
|             BEGIN
|             IF decnesting THEN
|                 BEGIN
|                 pagecnt := pagecnt + 1;
|                 pagecnt2 := 0;
|                 writeln (crosslist);
|                 header (blanks);
|                 writeln (crosslist,
|                          ' NESTING OF PROCEDURE-FUNCTION DECLARATION':46) ;
|                 writeln (crosslist,
|                          ' *****************************************':46) ;
|                 writeln (crosslist,
|                          ' HEADERLINE, NAME, P/F, BEGINLINE, ENDLINE':46) ;
|                 reallincnt:= reallincnt + 4;
|                 procstrucl := procstrucf;
|                 REPEAT
| ##                  writeprocname (procstrucl, procstrucl@.proclevel"* 2",' ',
| false);
|                     procstrucl := procstrucl@.nextproc;
|                 UNTIL procstrucl = NIL;
|                 END;
|             IF callnesting THEN
|                 BEGIN
|                 pagecnt := pagecnt + 1;
|                 pagecnt2 := 0;
|                 writeln (crosslist);
|                 header (blanks);
|                 writeln (crosslist,
|                          ' NESTING OF PROCEDURE-FUNCTION CALLS      ':46);
|                 writeln (crosslist,
|                          ' ***********************************      ':46);
|                 writeln (crosslist,
|                          ' NAME, P/F, HEADLINE, BEGINLINE, ENDLINE  ':46) ;
|                 reallincnt := reallincnt + 4;
|                 linecnt := 0;
|                 procstrucl := procstrucf;
|                 WHILE procstrucl <> NIL DO
|                     BEGIN
|                     IF NOT procstrucl@.printed THEN
|                         dumpcall (procstrucl, 0);
|                     procstrucl := procstrucl@.nextproc;
|                     END;
|                 END;
| ##          writeln(crosslist) ;
|             END;
|         END;
|     crossing := oldcrossing;
|     END (*PRINT_XREF_LIST*) ;
| 
|     (*MAIN PROGRAM*)
| 
| BEGIN
| # RESET(OLDSOURCE) ;
| # REWRITE(NEWSOURCE);
| # REWRITE(CROSSLIST) ;
| # REWRITE(TTY) ;
| checkoptions;
| ##"getstatus(oldsource,new_name,new_prot,new_ppn,new_dev);"
| 
| (*FIND MAX POSSIBLE LINE NUMBER WITH THIS INCREMENT*)
| ##increment := 1 ;
| maxinc := (99999 DIV increment);
| IF maxinc > 4000 THEN
|     maxinc := 4000;
| 
| ##"LOOP" REPEAT
|     init;
|     block;
| ##"EXIT" IF NOT programpresent OR (syty = eobsy) THEN GOTO 444;
|     IF refing OR decnesting OR callnesting THEN
|         print_xref_list;
| ##  "dispose(heapmark);"    (*RELEASE THE ENTIRE HEAP*)
|     rtime[0]:=clock(1)-rtime[0];
|     rtime[1]:=rtime[0] DIV 60000;
|     rtime[2]:=(rtime[0] MOD 60000) DIV 1000;
|     rtime[3]:=rtime[0] MOD 1000;
|     writeln(tty);
|     writeln(tty,' RUNTIME:',rtime[1]:3,':',rtime[2]:2,'.',rtime[3]:3);
| ##   (* break(tty); *)
| ##  UNTIL FALSE "END";
| ##  444:
| ##   (* writeln(tty, bel);   break(tty); *)
| 
| ##  "getnextcall (link_name, link_device);
| ##   IF link_name <> '         ' THEN
| ##     call (link_name, link_device); "
| END (*PCROSS*).
> Member PEDITOR
| (*$N+,D-****************************************************************
| *                                                                      *
| *                                                                      *
| *   A LINE EDITOR FOR PASCAL                                           *
| *                                                                      *
| *       The EDITOR program is a simple text editor that can  insert,   *
| *   delete and replace entire lines in a file. PRD is the file to be   *
| *   edited,  INPUT  is  the  file  containing  editor  commands. The   *
| *   resulting edited file is transmitted to the PRR  file.  Messages   *
| *   and a summary of the changes are printed on the OUTPUT file.       *
| *       The INPUT file consists of commands and cards to be inserted   *
| *   into the PRD  file.  Commands  are  distinguished  by  having  a   *
| *   percent  character  in  column  one. Cards that do not have this   *
| *   character in column one are automatically inserted.                *
| *       There are only four commands. Three of the commands have  an   *
| *   operand  consisting  of an arbitrary string of characters. These   *
| *   text string operands are "matched" against cards read  from  the   *
| *   PRD  file.  The  definition  of  "match" will be given after the   *
| *   commands are explained.                                            *
| *                                                                      *
| *   Find Line Command: %FL <text>                                      *
| *       Cards are copied from the PRD file to the PRR  file,  up  to   *
| *   and including the first card that "matches" <text>.                *
| *                                                                      *
| *   Replace Line Command: %RL <text>                                   *
| *       Cards are copied fom the PRD file to the PRR file, up to but   *
| *   not including the first card that "matches" <text>. That is, the   *
| *   card that matches is effectively deleted.                          *
| *                                                                      *
| *   Delete Lines Command: %DL <text>                                   *
| *       Cards are read from the PRD file, up to  and  including  the   *
| *   first  card  that  "matches" <text>. These cards are effectively   *
| *   deleted because they are not passed on to the PRR file.            *
| *                                                                      *
| *   End of Editing Command: %END                                       *
| *       All remaining cards in the PRD file are copied  to  the  PRR   *
| *   file.                                                              *
| *                                                                      *
| *   The <text> operand of a command "matches" a card read  from  PRD   *
| *   if that card begins with the exact same character sequence given   *
| *   in  <text>.  Blanks  are  totally  ignored,  in  both the <text>   *
| *   operand  and  the  PRD  card,  when   making   the   comparison.   *
| *   Furthermore,  some  character  equivalences  are  acceptable (in   *
| *   case the INPUT file is entered  from  a  device  that  does  not   *
| *   support the special characters). The equivalences are:             *
| *       Upper-case letters in INPUT match corresponding                *
| *                     lower-case letters in PRD                        *
| *       "(/" in INPUT matches "[" (left square bracket) in PRD         *
| *       "/)" in INPUT matches "]" (right square bracket) in PRD        *
| *       "(*" in INPUT matches "¯" (left brace) in PRD                  *
| *       "*)" in INPUT matches "ò" (right brace) in PRD                 *
| *       "" (i.e. nothing) in INPUT matches "#" in PRD                  *
| *   It should be noted that these equivalences are defined  to  work   *
| *   in one direction only.  That is, a left square bracket in a text   *
| *   operand will not match "(/" occurring  in  the  PRD  file.   The   *
| *   meaning  of the last equivalence above is that the "#" character   *
| *   in the PRD file is ignored if it does not match  a  "#"  in  the   *
| *   <text> operand.                                                    *
| *       It is an error if no card is found in  PRD  that  matches  a   *
| *   <text>  operand. The EDITOR program will print a warning message   *
| *   and return a non-zero return code to signal this  event.  It  is   *
| *   mandatory  that  the  last  card  in  the  INPUT  file be a %END   *
| *   command.                                                           *
| *                                                                      *
| *         An Example Editing Session                                   *
| *                                                                      *
| *   1. The Editing Commands in the INPUT file:                         *
| *                                                                      *
| *       %FL I := I                                                     *
| *          J := J + 1;                                                 *
| *          K := K + 1;                                                 *
| *       %RL A(/K                                                       *
| *          A(/K/) := CHR(K);                                           *
| *       %FL WRI                                                        *
| *       %FL WRI                                                        *
| *       %DL CALL                                                       *
| *          WRITELN ( 'A3 =', A(/K/) );                                 *
| *          EXIT( 10 );                                                 *
| *       %END                                                           *
| *                                                                      *
| *   2. The Contents of the PRD File:                                   *
| *                                                                      *
| *       PROGRAM NONSENSE( OUTPUT );                                    *
| *       VAR I,J,K: INTEGER; A: ARRAY[1..3] OF CHAR;                    *
| *       BEGIN                                                          *
| *          I := 0; J := 1; K := 2;                                     *
| *          I := I + 1;                                                 *
| *          A[I] := CHR(I);                                             *
| *          A[J] *= CHR(J);                                             *
| *          A[K] *= ORD(K);                                             *
| *          WRITELN( 'A1 =', A[1] );                                    *
| *          WRITELN( 'A2 =', A[2] );                                    *
| *          WRITELN( 'A3 =', A[3] );                                    *
| *          CALL EXIT(10);                                              *
| *       END.                                                           *
| *                                                                      *
| *   3. Resulting Output to PRR File:                                   *
| *                                                                      *
| *       PROGRAM NONSENSE( OUTPUT );                                    *
| *       VAR I,J,K: INTEGER; A: ARRAY[1..3] OF CHAR;                    *
| *       BEGIN                                                          *
| *          I := 0; J := 1; K := 2;                                     *
| *          I := I + 1;                                                 *
| *          J := J + 1;                                                 *
| *          K := K + 1;                                                 *
| *          A[I] := CHR(I);                                             *
| *          A[J] := CHR(J);                                             *
| *          A(/K/) := CHR(K);                                           *
| *          WRITELN( 'A1 =', A[1] );                                    *
| *          WRITELN( 'A2 =', A[2] );                                    *
| *          WRITELN( 'A3 =', A(/K/) );                                  *
| *          EXIT( 10 );                                                 *
| *       END.                                                           *
| *                                                                      *
| *   Comments:                                                          *
| *       As can be seen in the example, %FL is used to search through   *
| *   the PRD file. When there are many lines in PRD that  begin  with   *
| *   similar text, two or more %FL commands can be used successively.   *
| *   Generally,  %FL  is used to locate a position at which cards are   *
| *   to be inserted or from which lines are to be deleted.              *
| *       %RL is actually a redundant command  -  its  effect  can  be   *
| *   obtained   with  %FL  and  %DL  commands.  However  it  is  most   *
| *   convenient when a single line in PRD is to be deleted or  to  be   *
| *   replaced  by  one  or  more  cards from INPUT. It should also be   *
| *   apparent from the command descriptions that the commands must be   *
| *   presented in  the  correct  order.  I.e.,  all  the  editing  is   *
| *   performed in a single pass through PRD.                            *
| *                                                                      *
| *                                                                      *
| *                                      R. Nigel Horspool               *
| *                                                                      *
| *                                      School of Computer Science      *
| *                                      McGill University               *
| *                                                                      *
| *                                                                      *
| ***********************************************************************)
| 
| 
| PROGRAM EDITOR(INPUT,OUTPUT,PRD,PRR);
| CONST   CARDLEN = 80;
|         CONTROL = '%';
| 
| TYPE    CARD = ARRAY(/ 1 .. CARDLEN /) OF CHAR;
|         CHAR_TYPE = (NULL,LOWER_CASE,LSQ,RSQ,LBRACE,RBRACE,SHARP);
| 
| VAR     SOURCE, EDITS : CARD;
|         CLASS :         ARRAY(/CHAR/) OF CHAR_TYPE;
|         EOF_OK        : BOOLEAN;
|         ERRS, INNUM, OUTNUM, PATLEN : INTEGER;
| 
| FUNCTION MATCH: BOOLEAN;
|   LABEL 10;
|   VAR   IX1, IX2: INTEGER;
|         CH1, CH2: CHAR;
|   BEGIN
|     MATCH := FALSE;  IX1 := 1;  IX2 := 4;
|     REPEAT
|        CH1 := SOURCE(/IX1/);  CH2 := EDITS(/IX2/);
|        IF CH2 = ' ' THEN IX2 := IX2 + 1
|        ELSE IF CH1 = ' ' THEN IX1 := IX1 + 1
|        ELSE BEGIN
|           IF CH1 <> CH2 THEN
|              CASE CLASS(/CH1/) OF
|     LOWER_CASE:  IF (ORD(CH2)-ORD(CH1)) <> 64 THEN GOTO 10;
|     LSQ:         IF CH2 <> '(' THEN GOTO 10 ELSE IX2 := IX2 + 1;
|     RSQ:         IF CH2 <> '/' THEN GOTO 10 ELSE IX2 := IX2 + 1;
|     LBRACE:      IF CH2 <> '(' THEN GOTO 10 ELSE IX2 := IX2 + 1;
|     RBRACE:      IF CH2 <> '*' THEN GOTO 10 ELSE IX2 := IX2 + 1;
|     SHARP:       IX2 := IX2 - 1;
|     NULL:        GOTO 10
|              END;
|           IX1 := IX1 + 1;  IX2 := IX2 + 1;
|        END;
|     UNTIL (IX1 > CARDLEN) OR (IX2 > PATLEN);
|     IF IX2 > PATLEN THEN MATCH := TRUE;
| 10:
|   END (* MATCH *) ;
| 
| PROCEDURE INITIALIZE;
| VAR C : CHAR;
| BEGIN
|    FOR C := CHR(0) TO CHR(255) DO CLASS(/C/) := NULL;
|    FOR C := 'a' TO 'i' DO CLASS(/C/) := LOWER_CASE;
|    FOR C := 'j' TO 'r' DO CLASS(/C/) := LOWER_CASE;
|    FOR C := 's' to 'z' DO CLASS(/C/) := LOWER_CASE;
|    CLASS(/ CHR(173) /) := LSQ;     CLASS(/ CHR(189) /) := RSQ;
|    CLASS(/ CHR(139) /) := LBRACE;  CLASS(/ CHR(155) /) := RBRACE;
|    CLASS(/ '#' /) := SHARP;
| END;
| 
| BEGIN
|   ERRS := 0;  INNUM := 0;  OUTNUM := 0;  EOF_OK := FALSE;
|   INITIALIZE;
|   REPEAT
|     READLN(INPUT,EDITS);
|     IF EDITS(/1/) = CONTROL THEN
|        BEGIN
|           WRITELN();  WRITELN(' %% CONTROL CARD : ', EDITS );
|           PATLEN := CARDLEN;
|           WHILE EDITS(/PATLEN/) = ' ' DO PATLEN := PATLEN - 1;
|           IF EDITS(/2/) = 'D' THEN  (* DL COMMAND *)
|              REPEAT
|                 READLN(PRD,SOURCE);  INNUM := INNUM + 1;
|                 WRITELN(' -- DELETED  (',INNUM:5,') ------- ×',
|                      SOURCE,'× --' );
|              UNTIL MATCH OR EOF(PRD)
|           ELSE IF EDITS(/2/) = 'F' THEN (* FL COMMAND *)
|              REPEAT
|                 READLN(PRD,SOURCE);  INNUM := INNUM + 1;
|                 WRITE(PRR,SOURCE); OUTNUM := OUTNUM + 1;
|              UNTIL MATCH OR EOF(PRD)
|           ELSE IF EDITS(/2/) = 'R' THEN (* RL COMMAND *)
|              BEGIN
|                 READLN(PRD,SOURCE);  INNUM := INNUM + 1;
|                 WHILE NOT MATCH AND NOT EOF(PRD) DO
|                    BEGIN
|                       WRITE(PRR,SOURCE);  OUTNUM := OUTNUM + 1;
|                       READLN(PRD,SOURCE);   INNUM  := INNUM  + 1;
|                    END;
|                 IF NOT EOF(PRD) THEN
|                    WRITELN(' -- DELETED  (',INNUM:5,') ------- ×',
|                            SOURCE,'× --');
|             END
|           ELSE IF EDITS(/2/) = 'E' THEN (* END COMMAND *)
|              BEGIN
|                 REPEAT
|                    READLN(PRD,SOURCE);  INNUM := INNUM + 1;
|                    WRITE(PRR,SOURCE); OUTNUM := OUTNUM + 1;
|                 UNTIL EOF(PRD);
|                 EOF_OK := TRUE;
|              END
|           ELSE BEGIN
|              WRITELN(' ***** BAD CONTROL CARD - IGNORED.');
|              WRITELN();  ERRS := ERRS + 1;
|           END
|        END
|     ELSE BEGIN  (* INSERTED CODE *)
|        WRITE(PRR,EDITS);  OUTNUM := OUTNUM + 1;
|        WRITELN(' ++ INSERTED +++++++ (',OUTNUM:5,') ×',EDITS,'× ++' );
|     END;
|   UNTIL EOF(PRD) OR EOF(INPUT);
| 
|   WRITELN();
|   IF NOT EOF_OK THEN
|      BEGIN
|        IF EOF(PRD) THEN
|           WRITELN(' ***** LINE PREFIX NOT FOUND IN SOURCE FILE');
|        IF EOF(INPUT) THEN
|           WRITELN(' ***** MISSING %END CARD IN EDIT FILE');
|        ERRS := ERRS + 1;
|      END;
|   WRITELN;  WRITELN(' * EDITING FINISHED;', INNUM:7, ' CARDS INPUT;',
|                      OUTNUM:7, ' CARDS OUTPUT.' );
|   EXIT( ERRS );
| END.
> Member PFORMAT
|  (*************************************************************
|   *                                                           *
|   *      P A S C A L   P R O G R A M   F O R M A T T E R      *
|   *      -----------------------------------------------      *
|   *                                                           *
|   *             COPYRIGHT MICHAEL N. CONDICT 1975             *
|   *                                                           *
|   *************************************************************)
|  PROGRAM FORMAT( (*PROG,*) OUTPUT, INPUT );
| 
|  CONST
|     LASTPSYMBOLNAME = 40;
|     BUFFERSIZE = 160;
|     BUFFERSZP1 = 161;
|     BUFFSZDIV10 = 16;
|     ALFLEN = 10;
| 
|  TYPE
|     chset = 0..63;
|     STATMNTTYPES =
|        (FORWITHWHILESTATEMENT, REPEATSTATEMENT, IFSTATEMENT,
|         CASESTATEMENT, COMPOUNDSTATEMENT, OTHERSTATEMENT);
|     SYMBOLS =
|        (PROGRAMSYMBOL, COMMENT, BEGINSYMBOL, ENDSYMBOL,
|         SEMICOLON, CONSTSYMBOL, TYPESYMBOL, RECORDSYMBOL,
|         COLONSYMBOL, EQUALSYMBOL, PERIODSYMBOL, RANGE,
|         CASESYMBOL, OTHERSYMBOL, IFSYMBOL, THENSYMBOL,
|         ELSESYMBOL, DOSYMBOL, OFSYMBOL, FORSYMBOL, WITHSYMBOL,
|         WHILESYMBOL, REPEATSYMBOL, UNTILSYMBOL, IDENTIFIER,
|         VARSYMBOL, VALUESYMBOL, PROCEDSYMBOL, FUNCTIONSYMBOL,
|         LEFTBRACKET, RIGHTBRACKET, COMMASYMBOL, LABELSYMBOL,
|         LEFTPAREN, RIGHTPARENTH, UPARROW, ALPHAOPERATOR);
|     WIDTH = 0 .. BUFFERSIZE;
|     CHARTYPES =
|        (ALPHANUMERIC, ENDOFLINE, BLANK, RIGHTARROW, SLASH,
|         LFTPAREN, COLON, PERIOD, STRING, LESSTHAN, GREATERTHAN,
| "SZH"   STAR, DQUOTE, OTHER);
|     MARGINS = - 100 .. BUFFERSIZE;
|     SYMBOLSET = SET OF SYMBOLS;
|     OPTIONSIZE = - 99 .. 99;
|     COMMENTTEXT = ARRAY [1 .. BUFFSZDIV10] OF ALFA;
|     SYMBOLSTRING = ARRAY [WIDTH] OF CHAR;
| 
|  VAR
|     READINGFORMATOPTIONS, PROGISPASCAL2: BOOLEAN;
|     PROG: TEXT;
|     I: INTEGER;
|  (*USED AS FOR LOOP INDEX*)
|     CHARACTER: CHAR;
|     READCOLUMN, READCOL2: 0 .. 1000;
|     OUTPUTCOL, WRITECOLUMN, LEFTMARGIN, ACTUALLEFTMARGIN:
|        MARGINS;
|     READCOL1, WRITECOL1, WRITECOL2: MARGINS;
|     DISPLAYISON, PROCEDNAMESWANTED, ENDCOMMENTSWANTED,
|        PACKERISOFF, SAVEDCOMPRESS, COMPRESSWANTED, NOFORMATTING,
|        DISPLAYWANTED, CROSSREFWANTED: BOOLEAN;
|     LINENUMBER, INCREMENT: - 999 .. 999;
|     INDENTINDEX, LONGLINEINDENT, SYMBOLGAP, DECLARALIGNMENT,
|        STATMTSEPARATION, PROCEDSEPARATION: OPTIONSIZE;
|     LASTSYMBOL, SYMBOLNAME: SYMBOLS;
|     ALPHASYMBOLS, ENDLABEL, ENDCONST, ENDTYPE, ENDVAR, ENDVALUE:
|        SYMBOLSET;
|     SYMBOL: SYMBOLSTRING;
|     LENGTH: WIDTH;
| "SZH"  FIRSTDQUOTE,
|     SYMBOLISNUMBER, LASTPROGPARTWASBODY: BOOLEAN;
|     DIGITS: SET OF CHSET;
|     OLDEST: WIDTH;
|     CHARCOUNT: INTEGER (* USED AS A TOTAL CHARACTERS COUNT*);
|     MAIN: COMMENTTEXT;
|     MAINNMLENGTH: WIDTH;
|     BLANKS, ZEROES: ALFA;
|     UNWRITTEN: ARRAY [WIDTH] OF RECORD
|                                    CH: CHAR;
|                                    CHISENDLINE: BOOLEAN;
|                                    INDENTAFTEREOL: MARGINS;
|                                 END;
|     TYPEOF: ARRAY [CHAR] OF CHARTYPES;
|     PASCALSYMBOL: ARRAY [1 .. LASTPSYMBOLNAME] OF ALFA;
|     PSYMBOLNAME: ARRAY [1 .. LASTPSYMBOLNAME] OF SYMBOLS;
|     NAMEOF: ARRAY [CHAR] OF SYMBOLS;
|     STATEMENTTYPEOF: ARRAY [SYMBOLS] OF STATMNTTYPES;
| "szh"  CHMAP   : ARRAY [CHAR] OF 0..63  ;  (*CHAR CODE CONVERSION           *)
| "szh"  PQ      : INTEGER;
| 
| 
| "szh"procedure init_chmap;
| "szh"
| "szh"   (* this routine initializes the ebcdic to 'CCDC' display code MAP *)
| "szh"   (* chmap : array[char] of 0..63                                   *)
| "szh"
| "szh"   const ordmaxch= 255;
| "szh"
| "szh"   var ch: char;
| "szh"
| "szh"   BEGIN
| "szh"
| "szh"    FOR ch := chr(0) TO chr(ORDMAXCH) DO CHMAP[ch] := 0;
| "szh"    FOR CH := 'A' TO 'I' DO  CHMAP[CH] := ORD(CH)-192 ;
| "szh"    FOR CH := 'J' TO 'R' DO  CHMAP[CH] := ORD(CH)-199 ;
| "szh"    FOR CH := 'S' TO 'Z' DO  CHMAP[CH] := ORD(CH)-207 ;
| "szh"    FOR CH := 'a' TO 'i' DO  CHMAP[CH] := ORD(CH)-128 ;
| "szh"    FOR CH := 'j' TO 'r' DO  CHMAP[CH] := ORD(CH)-135 ;
| "szh"    FOR CH := 's' TO 'z' DO  CHMAP[CH] := ORD(CH)-143 ;
| "szh"    FOR CH := '0' TO '9' DO  CHMAP[CH] := ORD(CH)-213 ;
| "szh"    CHMAP['+']  :=  37 ;
| "szh"    CHMAP['-']  :=  38 ;
| "szh"    CHMAP['*']  :=  39 ;
| "szh"    CHMAP['/']  :=  40 ;
| "szh"    CHMAP['(']  :=  41 ;
| "szh"    CHMAP[')']  :=  42 ;
| "szh"    CHMAP['$']  :=  43 ;
| "szh"    CHMAP['=']  :=  44 ;
| "szh"    CHMAP[' ']  :=  45 ;
| "szh"    CHMAP[',']  :=  46 ;
| "szh"    CHMAP['.']  :=  47 ;
| "szh"    CHMAP['#']  :=  48 ;
| "szh"    CHMAP['[']  :=  49 ;
| "szh"    CHMAP[']']  :=  50 ;
| "szh"    CHMAP['%']  :=  51 ;
| "szh"    CHMAP['"']  :=  52 ;
| "szh"    CHMAP['_']  :=  53 ;
| "szh"    CHMAP['¯']  :=  54 ;      (* SHOULD BE '!' *)
| "szh"    CHMAP['&']  :=  55 ;
| "szh"    CHMAP[''''] :=  56 ;
| "szh"    CHMAP['ò']  :=  57 ;
| "szh"    CHMAP['<']  :=  58 ;
| "szh"    CHMAP['>']  :=  59 ;
| "szh"    CHMAP['@']  :=  60 ;
| "szh"    CHMAP[':']  :=  61 ;       (* SHOULD BE '0', 61 IS BACK SLASH *)
| "szh"    CHMAP['Ö']  :=  62 ;
| "szh"    CHMAP[';']  :=  63 ;
| "szh"
| "szh"   END (*init_chmap*);
| "szh"
|  PROCEDURE CONSTANTSINITIALIZATION;
| 
|     BEGIN
| "SZH"  FIRSTDQUOTE := FALSE;
|        MAIN[1] := 'MAIN      ';   MAINNMLENGTH := 4;
|        BLANKS := '          ';   ZEROES := '0000000000';
|        FOR I := 0 TO BUFFERSIZE DO
|           WITH UNWRITTEN[I] DO
|              BEGIN
|                 CH := 'A';   CHISENDLINE := FALSE;
|                 INDENTAFTEREOL := 0;
|              END;
|        FOR CHARACTER := CHR(0) TO CHR(255) DO
|           TYPEOF[CHARACTER] := OTHER;
|        TYPEOF[CHR(0)] := BLANK;
|        FOR CHARACTER := 'A' TO 'I' DO
|           TYPEOF[CHARACTER] := ALPHANUMERIC;
|        FOR CHARACTER := 'J' TO 'R' DO
|           TYPEOF[CHARACTER] := ALPHANUMERIC;
|        FOR CHARACTER := 'S' TO 'Z' DO
|           TYPEOF[CHARACTER] := ALPHANUMERIC;
|        FOR CHARACTER := '0' TO '9' DO
|           TYPEOF[CHARACTER] := ALPHANUMERIC;
|        TYPEOF['*'] := STAR;         TYPEOF['/'] := SLASH;
|        TYPEOF['('] := LFTPAREN;     TYPEOF[' '] := BLANK;
|        TYPEOF['.'] := PERIOD;       TYPEOF[''''] := STRING;
|        TYPEOF[':'] := COLON;
| "SZH"  TYPEOF['¯'] := RIGHTARROW;   TYPEOF['"'] := DQUOTE;
| "SZH"  TYPEOF['$'] := ALPHANUMERIC; TYPEOF['_'] := ALPHANUMERIC;
| "SZH"  TYPEOF['#'] := BLANK;
|        TYPEOF['<'] := LESSTHAN;     TYPEOF['>'] := GREATERTHAN;
| "SZH"  FOR CHARACTER := CHR(0) TO CHR(255) DO
|           NAMEOF[CHARACTER] := OTHERSYMBOL;
|        NAMEOF['('] := LEFTPAREN;
|        NAMEOF[')'] := RIGHTPARENTH;
|        NAMEOF['='] := EQUALSYMBOL;   NAMEOF[','] := COMMASYMBOL;
|        NAMEOF['.'] := PERIODSYMBOL;
|        NAMEOF['['] := LEFTBRACKET;
|        NAMEOF[']'] := RIGHTBRACKET;
|        NAMEOF[':'] := COLONSYMBOL;   NAMEOF['@'] := UPARROW;
| "SZH"  NAMEOF['ò'] := COMMENT;   NAMEOF['<'] := EQUALSYMBOL;
| "SZH"  NAMEOF['"'] := COMMENT;
|        NAMEOF['>'] := EQUALSYMBOL;   NAMEOF[';'] := SEMICOLON;
|        PASCALSYMBOL[1] := 'PROGRAM   ';
|        PASCALSYMBOL[21] := 'FUNCTION  ';
|        PASCALSYMBOL[2] := 'BEGIN     ';
|        PASCALSYMBOL[22] := 'LABEL     ';
|        PASCALSYMBOL[3] := 'END       ';
|        PASCALSYMBOL[23] := 'IN        ';
|        PASCALSYMBOL[4] := 'CONST     ';
|        PASCALSYMBOL[24] := 'MOD       ';
|        PASCALSYMBOL[5] := 'TYPE      ';
|        PASCALSYMBOL[25] := 'DIV       ';
|        PASCALSYMBOL[6] := 'VAR       ';
|        PASCALSYMBOL[26] := 'AND       ';
|        PASCALSYMBOL[7] := 'VALUE     ';
|        PASCALSYMBOL[27] := 'OR        ';
|        PASCALSYMBOL[8] := 'RECORD    ';
|        PASCALSYMBOL[28] := 'NOT       ';
|        PASCALSYMBOL[9] := 'CASE      ';
|        PASCALSYMBOL[29] := 'LT        ';
|        PASCALSYMBOL[10] := 'IF        ';
|        PASCALSYMBOL[30] := 'LE        ';
|        PASCALSYMBOL[11] := 'THEN      ';
|        PASCALSYMBOL[31] := 'IS        ';
|        PASCALSYMBOL[12] := 'ELSE      ';
|        PASCALSYMBOL[32] := 'ISNT      ';
|        PASCALSYMBOL[13] := 'DO        ';
|        PASCALSYMBOL[33] := 'EQ        ';
|        PASCALSYMBOL[14] := 'OF        ';
|        PASCALSYMBOL[34] := 'NE        ';
|        PASCALSYMBOL[15] := 'FOR       ';
|        PASCALSYMBOL[35] := 'GE        ';
|        PASCALSYMBOL[16] := 'WHILE     ';
|        PASCALSYMBOL[36] := 'GT        ';
|        PASCALSYMBOL[17] := 'WITH      ';
|        PASCALSYMBOL[37] := 'JOIN      ';
|        PASCALSYMBOL[18] := 'REPEAT    ';
|        PASCALSYMBOL[38] := 'MEET      ';
|        PASCALSYMBOL[19] := 'UNTIL     ';
|        PASCALSYMBOL[39] := 'ARRAY     ';
|        PASCALSYMBOL[20] := 'PROCEDURE ';
|        PASCALSYMBOL[40] := 'NOSYMBOL  ';
|        PSYMBOLNAME[1] := PROGRAMSYMBOL;
|        PSYMBOLNAME[21] := FUNCTIONSYMBOL;
|        PSYMBOLNAME[2] := BEGINSYMBOL;
|        PSYMBOLNAME[22] := LABELSYMBOL;
|        PSYMBOLNAME[3] := ENDSYMBOL;
|        PSYMBOLNAME[4] := CONSTSYMBOL;
|        PSYMBOLNAME[5] := TYPESYMBOL;
|        PSYMBOLNAME[6] := VARSYMBOL;
|        PSYMBOLNAME[7] := VALUESYMBOL;
|        PSYMBOLNAME[8] := RECORDSYMBOL;
|        PSYMBOLNAME[9] := CASESYMBOL;
|        PSYMBOLNAME[10] := IFSYMBOL;
|        PSYMBOLNAME[11] := THENSYMBOL;
|        PSYMBOLNAME[12] := ELSESYMBOL;
|        PSYMBOLNAME[13] := DOSYMBOL;   PSYMBOLNAME[14] := OFSYMBOL;
|        PSYMBOLNAME[15] := FORSYMBOL;
|        PSYMBOLNAME[16] := WHILESYMBOL;
|        PSYMBOLNAME[17] := WITHSYMBOL;
|        PSYMBOLNAME[18] := REPEATSYMBOL;
|        PSYMBOLNAME[19] := UNTILSYMBOL;
|        PSYMBOLNAME[20] := PROCEDSYMBOL;
|        PSYMBOLNAME[40] := IDENTIFIER;
|        FOR I := 23 TO 39 DO PSYMBOLNAME[I] := ALPHAOPERATOR;
|        FOR SYMBOLNAME := PROGRAMSYMBOL TO ALPHAOPERATOR DO
|           STATEMENTTYPEOF[SYMBOLNAME] := OTHERSTATEMENT;
|        STATEMENTTYPEOF[BEGINSYMBOL] := COMPOUNDSTATEMENT;
|        STATEMENTTYPEOF[CASESYMBOL] := CASESTATEMENT;
|        STATEMENTTYPEOF[IFSYMBOL] := IFSTATEMENT;
|        STATEMENTTYPEOF[FORSYMBOL] := FORWITHWHILESTATEMENT;
|        STATEMENTTYPEOF[WHILESYMBOL] := FORWITHWHILESTATEMENT;
|        STATEMENTTYPEOF[WITHSYMBOL] := FORWITHWHILESTATEMENT;
|        STATEMENTTYPEOF[REPEATSYMBOL] := REPEATSTATEMENT;
|     END (*CONSTANTSINITIALIZATION*);
| 
|  PROCEDURE WRITEA(CHARACTER: CHAR);
| 
|     VAR
|        I: WIDTH;
|        TESTNO: INTEGER;
| 
|     BEGIN
|        CHARCOUNT := CHARCOUNT + 1;
|        OLDEST := CHARCOUNT MOD BUFFERSIZE;
|        WITH UNWRITTEN[OLDEST] DO
|           BEGIN
|              IF CHARCOUNT > BUFFERSZP1
|              THEN
|                 BEGIN
|                    IF CHISENDLINE
|                    THEN
|                       BEGIN
|                          IF INDENTAFTEREOL < 0
|                          THEN
|                             BEGIN
|                                WRITE(OUTPUT, BLANKS: - INDENTAFTEREOL);
|                                OUTPUTCOL := OUTPUTCOL -
|                                   INDENTAFTEREOL;
|                             END
|                          ELSE
|                             BEGIN
|                                IF INCREMENT < 0
|                                THEN
|                                   BEGIN
|                                      I := WRITECOL2 - OUTPUTCOL
|                                         + 1;
|                                      IF I > 0
|                                      THEN WRITE(OUTPUT, BLANKS: I);
|                                      TESTNO := LINENUMBER;
|                                      I := 0;
|                                      REPEAT
|                                         TESTNO := TESTNO DIV 10;
|                                         I := I + 1;
|                                      UNTIL TESTNO = 0;
|                                      WRITE(OUTPUT, ZEROES: (6 - I),
|                                         LINENUMBER: I);
|                                      LINENUMBER := LINENUMBER -
|                                         INCREMENT;
|                                      IF LINENUMBER > 999999
|                                      THEN
|                                         LINENUMBER := LINENUMBER
|                                            - 1000000;
|                                      WRITELN(OUTPUT);  WRITE(OUTPUT, ' ');
|                                   END
|                                ELSE
|                                   BEGIN
|                                      WRITELN(OUTPUT, ' '); WRITE(OUTPUT, ' ');
|                                      IF INCREMENT > 0 THEN
|                                         BEGIN
|                                            WRITE(OUTPUT, LINENUMBER: (
|                                               WRITECOL1 - 2));
|                                            INDENTAFTEREOL :=
|                                               INDENTAFTEREOL -
|                                               WRITECOL1 + 2;
|                                            LINENUMBER :=
|                                               LINENUMBER +
|                                               INCREMENT;
|                                         END
|                                   END;
|                                IF INDENTAFTEREOL > 0 THEN
|                                   WRITE(OUTPUT, BLANKS: INDENTAFTEREOL);
|                                OUTPUTCOL := INDENTAFTEREOL + 1;
|                             END;
|                          CHISENDLINE := FALSE;
|                       END (*IF CHISENDLINE*)
|                    ELSE
|                       BEGIN
|                          WRITE(OUTPUT, CH);
|                          OUTPUTCOL := OUTPUTCOL + 1;
|                       END (*ELSE*);
|                 END (*IF CHARCOUNT > *);
|              CH := CHARACTER;   WRITECOLUMN := WRITECOLUMN + 1;
|           END (*WITH*);
|     END (*WRITEA*);
| 
|  PROCEDURE WRITEANEOLWITHNOINDENT;
| 
|     BEGIN
|        WRITEA(' ');
|        WITH UNWRITTEN[OLDEST] DO
|           BEGIN
|              CHISENDLINE := TRUE;
|              INDENTAFTEREOL := WRITECOL1 - 1;
|           END;
|        WRITECOLUMN := WRITECOL1;
|     END (*WRITEANEOLWITHNOINDENT*);
| 
|  PROCEDURE STARTNEWLINEANDINDENT;
| 
|     LABEL
|        1, 2;
| 
|     VAR
|        I: OPTIONSIZE;
| 
|     BEGIN
|        IF PACKERISOFF AND DISPLAYISON
|        THEN
|           BEGIN
|           2: WRITEA(' ');   1: LASTSYMBOL := PERIODSYMBOL;
|              WITH UNWRITTEN[OLDEST] DO
|                 BEGIN
|                    CHISENDLINE := TRUE;
|                    INDENTAFTEREOL := WRITECOL1 + LEFTMARGIN - 1;
|                 END;
|              WRITECOLUMN := WRITECOL1 + LEFTMARGIN;
|           END (*IF PACKERISOFF*);
|     END (*STARTNEWLINE*);
| 
|  PROCEDURE READACHARACTER;
| 
|     BEGIN
|        IF READCOLUMN > READCOL2
|        THEN
|           BEGIN
|              GET(PROG);
|              IF READCOL2 < 999
|              THEN BEGIN WHILE NOT EOLN(PROG) DO GET(PROG); END
|              ELSE READCOLUMN := 2;
|           END
|        ELSE
|           IF READCOLUMN <= 1
|           THEN
|              BEGIN
|                 IF READCOLUMN = 1   THEN GET(PROG)
|                 ELSE READCOLUMN := 1;
|                 WHILE READCOLUMN < READCOL1 DO
|                    BEGIN
|                       IF EOLN(PROG)   THEN READCOLUMN := 1
|                       ELSE READCOLUMN := READCOLUMN + 1;
|                       GET(PROG);
|                    END;
|              END
|           ELSE GET(PROG);
|        IF EOLN(PROG)
|        THEN
|           BEGIN
|              CHARACTER := ' ';   READCOLUMN := 1;
|              IF NOFORMATTING   THEN WRITEANEOLWITHNOINDENT;
|           END
|        ELSE
|           BEGIN
|              CHARACTER := PROG@;   READCOLUMN := READCOLUMN + 1;
|              IF NOFORMATTING   THEN WRITEA(CHARACTER);
|           END;
| 
| "SZH" IF CHARACTER = '"' THEN
| "SZH"    IF FIRSTDQUOTE THEN
| "SZH"       BEGIN  CHARACTER := 'ò';
| "SZH"       FIRSTDQUOTE := FALSE;
| "SZH"       END ;
| 
|     END (*READACHARACTER*);
| 
|  PROCEDURE WRITESYMBOL;
| 
|     VAR
|        I: WIDTH;
|        NUMBERBLANKSTOWRITE: OPTIONSIZE;
|        WRITEWIDTH, TOTALINDENT: WIDTH;
| 
|     BEGIN
|        IF DISPLAYISON
|        THEN
|           BEGIN
|              NUMBERBLANKSTOWRITE := SYMBOLGAP;
|              IF (LASTSYMBOL IN [LEFTPAREN, LEFTBRACKET,
|                 PERIODSYMBOL]) OR (SYMBOLNAME IN [SEMICOLON,
|                 RIGHTPARENTH, RIGHTBRACKET, COMMASYMBOL,
|                 PERIODSYMBOL, COLONSYMBOL]) OR (SYMBOLNAME IN [
|                 LEFTBRACKET, LEFTPAREN, UPARROW]) AND (
|                 LASTSYMBOL = IDENTIFIER)
|              THEN NUMBERBLANKSTOWRITE := 0
|              ELSE
|                 IF (SYMBOLNAME IN ALPHASYMBOLS) AND (LASTSYMBOL
|                    IN ALPHASYMBOLS)
|                 THEN
|                    IF WRITECOLUMN <= WRITECOL2 THEN
|                       BEGIN
|                          WRITEA(' ');
|                          IF SYMBOLGAP > 0 THEN
|                             NUMBERBLANKSTOWRITE := SYMBOLGAP - 1
|                          ;
|                       END;
|              IF WRITECOLUMN + LENGTH + NUMBERBLANKSTOWRITE - 1 >
|                 WRITECOL2
|              THEN
|                 BEGIN
|                    WRITEA(' ');
|                    WITH UNWRITTEN[OLDEST] DO
|                       BEGIN
|                          CHISENDLINE := TRUE;
|                          IF PACKERISOFF
|                          THEN
|                             BEGIN
|                                WRITEWIDTH := WRITECOL2 -
|                                   WRITECOL1 + 1;
|                                TOTALINDENT := LEFTMARGIN +
|                                   LONGLINEINDENT;
|                                IF LENGTH <= WRITEWIDTH -
|                                   TOTALINDENT
|                                THEN
|                                   INDENTAFTEREOL := WRITECOL1 -
|                                      1 + TOTALINDENT
|                                ELSE
|                                   IF LENGTH <= WRITEWIDTH
|                                   THEN
|                                      INDENTAFTEREOL := WRITECOL2
|                                         - LENGTH
|                                   ELSE
|                                      BEGIN
|                                         LENGTH := WRITEWIDTH;
|                                         INDENTAFTEREOL :=
|                                            WRITECOL1 - 1;
|                                         IF SYMBOL[1] = ''''
|                                         THEN
|                                            SYMBOL[LENGTH] :=
|                                               ''''
|                                      END;
|                                WRITECOLUMN := INDENTAFTEREOL + 1
|                                ;
|                             END
|                          ELSE
|                             BEGIN
|                                IF LENGTH > WRITECOL2 - WRITECOL1
|                                   + 1
|                                THEN
|                                   LENGTH := WRITECOL2 -
|                                      WRITECOL1 + 1;
|                                INDENTAFTEREOL := WRITECOL1 - 1;
|                                WRITECOLUMN := WRITECOL1;
|                             END;
|                       END (*WITH*);
|                 END
|              ELSE
|                 FOR I := 1 TO NUMBERBLANKSTOWRITE DO
|                    WRITEA(' ');
|              FOR I := 1 TO LENGTH DO WRITEA(SYMBOL[I]);
|           END (*IF DISPLAYISON*);
|        LASTSYMBOL := SYMBOLNAME;
|     END (*WRITESYMBOL*);
| 
|  PROCEDURE READSYMBOL;
| 
|     CONST
|        READNEXTCH = TRUE;
|        DONTREADNEXTCH = FALSE;
| 
|     VAR
|        TESTSYMBOL: ALFA;
|        CHARNUMBER: WIDTH;
|        I: WIDTH;
| 
|     PROCEDURE DOCOMMENT(TERMINATOR: CHAR);
| 
|        VAR
|           I: OPTIONSIZE;
|           SECONDTERMINATOR: CHAR;
|           SAVEDSYMBGP: OPTIONSIZE;
| 
|        PROCEDURE COPYACHARACTER;
| 
|           LABEL
|              10;
| 
|           BEGIN
|              IF READINGFORMATOPTIONS
|              THEN BEGIN CHARACTER := INPUT@;   GET(INPUT); END
|              ELSE
|                 BEGIN
|                    IF DISPLAYISON
|                    THEN
|                       BEGIN
|                          IF WRITECOLUMN > WRITECOL2
|                          THEN
|                             BEGIN
|                                IF (CHARACTER = ' ') AND
|                                   NOT EOLN(PROG)
|                                THEN
|                                   BEGIN
|                                      REPEAT READACHARACTER;
|                                      UNTIL (CHARACTER <> ' ') OR
|                                         EOLN(PROG);
|                                      IF CHARACTER = TERMINATOR
|                                      THEN GOTO 10;
|                                   END;
|                                IF NOT EOLN(PROG)
|                                THEN
|                                   BEGIN
|                                      WRITEA(' ');
|                                      WITH UNWRITTEN[OLDEST] DO
|                                         BEGIN
|                                            CHISENDLINE := TRUE;
|                                            INDENTAFTEREOL :=
|                                               WRITECOL1 +
|                                               LEFTMARGIN - 1;
|                                         END;
|                                      WRITECOLUMN := WRITECOL1 +
|                                         LEFTMARGIN;
|                                   END;
|                             END;
|                          IF EOLN(PROG)
|                          THEN WRITEANEOLWITHNOINDENT
|                          ELSE WRITEA(CHARACTER);
|                       END;
|                    READACHARACTER;
|                 END;
|          10:
|           END (*COPYACHARACTER*);
| 
|        PROCEDURE COMPILERDIRECTIVES;
| 
|           BEGIN
|              REPEAT
|                 REPEAT COPYACHARACTER;
| "SZH"          UNTIL CHMAP[CHARACTER] IN
| "SZH"                [CHMAP['E'], CHMAP['U'], CHMAP[' '], CHMAP['['],
| "SZH"                 CHMAP[TERMINATOR] ];
|              UNTIL NOT ((CHARACTER = 'E') AND PROGISPASCAL2);
|              IF (CHARACTER = 'E') OR (CHARACTER = 'U')
|              THEN
|                 BEGIN
|                    COPYACHARACTER;
|                    IF (CHARACTER = '+') OR (CHARACTER = '-') THEN
|                       BEGIN
|                          IF CHARACTER = '+'
|                          THEN READCOL2 := 72
|                          ELSE READCOL2 := 999;
|                          IF (WRITECOL2 > 72)
|                          THEN CHARACTER := '-';
|                       END;
|                 END;
| "SZH"       WHILE NOT (CHMAP[CHARACTER] IN [ CHMAP['['], CHMAP[TERMINATOR]]) DO
|                 COPYACHARACTER;
|           END (*COMPILERDIRECTIVES*);
| 
|        PROCEDURE FORMATTERDIRECTIVES;
| 
|           CONST
|              INVALID = - 1;
| 
|           TYPE
|              PARAMCOUNT = 1 .. 2;
|              PARAMS = ARRAY [PARAMCOUNT] OF MARGINS;
| 
|           VAR
|              SPECIFICATION: PARAMS;
|              FORMATOPTION: CHAR;
|              PREVDISPLAY: BOOLEAN;
|              ENDDIRECTV: SET OF CHSET;
| 
|           PROCEDURE READIN(N: PARAMCOUNT; VAR SPECIFICATION:
|              PARAMS);
| 
|              VAR
|                 I: PARAMCOUNT;
| 
|              BEGIN
|                 FOR I := 1 TO N DO
|                    BEGIN
| "SZH"                 WHILE NOT (CHMAP[CHARACTER] IN (DIGITS +
|                          ENDDIRECTV)) DO
|                          COPYACHARACTER;
|                       SPECIFICATION[I] := 0;
| "SZH"                 IF NOT (CHMAP[CHARACTER] IN ENDDIRECTV)
|                       THEN
|                          REPEAT
|                             SPECIFICATION[I] := 10 *
|                                SPECIFICATION[I] + ORD(CHARACTER)
|                                - ORD('0');
|                             COPYACHARACTER;
| "SZH"                    UNTIL NOT (CHMAP[CHARACTER] IN DIGITS)
|                       ELSE SPECIFICATION[I] := INVALID;
|                    END (*FOR*);
|              END (*READIN*);
| 
|           BEGIN (*FORMATTERDIRECTIVES*)
| "SZH"        ENDDIRECTV := [CHMAP[TERMINATOR], CHMAP[']']];
|              REPEAT
| "SZH"          IF ( CHMAP[CHARACTER] IN
| "SZH"             [ CHMAP['A'], CHMAP['B'], CHMAP['C'], CHMAP['D'],
| "SZH"               CHMAP['E'], CHMAP['G'], CHMAP['I'], CHMAP['L'],
| "SZH"               CHMAP['N'], CHMAP['P'], CHMAP['R'], CHMAP['S'],
| "SZH"               CHMAP['W'], CHMAP['F'], CHMAP['X'] ])
|                 THEN
|                    BEGIN
|                       FORMATOPTION := CHARACTER;
|                       CASE FORMATOPTION OF
|                          'A', 'E', 'I', 'G', 'P', 'L', 'S':
|                             BEGIN
|                                READIN(1, SPECIFICATION);
|                                IF (SPECIFICATION[1] < WRITECOL2
|                                   - WRITECOL1 - 9) OR (
|                                   FORMATOPTION = 'P')
|                                THEN
|                                   CASE FORMATOPTION OF
|                                      'A':
|                                         DECLARALIGNMENT :=
|                                            SPECIFICATION[1];
|                                      'E':
|                                         IF SPECIFICATION[1] < 4
|                                         THEN
|                                            BEGIN
|                                               PROCEDNAMESWANTED
|                                                  :=
|                                                  SPECIFICATION[1
|                                                  ] > 1;
|                                               ENDCOMMENTSWANTED
|                                                  := ODD(
|                                                  SPECIFICATION[1]
|                                                  );
|                                            END;
|                                      'G':
|                                         SYMBOLGAP :=
|                                            SPECIFICATION[1];
|                                      'I':
|                                         INDENTINDEX :=
|                                            SPECIFICATION[1];
|                                      'L':
|                                         LONGLINEINDENT :=
|                                            SPECIFICATION[1];
|                                      'P':
|                                         PROCEDSEPARATION :=
|                                            SPECIFICATION[1];
|                                      'S':
|                                         STATMTSEPARATION :=
|                                            SPECIFICATION[1];
|                                   END (*CASE*);
|                             END (*SINGLE PARAMETERS*);
|                          'W', 'R', 'N':
|                             BEGIN
|                                READIN(2, SPECIFICATION);
|                                IF SPECIFICATION[2] <> INVALID
|                                THEN
|                                   CASE FORMATOPTION OF
|                                      'W':
|                                         IF (SPECIFICATION[1] > 0
|                                            ) AND (SPECIFICATION[
|                                            2] < BUFFERSIZE - 2)
|                                            AND (SPECIFICATION[2]
|                                            - SPECIFICATION[1] >
|                                            8)
|                                         THEN
|                                            BEGIN
|                                               WRITECOL1 :=
|                                                  SPECIFICATION[1
|                                                  ];
|                                               WRITECOL2 :=
|                                                  SPECIFICATION[2
|                                                  ];
|                                            END;
|                                      'R':
|                                         IF (SPECIFICATION[1] > 0
|                                            ) AND (SPECIFICATION[
|                                            2] - SPECIFICATION[1]
|                                            > 8)
|                                         THEN
|                                            BEGIN
|                                               READCOL1 :=
|                                                  SPECIFICATION[1
|                                                  ];
|                                               READCOL2 :=
|                                                  SPECIFICATION[2
|                                                  ];
|                                            END;
|                                      'N':
|                                         BEGIN
|                                            LINENUMBER :=
|                                               SPECIFICATION[1];
|                                            INCREMENT :=
|                                               SPECIFICATION[2];
| "SZH"                                     WHILE NOT ( CHMAP[CHARACTER]
| "SZH"                                           IN ([CHMAP['+'], CHMAP['-'] ]+
|                                               ENDDIRECTV)) DO
|                                               COPYACHARACTER;
|                                            IF CHARACTER = '-'
|                                            THEN
|                                               INCREMENT := -
|                                                  INCREMENT
|                                            ELSE
|                                               IF WRITECOL1 < 3
|                                               THEN
|                                                  WRITECOL1 := 3;
|                                         END;
|                                   END (*CASE*);
|                             END (*DOUBLE PARAMETERS*);
|                          'B', 'C', 'D', 'F', 'X':
|                             BEGIN
|                                REPEAT COPYACHARACTER;
| "SZH"                         UNTIL CHMAP[CHARACTER] IN
| "SZH"                               ([ CHMAP['+'], CHMAP['-'] ] +
|                                      ENDDIRECTV);
|                                IF (CHARACTER = '+') OR (CHARACTER = '-')
|                                THEN
|                                   CASE FORMATOPTION OF
|                                      'B':
|                                         PACKERISOFF := CHARACTER
|                                            = '-';
|                                      'C':
|                                         IF DISPLAYISON THEN
|                                            COMPRESSWANTED :=
|                                               CHARACTER = '+';
|                                      'D':
|                                         BEGIN
|                                            PREVDISPLAY :=
|                                               DISPLAYWANTED;
|                                            DISPLAYWANTED :=
|                                               CHARACTER = '+';
|                                            IF PREVDISPLAY AND
|                                               NOT DISPLAYWANTED
|                                            THEN
|                                               BEGIN
|                                                  WRITEA(
|                                                     TERMINATOR);
|                                                  IF TERMINATOR =
|                                                     '*'
|                                                  THEN
|                                                    IF
|                                                    PROGISPASCAL2
|                                                    THEN
|                                                    WRITEA('(')
|                                                    ELSE
|                                                    WRITEA('/');
|                                                  SAVEDCOMPRESS
|                                                     :=
|                                                   COMPRESSWANTED
|                                                  ;
|                                                  COMPRESSWANTED
|                                                     := FALSE;
|                                               END
|                                            ELSE
|                                               IF NOT PREVDISPLAY
|                                                  AND
|                                                  DISPLAYWANTED
|                                               THEN
|                                                  BEGIN
| 
|                                            STARTNEWLINEANDINDENT
|                                                     ;
|                                                    IF TERMINATOR
|                                                       = '*'
|                                                    THEN
|                                                    BEGIN
|                                                    IF PROGISPASCAL2
|                                                    THEN
|                                                    WRITEA('(')
|                                                    ELSE
|                                                    WRITEA('/');
|                                                    WRITEA('*');
|                                                    END
|                                                    ELSE
|                                                    WRITEA('_');
| 
|                                                   COMPRESSWANTED
|                                                       :=
|                                                    SAVEDCOMPRESS
|                                                     ;
|                                                  END (*IF NOT PR
|                                                  EV*);
|                                         END (* 'D': *);
|                                      'F':
|                                         BEGIN
|                                            PREVDISPLAY :=
|                                               NOFORMATTING;
|                                            NOFORMATTING :=
|                                               CHARACTER = '-';
|                                            IF PREVDISPLAY AND
|                                               NOT NOFORMATTING
|                                            THEN READACHARACTER;
|                                            IF NOT PREVDISPLAY
|                                               AND NOFORMATTING
|                                            THEN WRITEA('-');
|                                         END;
|                                      'X':
|                                         CROSSREFWANTED :=
|                                            CHARACTER = '+';
|                                   END (*CASE*);
|                                DISPLAYISON := DISPLAYWANTED AND
|                                   NOT NOFORMATTING;
|                             END (*BOOLEAN PARAMETERS*);
|                       END (*CASE*)
|                    END (*THEN*)
|                 ELSE
| "SZH"              IF NOT (CHMAP[CHARACTER] IN ENDDIRECTV)
|                    THEN COPYACHARACTER;
| "SZH"        UNTIL CHMAP[CHARACTER] IN ENDDIRECTV;
|              IF CHARACTER = ']'   THEN COPYACHARACTER;
|           END (*FORMATTERDIRECTIVES*);
| 
|        BEGIN (*DOCOMMENT*)
|           IF READINGFORMATOPTIONS   THEN FORMATTERDIRECTIVES
|           ELSE
|              BEGIN
|                 IF PROGISPASCAL2   THEN SECONDTERMINATOR := ')'
|                 ELSE SECONDTERMINATOR := '/';
|                 IF LASTSYMBOL IN [COMMENT, SEMICOLON] THEN
|                    BEGIN
|                       LEFTMARGIN := 0;   STARTNEWLINEANDINDENT;
|                       LEFTMARGIN := ACTUALLEFTMARGIN;
|                    END;
|                 WRITESYMBOL;
|                 IF CHARACTER = '$'   THEN COMPILERDIRECTIVES;
|                 IF CHARACTER = '['   THEN FORMATTERDIRECTIVES;
|                 SAVEDSYMBGP := SYMBOLGAP;   SYMBOLGAP := 0;
|                 REPEAT
| 
|                    WHILE CHARACTER <> TERMINATOR DO
|                       BEGIN  COPYACHARACTER;
|                       END (*WHILE*);
| 
|                    READSYMBOL;   WRITESYMBOL;
|                 UNTIL SYMBOLNAME = COMMENT;
|                 SYMBOLGAP := SAVEDSYMBGP;   READSYMBOL;
|              END;
|        END (*DOCOMMENT*);
| 
|     PROCEDURE CHECKFOR(SECONDCHAR: CHAR; TWOCHARSYMBOL: SYMBOLS;
|        READALLOWED: BOOLEAN);
| 
|        BEGIN
|           IF READALLOWED THEN
|              BEGIN
|                 LENGTH := 1;   SYMBOL[1] := CHARACTER;
|                 SYMBOLNAME := NAMEOF[CHARACTER];
|                 READACHARACTER;
|              END;
|           IF CHARACTER = SECONDCHAR THEN
|              BEGIN
|                 SYMBOL[2] := CHARACTER;   LENGTH := 2;
|                 SYMBOLNAME := TWOCHARSYMBOL;   READACHARACTER;
|              END;
|        END (*CHECKFOR*);
| 
|     BEGIN (*READSYMBOL*)
| "SZH"
| "SZH"  IF CHARACTER = '#' THEN CHARACTER := ' '
| "SZH"  ELSE
| "SZH"     IF CHARACTER = '"' THEN
| "SZH"         IF FIRSTDQUOTE THEN
| "SZH"            BEGIN CHARACTER := 'ò';  FIRSTDQUOTE := FALSE END
| "SZH"         ELSE  BEGIN  CHARACTER := '¯';  FIRSTDQUOTE := TRUE  END;
| "SZH"
|        IF READINGFORMATOPTIONS   THEN DOCOMMENT('*')
|        ELSE
|           CASE TYPEOF[CHARACTER] OF
|              STAR:
|                 IF PROGISPASCAL2
|                 THEN CHECKFOR(')', COMMENT, READNEXTCH)
|                 ELSE CHECKFOR('/', COMMENT, READNEXTCH);
|              RIGHTARROW:
|                 BEGIN
|                    SYMBOLNAME := COMMENT;   SYMBOL[1] := '¯';
|                    LENGTH := 1;   READACHARACTER;
|                    DOCOMMENT('ò');
|                 END;
| "SZH"    (*  DQUOTE:
| "SZH"           BEGIN
| "SZH"              SYMBOLNAME := COMMENT;   SYMBOL[1] := '"';
| "SZH"              LENGTH := 1;   READACHARACTER;
| "SZH"              DOCOMMENT('"');
| "SZH"           END;   *)
|              SLASH:
|                 BEGIN
|                    CHECKFOR('*', COMMENT, READNEXTCH);
|                    IF (SYMBOLNAME = COMMENT) THEN
|                       BEGIN
|                          PROGISPASCAL2 := FALSE;
|                          DOCOMMENT('*')
|                       END;
|                 END;
|              LFTPAREN:
|                 BEGIN
|                    CHECKFOR('*', COMMENT, READNEXTCH);
|                    IF (SYMBOLNAME = COMMENT) THEN
|                       BEGIN
|                          PROGISPASCAL2 := TRUE;
|                          DOCOMMENT('*')
|                       END;
|                 END;
|              ALPHANUMERIC:
|                 BEGIN
| "SZH"              SYMBOLISNUMBER := CHMAP[CHARACTER] IN DIGITS;
|                    CHARNUMBER := 1;
|                    REPEAT
|                       SYMBOL[CHARNUMBER] := CHARACTER;
|                       READACHARACTER;
|                       CHARNUMBER := CHARNUMBER + 1
|                    UNTIL NOT (TYPEOF[CHARACTER] = ALPHANUMERIC);
|                    IF SYMBOLISNUMBER AND (SYMBOL[CHARNUMBER - 1]
|                       = 'E')
|                    THEN
|                       REPEAT
|                          SYMBOL[CHARNUMBER] := CHARACTER;
|                          READACHARACTER;
|                          CHARNUMBER := CHARNUMBER + 1;
| "SZH"                 UNTIL NOT (CHMAP[CHARACTER] IN DIGITS);
|                    LENGTH := CHARNUMBER - 1;
|                    IF SYMBOLISNUMBR
|                    THEN SYMBOLNAME := IDENTIFIER
|                    ELSE
|                       BEGIN
|                          FOR CHARNUMBER := CHARNUMBER TO 10 DO
|                             SYMBOL[CHARNUMBER] := ' ';
| """                      PACK(SYMBOL, 1, TESTSYMBOL);   """  I := 1;
| "SZH"                    FOR PQ := 1 TO ALFLEN DO TESTSYMBOL[PQ] := SYMBOL[PQ];
|                          PASCALSYMBOL[LASTPSYMBOLNAME] :=
|                             TESTSYMBOL;
|                          WHILE TESTSYMBOL <> PASCALSYMBOL[I] DO
|                             I := I + 1;
|                          SYMBOLNAME := PSYMBOLNAME[I];
|                       END (*ELSE*);
|                 END (*ALPHANUMERIC*);
|              BLANK, ENDOFLINE:
|                 BEGIN
|                    REPEAT READACHARACTER
|                    UNTIL NOT (TYPEOF[CHARACTER] IN [BLANK,
|                       ENDOFLINE]);
|                    READSYMBOL
|                 END;
|              GREATERTHAN, COLON:
|                 CHECKFOR('=', OTHERSYMBOL, READNEXTCH);
|              LESSTHAN:
|                 BEGIN
|                    CHECKFOR('=', OTHERSYMBOL, READNEXTCH);
|                    IF SYMBOLNAME <> OTHERSYMBOL THEN
|                       CHECKFOR('>', OTHERSYMBOL, DONTREADNEXTCH)
|                    ;
|                 END;
|              PERIOD:
|                 IF LASTSYMBOL <> ENDSYMBOL
|                 THEN CHECKFOR('.', RANGE, READNEXTCH)
|                 ELSE SYMBOLNAME := PERIODSYMBOL;
|              STRING:
|                 BEGIN
|                    CHARNUMBER := 1;
|                    REPEAT
|                       REPEAT
|                          SYMBOL[CHARNUMBER] := CHARACTER;
|                          CHARNUMBER := CHARNUMBER + 1;
|                          READACHARACTER;
|                       UNTIL CHARACTER = '''';
|                       SYMBOL[CHARNUMBER] := CHARACTER;
|                       CHARNUMBER := CHARNUMBER + 1;
|                       READACHARACTER;
|                    UNTIL CHARACTER <> '''';
|                    LENGTH := CHARNUMBER - 1;
|                    SYMBOLNAME := OTHERSYMBOL;
|                 END (*STRING*);
|              OTHER:
|                 BEGIN
|                    SYMBOL[1] := CHARACTER;
|                    SYMBOLNAME := NAMEOF[CHARACTER];
|                    LENGTH := 1;   READACHARACTER;
|                 END;
|           END (*CASE*);
|     END (*READSYMBOL*);
| 
|  PROCEDURE CHANGEMARGINTO(NEWLEFTMARGIN: MARGINS);
| 
|     BEGIN
|        ACTUALLEFTMARGIN := NEWLEFTMARGIN;
|        LEFTMARGIN := NEWLEFTMARGIN;
|        IF LEFTMARGIN < 0   THEN LEFTMARGIN := 0
|        ELSE
|           IF LEFTMARGIN > WRITECOL2 - WRITECOL1 - 9 -
|              LONGLINEINDENT
|           THEN
|              LEFTMARGIN := WRITECOL2 - WRITECOL1 - 9 -
|                 LONGLINEINDENT;
|     END (*CHANGEMARGINTO*);
| 
|  PROCEDURE DODECLARATIONUNTIL(ENDDECLARATION: SYMBOLSET);
| 
|     PROCEDURE DOPARENTHESES;
| 
|        VAR
|           SAVEDLGLNID: OPTIONSIZE;
| 
|        BEGIN
|           SAVEDLGLNID := LONGLINEINDENT;
|           IF DECLARALIGNMENT > 0
|           THEN
|              BEGIN
|                 LONGLINEINDENT := WRITECOLUMN + SYMBOLGAP + 1 -
|                    LEFTMARGIN - WRITECOL1;
|                 REPEAT WRITESYMBOL;   READSYMBOL;
|                 UNTIL SYMBOLNAME = RIGHTPARENTH;
|                 WRITESYMBOL;   READSYMBOL;
|              END
|           ELSE
|              BEGIN
|                 LONGLINEINDENT := 1;
|                 CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
|                 STARTNEWLINEANDINDENT;
|                 REPEAT WRITESYMBOL;   READSYMBOL
|                 UNTIL SYMBOLNAME = RIGHTPARENTH;
|                 WRITESYMBOL;   READSYMBOL;
|                 CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
|              END (*ELSE*);
|           LONGLINEINDENT := SAVEDLGLNID;
|        END (*DOPARENTHESES*);
| 
|     PROCEDURE DOFIELDLISTUNTIL(ENDFIELDLIST: SYMBOLSET);
| 
|        VAR
|           LASTEOL: MARGINS;
|           ALIGNCOLUMN: WIDTH;
| 
|        PROCEDURE DORECORD;
| 
|           VAR
|              SAVEDLEFTMARGIN: WIDTH;
| 
|           BEGIN
|              SAVEDLEFTMARGIN := ACTUALLEFTMARGIN;   WRITESYMBOL;
|              READSYMBOL;
|              CHANGEMARGINTO(WRITECOLUMN - 6 + INDENTINDEX -
|                 WRITECOL1);
|              STARTNEWLINEANDINDENT;
|              DOFIELDLISTUNTIL([ENDSYMBOL]);
|              CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
|              STARTNEWLINEANDINDENT;   WRITESYMBOL;   READSYMBOL;
|              CHANGEMARGINTO(SAVEDLEFTMARGIN);
|           END (*DORECORD*);
| 
|        PROCEDURE DOVARIANTRECORDPART;
| 
|           VAR
|              SAVEDLEFTMARGIN, OTHERSAVEDMARGIN: MARGINS;
| 
|           BEGIN
|              OTHERSAVEDMARGIN := ACTUALLEFTMARGIN;
|              IF DECLARALIGNMENT > 0
|              THEN
|                 BEGIN
|                    REPEAT WRITESYMBOL;   READSYMBOL;
|                    UNTIL SYMBOLNAME = COLONSYMBOL;
|                    WRITESYMBOL;   READSYMBOL;
|                    WITH UNWRITTEN[LASTEOL] DO
|                       BEGIN
|                          INDENTAFTEREOL := INDENTAFTEREOL +
|                             ALIGNCOLUMN - WRITECOLUMN;
|                          IF INDENTAFTEREOL < 0
|                          THEN INDENTAFTEREOL := 0;
|                       END;
|                    WRITECOLUMN := ALIGNCOLUMN;
|                    CHANGEMARGINTO(ACTUALLEFTMARGIN + ALIGNCOLUMN -
|                       WRITECOLUMN);
|                 END;
|              REPEAT WRITESYMBOL;   READSYMBOL;
|              UNTIL SYMBOLNAME = OFSYMBOL;
|              CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
|              REPEAT
|                 WRITESYMBOL;   READSYMBOL;
|                 IF SYMBOLNAME <> ENDSYMBOL
|                 THEN
|                    BEGIN
|                       STARTNEWLINEANDINDENT;
|                       REPEAT WRITESYMBOL;   READSYMBOL;
|                       UNTIL SYMBOLNAME IN [LEFTPAREN, SEMICOLON
|                          , ENDSYMBOL];
|                       IF SYMBOLNAME = LEFTPAREN
|                       THEN
|                          BEGIN
|                             WRITESYMBOL;   READSYMBOL;
|                             SAVEDLEFTMARGIN := ACTUALLEFTMARGIN;
|                             CHANGEMARGINTO(WRITECOLUMN -
|                                WRITECOL1);
|                             DOFIELDLISTUNTIL([RIGHTPARENTH]);
|                             WRITESYMBOL;   READSYMBOL;
|                             CHANGEMARGINTO(SAVEDLEFTMARGIN);
|                          END;
|                    END;
|              UNTIL SYMBOLNAME <> SEMICOLON;
|              CHANGEMARGINTO(OTHERSAVEDMARGIN);
|           END (*DOVARIANTRECORDPART*);
| 
|        BEGIN (*DOFIELDLISTUNTIL*)
|           LASTEOL := OLDEST;
|           IF LASTSYMBOL = LEFTPAREN THEN
|              FOR I := 1 TO DECLARALIGNMENT - LENGTH DO WRITEA(' ');
|           ALIGNCOLUMN := LEFTMARGIN + WRITECOL1 + DECLARALIGNMENT +
|              1;
|           WHILE NOT (SYMBOLNAME IN ENDFIELDLIST) DO
|              BEGIN
|                 IF LASTSYMBOL IN [SEMICOLON, COMMENT] THEN
|                    IF SYMBOLNAME <> SEMICOLON THEN
|                       BEGIN
|                          STARTNEWLINEANDINDENT;
|                          LASTEOL := OLDEST
|                       END;
|                 IF SYMBOLNAME IN [RECORDSYMBOL, CASESYMBOL,
|                    LEFTPAREN, COMMASYMBOL, COLONSYMBOL,
|                    EQUALSYMBOL]
|                 THEN
|                    CASE SYMBOLNAME OF
|                       RECORDSYMBOL: DORECORD;
|                       CASESYMBOL: DOVARIANTRECORDPART;
|                       LEFTPAREN: DOPARENTHESES;
|                       COMMASYMBOL, COLONSYMBOL, EQUALSYMBOL:
|                          BEGIN
|                             WRITESYMBOL;
|                             IF DECLARALIGNMENT > 0
|                             THEN
|                                IF ENDFIELDLIST <> ENDLABEL
|                                THEN
|                                   BEGIN
|                                      WITH UNWRITTEN[LASTEOL] DO
|                                         BEGIN
|                                            INDENTAFTEREOL :=
|                                               INDENTAFTEREOL +
|                                               ALIGNCOLUMN -
|                                               WRITECOLUMN;
|                                            IF INDENTAFTEREOL < 0
|                                            THEN
|                                               INDENTAFTEREOL :=
|                                                  0;
|                                            WRITECOLUMN :=
|                                               ALIGNCOLUMN;
|                                         END;
|                                      IF SYMBOLNAME = COMMASYMBOL
|                                      THEN
|                                         BEGIN
|                                            STARTNEWLINEANDINDENT
|                                            ;
|                                            LASTEOL := OLDEST;
|                                         END;
|                                   END (*IF DECLARALIGN*);
|                             READSYMBOL;
|                          END (*  ,   :   = *)
|                    END (*CASE*)
|                 ELSE BEGIN WRITESYMBOL;   READSYMBOL END;
|              END (*WHILE*);
|        END (*DOFIELDLISTUNTIL*);
| 
|     BEGIN (*DODECLARATIONUNTIL*)
|        STARTNEWLINEANDINDENT;   WRITESYMBOL;
|        CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
|        STARTNEWLINEANDINDENT;   READSYMBOL;
|        DOFIELDLISTUNTIL(ENDDECLARATION);
|        STARTNEWLINEANDINDENT;
|        CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
|     END (*DOTYPES*);
| 
|  PROCEDURE BLOCK(BLOCKNAME: COMMENTTEXT; BLOCKNMLENGTH: WIDTH);
| 
|     VAR
|        I: WIDTH;
|        IFTHENCOMPRESSNEEDED: BOOLEAN;
|        ATPROCEDBEGINNING: BOOLEAN;
| 
|     PROCEDURE PROCEDURES;
| 
|        VAR
|           I: 0 .. 20;
|           PROCEDNAME: COMMENTTEXT;
|           PROCEDNMLENGTH: WIDTH;
| 
|        BEGIN
|           FOR I := 2 TO PROCEDSEPARATION DO
|              STARTNEWLINEANDINDENT;
|           STARTNEWLINEANDINDENT;   WRITESYMBOL;   READSYMBOL;
|           FOR I := 0 TO(LENGTH - 1) DIV 10 DO
| """          PACK(SYMBOL, I * 10 + 1, PROCEDNAME[I + 1]); """
| "SZH"        FOR PQ := 1 TO ALFLEN DO PROCEDNAME[I+1,PQ] := SYMBOL[I*10+PQ];
|           PROCEDNMLENGTH := LENGTH;   WRITESYMBOL;   READSYMBOL;
|           IF SYMBOLNAME = LEFTPAREN THEN
|              BEGIN
|                 WRITESYMBOL;
|                 REPEAT READSYMBOL;   WRITESYMBOL
|                 UNTIL SYMBOLNAME = RIGHTPARENTH;
|                 READSYMBOL;
|              END;
|           IF SYMBOLNAME = COLONSYMBOL THEN
|              REPEAT WRITESYMBOL;   READSYMBOL;
|              UNTIL SYMBOLNAME = SEMICOLON;
|           WRITESYMBOL;   READSYMBOL;
|           CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
|           STARTNEWLINEANDINDENT;   LASTPROGPARTWASBODY := FALSE;
|           BLOCK(PROCEDNAME, PROCEDNMLENGTH);
|           LASTPROGPARTWASBODY := TRUE;
|           CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
|           WRITESYMBOL;   READSYMBOL;
|  (* WRITE ";"*)
|           STARTNEWLINEANDINDENT;
|        END (*PROCEDURES*);
| 
|     PROCEDURE DOSTATEMENT(VAR ADDEDBLANKS: WIDTH; STATMTSYMBOL:
|        COMMENTTEXT; STMTSYMLENGTH: WIDTH);
| 
|        VAR
|           I: WIDTH;
|           STATMTBEGINNING: INTEGER;
|           STATMTPART: ARRAY [1 .. 4] OF INTEGER;
|           BLKSONCURRNTLINE, BLKSADDEDBYTHISSTMT: INTEGER;
|           SUCCESSFUL: BOOLEAN;
| 
|        PROCEDURE COMPRESS(BEGINNING, BREAKPT, ENDING: INTEGER;
|           STATMTSEPARATION: OPTIONSIZE);
| 
|           BEGIN
|              IF COMPRESSWANTED OR IFTHENCOMPRESSNEEDED
|              THEN
|                 BEGIN
|                    IF STATMTSEPARATION < 1
|                    THEN STATMTSEPARATION := 1;
|                    BLKSONCURRNTLINE := BLKSONCURRNTLINE +
|                       STATMTSEPARATION - 1;
|                    SUCCESSFUL := ((ENDING - BEGINNING +
|                       BLKSONCURRNTLINE + UNWRITTEN[BEGINNING MOD
|                       BUFFERSIZE].INDENTAFTEREOL) < WRITECOL2)
|                       AND (CHARCOUNT - BEGINNING < BUFFERSIZE);
|                    IF SUCCESSFUL THEN
|                       BEGIN
|                          BLKSADDEDBYTHISST := BLKSADDEDBYTHISST +
|                             STATMTSEPARATION - 1;
|                          UNWRITTEN[BREAKPT MOD BUFFERSIZE].
|                             INDENTAFTEREOL := - STATMTSEPARATION
|                          ;
|                       END;
|                 END;
|           END (*COMPRESS*);
| 
|        PROCEDURE WRITECOMMENT;
| 
|           VAR
|              I: 0 .. BUFFSZDIV10;
|              SAVEDLENGTH: WIDTH;
|              SAVEDSYMBOLNAME: SYMBOLS;
|              SAVEDCHARS: SYMBOLSTRING;
| 
|           BEGIN
|              SAVEDSYMBOLNAME := SYMBOLNAME;
|              FOR I := 1 TO LENGTH DO SAVEDCHARS[I] := SYMBOL[I];
|              SAVEDLENGTH := LENGTH;   SYMBOLNAME := OTHERSYMBOL;
|              IF PROGISPASCAL2   THEN SYMBOL[1] := '('
|              ELSE SYMBOL[1] := '/';
|              SYMBOL[2] := '*';   LENGTH := 2;   WRITESYMBOL;
|              FOR I := 0 TO(STMTSYMLENGTH - 1) DIV 10 DO
|             """ UNPACK(STATMTSYMBOL[I + 1], SYMBOL, (I * 10 + 1)
|                    );"""
|                 FOR PQ := 1 TO ALFLEN DO  SYMBOL[I*10+PQ]:=STATMTSYMBOL[I+1,PQ];
|              LENGTH := STMTSYMLENGTH;
|              SYMBOLNAME := PERIODSYMBOL;
|              LASTSYMBOL := PERIODSYMBOL;   WRITESYMBOL;
|              SYMBOL[1] := '*';
|              IF PROGISPASCAL2   THEN SYMBOL[2] := ')'
|              ELSE SYMBOL[2] := '/';
|              LENGTH := 2;   WRITESYMBOL;
|              SYMBOLNAME := SAVEDSYMBOLNAME;
|              LENGTH := SAVEDLENGTH;
|              FOR I := 1 TO LENGTH DO SYMBOL[I] := SAVEDCHARS[I];
|           END (*WRITECOMMENT*);
| 
|        PROCEDURE DOSTATMTLIST(ENDLIST: SYMBOLS);
| 
|           VAR
|              BLKSAFTERPRT2: WIDTH;
|              ATPROCEDEND: BOOLEAN;
| 
|           BEGIN
|              ATPROCEDEND := ATPROCEDBEGINNING;   WRITESYMBOL;
|              READSYMBOL;   STATMTPART[1] := CHARCOUNT + 1;
|              STATMTPART[2] := STATMTPART[1];
|              IF SYMBOLNAME <> ENDLIST
|              THEN
|                 BEGIN
|                    IF PROCEDNAMESWANTED THEN
|                       IF ATPROCEDBEGINNING THEN
|                          IF LASTPROGPARTWASBODY THEN
|                             IF LASTSYMBOL = BEGINSYMBOL
|                             THEN WRITECOMMENT;
|                    ATPROCEDBEGINNING := FALSE;
|                    DOSTATEMENT(ADDEDBLANKS, STATMTSYMBOL,
|                       STMTSYMLENGTH);
|                    BLKSAFTERPRT2 := ADDEDBLANKS;
|                    BLKSADDEDBYTHISSTMT := BLKSADDEDBYTHISSTMT +
|                       ADDEDBLANKS;
|                    WHILE SYMBOLNAME <> ENDLIST DO
|                       BEGIN
|                          WRITESYMBOL;   READSYMBOL;
|                          IF SYMBOLNAME <> ENDLIST
|                          THEN
|                             BEGIN
|                                STATMTPART[3] := CHARCOUNT + 1;
|                                DOSTATEMENT(ADDEDBLANKS,
|                                   STATMTSYMBOL, STMTSYMLENGTH);
|                                BLKSONCURRNTLINE := ADDEDBLANKS +
|                                   BLKSAFTERPRT2;
|                                BLKSADDEDBYTHSTMT :=
|                                   BLKSADDEDBYTHSTMT +
|                                   ADDEDBLANKS;
|                                COMPRESS(STATMTPART[2],
|                                   STATMTPART[3], CHARCOUNT,
|                                   STATMTSEPARATION);
|                                IF NOT SUCCESSFUL
|                                THEN
|                                   BEGIN
|                                      BLKSAFTERPRT2 :=
|                                         ADDEDBLANKS;
|                                      STATMTPART[2] := STATMTPART
|                                         [3];
|                                   END
|                                ELSE
|                                   BLKSAFTERPRT2 :=
|                                      BLKSONCURRNTLINE;
|                             END;
|                       END (*WHILE SYMBOLNAME <> ENDLIST*);
|                 END (*IF SYMBOLNAME <> ENDLIST*);
|              BLKSONCURRNTLINE := BLKSADDEDBYTHISSTMT;
|              COMPRESS(STATMTBEGINNING, STATMTPART[1], CHARCOUNT,
|                 SYMBOLGAP);
|              STARTNEWLINEANDINDENT;
|              STATMTPART[1] := CHARCOUNT;
|              REPEAT WRITESYMBOL;   READSYMBOL;
|              UNTIL SYMBOLNAME IN [SEMICOLON, UNTILSYMBOL,
|                 ENDSYMBOL, ELSESYMBOL, PERIODSYMBOL];
|              IF SUCCESSFUL
|              THEN
|                 BEGIN
|                    IF ENDLIST = UNTILSYMBOL
|                    THEN STATMTPART[4] := STATMTSEPARATION
|                    ELSE STATMTPART[4] := SYMBOLGAP;
|                    COMPRESS(STATMTBEGINNING, STATMTPART[1],
|                       CHARCOUNT, STATMTPART[4]);
|                 END (*IF SUCCESSFUL*);
|              IF NOT (SUCCESSFUL AND COMPRESSWANTED)
|              THEN
|                 IF ENDLIST = ENDSYMBOL THEN
|                    IF LASTSYMBOL = ENDSYMBOL THEN
|                       IF ATPROCEDEND AND PROCEDNAMESWANTED
|                       THEN WRITECOMMENT
|                       ELSE
|                          IF ENDCOMMENTSWANTED
|                          THEN WRITECOMMENT;
|           END (*DOSTATMTLIST*);
| 
|        BEGIN (*DOSTATEMENT*)
|           BLKSONCURRNTLINE := 0;
|           BLKSADDEDBYTHISST := 0;
|           CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
|           STARTNEWLINEANDINDENT;   STATMTBEGINNING := CHARCOUNT;
|           IF SYMBOLISNUMBER
|           THEN
|              BEGIN
|                 WITH UNWRITTEN[OLDEST] DO
|                    BEGIN
|                       INDENTAFTEREOL := INDENTAFTEREOL - 1 -
|                          LENGTH - SYMBOLGAP;
|                       IF INDENTAFTEREOL < 0
|                       THEN INDENTAFTEREOL := 0;
|                    END;
|                 WRITESYMBOL;   READSYMBOL (*WRITE LABEL*);
|                 WRITESYMBOL;   READSYMBOL (*WRITE COLON*);
|              END;
|           CASE STATEMENTTYPEOF[SYMBOLNAME] OF
|              FORWITHWHILESTATEMENT:
|                 BEGIN
| """                PACK(SYMBOL, 1, STATMTSYMBOL[1]);    """
| "SZH"              FOR PQ := 1 TO ALFLEN DO STATMTSYMBOL[1,PQ] := SYMBOL[PQ];
|                    STMTSYMLENGTH := LENGTH;
|                    REPEAT WRITESYMBOL;   READSYMBOL
|                    UNTIL SYMBOLNAME = DOSYMBOL;
|                    WRITESYMBOL;   READSYMBOL;
|                    STATMTPART[1] := CHARCOUNT + 1;
|                    DOSTATEMENT(ADDEDBLANKS, STATMTSYMBOL,
|                       STMTSYMLENGTH);
|                    BLKSONCURRNTLINE := BLKSONCURRNTLINE +
|                       ADDEDBLANKS;
|                    BLKSADDEDBYTHISSTMT := BLKSADDEDBYTHISSTMT +
|                       ADDEDBLANKS;
|                    COMPRESS(STATMTBEGINNING, STATMTPART[1],
|                       CHARCOUNT, SYMBOLGAP);
|                 END;
|              REPEATSTATEMENT: DOSTATMTLIST(UNTILSYMBOL);
|              IFSTATEMENT:
|                 BEGIN
| """                PACK(SYMBOL, 1, STATMTSYMBOL[1]);   """
| "SZH"              FOR PQ := 1 TO ALFLEN DO STATMTSYMBOL[1,PQ] := SYMBOL[PQ];
|                    STMTSYMLENGTH := LENGTH;
|                    REPEAT WRITESYMBOL;   READSYMBOL
|                    UNTIL SYMBOLNAME = THENSYMBOL;
|                    STARTNEWLINEANDINDENT;
|                    STATMTPART[1] := CHARCOUNT;   WRITESYMBOL;
|                    READSYMBOL;   STATMTPART[2] := CHARCOUNT + 1;
|                    DOSTATEMENT(ADDEDBLANKS, STATMTSYMBOL,
|                       STMTSYMLENGTH);
|                    BLKSONCURRNTLINE := ADDEDBLANKS;
|                    BLKSADDEDBYTHISSTMT := ADDEDBLANKS;
|                    COMPRESS(STATMTPART[1], STATMTPART[2],
|                       CHARCOUNT, SYMBOLGAP);
|                    IF SUCCESSFUL
|                    THEN
|                       COMPRESS(STATMTBEGINNING, STATMTPART[1],
|                          CHARCOUNT, STATMTSEPARATION)
|                    ELSE IFTHENCOMPRESSNEEDED := TRUE;
|                    IF SYMBOLNAME = ELSESYMBOL
|                    THEN
|                       BEGIN
| """                      PACK(SYMBOL, 1, STATMTSYMBOL[1]);          """
| "SZH"                    FOR PQ := 1 TO ALFLEN DO
| "SZH"                        STATMTSYMBOL[1,PQ] := SYMBOL[PQ];
|                          STMTSYMLENGTH := LENGTH;
|                          IFTHENCOMPRESSNEEDED := FALSE;
|                          STARTNEWLINEANDINDENT;
|                          STATMTPART[3] := CHARCOUNT;
|                          WRITESYMBOL;   READSYMBOL;
|                          STATMTPART[4] := CHARCOUNT + 1;
|                          DOSTATEMENT(ADDEDBLANKS, STATMTSYMBOL,
|                             STMTSYMLENGTH);
|                          BLKSONCURRNTLINE := ADDEDBLANKS;
|                          BLKSADDEDBYTHISSTMT :=
|                             BLKSADDEDBYTHISSTMT + ADDEDBLANKS;
|                          COMPRESS(STATMTPART[3], STATMTPART[4],
|                             CHARCOUNT, SYMBOLGAP);
|                          BLKSONCURRNTLINE := BLKSADDEDBYTHISSTMT
|                          ;
|                          IF SUCCESSFUL THEN
|                             COMPRESS(STATMTBEGINNING, STATMTPART[3],
|                                CHARCOUNT, STATMTSEPARATION);
|                       END
|                    ELSE
|                       IF (CHARCOUNT - STATMTBEGINNING) <
|                          BUFFERSIZE
|                       THEN
|                          BEGIN
|                             COMPRESSWANTED := NOT COMPRESSWANTED
|                             ;
|                             BLKSONCURRNTLINE := 0;
|                             COMPRESS(STATMTBEGINNING, STATMTPART
|                                [1], STATMTPART[2], SYMBOLGAP);
|                             COMPRESSWANTED := NOT COMPRESSWANTED
|                             ;
|                          END;
|                    IFTHENCOMPRESSNEEDED := FALSE;
|                 END (*IFSTATEMENT*);
|              CASESTATEMENT:
|                 BEGIN
|                    REPEAT WRITESYMBOL;   READSYMBOL
|                    UNTIL SYMBOLNAME = OFSYMBOL;
|                    WRITESYMBOL;   READSYMBOL;
|                    CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX
|                       );
|                    WHILE SYMBOLNAME <> ENDSYMBOL DO
|                       BEGIN
|                          STARTNEWLINEANDINDENT;
|                          STATMTPART[1] := CHARCOUNT;
|                          FOR I := 0 TO(LENGTH - 1) DIV 10 DO
| """                         PACK(SYMBOL, (I * 10 + 1), STATMTSYMBOL[I + 1]);"""
| "SZH"                       FOR PQ := 1 TO ALFLEN DO
|                               STATMTSYMBOL[I+1, PQ] := SYMBOL[I*10 +PQ];
|                          STMTSYMLENGTH := LENGTH;
|                          REPEAT WRITESYMBOL;   READSYMBOL
|                          UNTIL SYMBOLNAME = COLONSYMBOL;
|                          WRITESYMBOL;   READSYMBOL;
|  (*WRITE COLON*)
|                          IF NOT (SYMBOLNAME IN [SEMICOLON,
|                             ENDSYMBOL])
|                          THEN
|                             BEGIN
|                                STATMTPART[2] := CHARCOUNT + 1;
|                                DOSTATEMENT(ADDEDBLANKS,
|                                   STATMTSYMBOL, STMTSYMLENGTH);
|                                BLKSONCURRNTLINE := ADDEDBLANKS;
|                                BLKSADDEDBYTHISSTMT :=
|                                   BLKSADDEDBYTHISSTMT +
|                                   ADDEDBLANKS;
|                                COMPRESS(STATMTPART[1],
|                                   STATMTPART[2], CHARCOUNT,
|                                   SYMBOLGAP);
|                             END (*IF NOT(SYMBOLNAME...)*);
|                          IF SYMBOLNAME = SEMICOLON THEN
|                             BEGIN WRITESYMBOL;   READSYMBOL;
|                             END;
|                       END;
|                    CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX
|                       );
|                    STARTNEWLINEANDINDENT;   WRITESYMBOL;
|                    READSYMBOL;
|                    IF ENDCOMMENTSWANTED AND (LASTSYMBOL =
|                       ENDSYMBOL)
|                    THEN
|                       BEGIN
|                          STATMTSYMBOL[1] := 'CASE      ';
|                          STMTSYMLENGTH := 4;   WRITECOMMENT;
|                       END;
|                 END (*CASESTATEMENT*);
|              OTHERSTATEMENT:
|                 BEGIN
|                    WHILE NOT (SYMBOLNAME IN [SEMICOLON,
|                       UNTILSYMBOL, ENDSYMBOL, ELSESYMBOL]) DO
|                       BEGIN WRITESYMBOL;   READSYMBOL END;
|                 END (*OTHER*);
|              COMPOUNDSTATEMENT: DOSTATMTLIST(ENDSYMBOL);
|           END (*CASE*);
|           ADDEDBLANKS := BLKSADDEDBYTHISSTMT;
|           CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
|        END (*DOSTATEMENT*);
| 
|     BEGIN (*BLOCK*)
|        LASTPROGPARTWASBODY := LASTPROGPARTWASBODY AND (
|           SYMBOLNAME = BEGINSYMBOL);
|        IF SYMBOLNAME = LABELSYMBOL
|        THEN DODECLARATIONUNTIL(ENDLABEL);
|        IF SYMBOLNAME = CONSTSYMBOL
|        THEN DODECLARATIONUNTIL(ENDCONST);
|        IF SYMBOLNAME = TYPESYMBOL
|        THEN DODECLARATIONUNTIL(ENDTYPE);
|        IF SYMBOLNAME = VARSYMBOL
|        THEN DODECLARATIONUNTIL(ENDVAR);
|        IF SYMBOLNAME = VALUESYMBOL
|        THEN DODECLARATIONUNTIL(ENDVALUE);
|        WHILE SYMBOLNAME IN [FUNCTIONSYMBOL, PROCEDSYMBOL] DO
|           PROCEDURES;
|        IF SYMBOLNAME = BEGINSYMBOL
|        THEN
|           BEGIN
|              IF LASTPROGPARTWASBODY THEN
|                 FOR I := 2 TO PROCEDSEPARATION DO
|                    STARTNEWLINEANDINDENT;
|              IFTHENCOMPRESSNEEDED := FALSE;
|              ATPROCEDBEGINNING := TRUE;
|              CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
|              DOSTATEMENT(I, BLOCKNAME, BLOCKNMLENGTH);
|  (*I = DUMMY PARAMETER*)
|              LASTPROGPARTWASBODY := TRUE;
|              CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
|           END
|        ELSE
|           BEGIN WRITESYMBOL;   READSYMBOL;
|  (*WRITE "FORWARD"*)
|           END;
|     END (*BLOCK*);
| 
|  PROCEDURE INITIALIZE;
| 
|     VAR
|        I: WIDTH;
| 
|     BEGIN
| "SZH" DIGITS := [ CHMAP['0'], CHMAP['1'], CHMAP['2'], CHMAP['3'],
| "SZH"             CHMAP['4'], CHMAP['5'], CHMAP['6'], CHMAP['7'],
| "SZH"             CHMAP['8'], CHMAP['9'] ];
|        ALPHASYMBOLS := [PROGRAMSYMBOL, BEGINSYMBOL, ENDSYMBOL,
|           CONSTSYMBOL, TYPESYMBOL, RECORDSYMBOL, CASESYMBOL,
|           IFSYMBOL, THENSYMBOL, ELSESYMBOL, DOSYMBOL, OFSYMBOL,
|           FORSYMBOL, WITHSYMBOL, WHILESYMBOL, REPEATSYMBOL,
|           UNTILSYMBOL, IDENTIFIER, VARSYMBOL, VALUESYMBOL,
|           PROCEDSYMBOL, FUNCTIONSYMBOL, LABELSYMBOL,
|           ALPHAOPERATOR];
|        ENDLABEL := [CONSTSYMBOL, TYPESYMBOL, VARSYMBOL,
|           VALUESYMBOL, PROCEDSYMBOL, FUNCTIONSYMBOL, BEGINSYMBOL
|           ];
|        ENDCONST := ENDLABEL - [CONSTSYMBOL];
|        ENDTYPE := ENDCONST - [TYPESYMBOL];
|        ENDVAR := ENDTYPE - [VARSYMBOL];
|        ENDVALUE := ENDVAR - [VALUESYMBOL];   WRITECOLUMN := 1;
|        LEFTMARGIN := 0;   ACTUALLEFTMARGIN := 0;
|        OUTPUTCOL := 1;   READCOL1 := 1;   READCOL2 := 999;
|        WRITECOL1 := 1;   WRITECOL2 := 72;   OLDEST := 1;
|        CHARCOUNT := 1;   LINENUMBER := 0;   INCREMENT := 0;
|        PACKERISOFF := TRUE;   COMPRESSWANTED := FALSE;
|        DISPLAYISON := TRUE;   DISPLAYWANTED := TRUE;
|        NOFORMATTING := FALSE;   CROSSREFWANTED := FALSE;
|        PROCEDNAMESWNTD := TRUE;   ENDCOMMENTSWNTD := FALSE;
|        INDENTINDEX := 3;   LONGLINEINDENT := 3;
|        PROCEDSEPARATION := 3;   SYMBOLGAP := 1;
|        STATMTSEPARATION := 3;   DECLARALIGNMENT := 0;
|        READCOLUMN := 0;   LASTSYMBOL := PERIODSYMBOL;
|        LASTPROGPARTWASBODY := FALSE;
|        READINGFORMATOPTIONS := FALSE;   PROGISPASCAL2 := FALSE;
|        RESET(PROG);
|     END (*INITIALIZE*);
| 
|  PROCEDURE READFORMATOPTIONS;
| 
|     BEGIN
|        IF NOT EOF (*EOS*) (INPUT) THEN
|           BEGIN
|              READINGFORMATOPTIONS := TRUE;   READSYMBOL;
|              READINGFORMATOPTIONS := FALSE;
|           END;
|     END (*READFORMATOPTIONS*);
| 
|  BEGIN (*MAINPROGRAM*)
| "szh" init_chmap;
|     (*MESSAGE*)
|     WRITELN(OUTPUT, ' >>>> PASCAL PROGRAM FORMATTER VERS. 1/5/76 <<<<');
|     (*MESSAGE*)
|     WRITELN(OUTPUT, ' -----------------------------------------------');
|     WRITELN(OUTPUT);
| 
| """ LINELIMIT(OUTPUT, - 1);    """
|  (* UNLIMITED OUTPUT IS ALLOWED*)
|     CONSTANTSINITIALIZATION;   INITIALIZE;   READFORMATOPTIONS;
|     READACHARACTER;   WRITEA(' ');   READSYMBOL;
|     PROGISPASCAL2 := SYMBOLNAME = PROGRAMSYMBOL;
|     IF PROGISPASCAL2
|     THEN
|        BEGIN
|           STARTNEWLINEANDINDENT;   WRITESYMBOL;   READSYMBOL;
|           FOR I := 0 TO(LENGTH - 1) DIV 10 DO
| """          PACK(SYMBOL, (I * 10 + 1), MAIN[I + 1]);      """
| "SZH"        FOR PQ := 1 TO ALFLEN DO MAIN[I+1,PQ] := SYMBOL[I*10+PQ];
|           MAINNMLENGTH := LENGTH;
|           REPEAT WRITESYMBOL;   READSYMBOL;
|           UNTIL SYMBOLNAME = SEMICOLON;
|           WRITESYMBOL;   READSYMBOL;   STARTNEWLINEANDINDENT;
|           PSYMBOLNAME[7] := IDENTIFIER;
|           PSYMBOLNAME[31] := IDENTIFIER;
|           PSYMBOLNAME[32] := IDENTIFIER;
|        END (*IF PROGISPASCAL2*);
|     BLOCK(MAIN, MAINNMLENGTH);   WRITEA('.');   WRITEA(' ');
|     WITH UNWRITTEN[OLDEST] DO
|        BEGIN CHISENDLINE := TRUE;   INDENTAFTEREOL := 0; END;
|     WRITECOLUMN := 0;   FOR I := 0 TO 159 DO WRITEA(' ');
|     WRITELN(OUTPUT);
| 
|     IF SYMBOLNAME <> PERIODSYMBOL
|     THEN (*MESSAGE*)  WRITELN(OUTPUT, ' >>>> ERROR(S) IN FORMATTING.');
|     (*MESSAGE*)  WRITELN(OUTPUT, ' >>>> END FORMATTING');
|  END (*MAINPROGRAM*).
| PROGRAM PASCREF(INPUT,OUTPUT);      (*$D- N.WIRTH  2.7.75*)
| (*CROSS REFERENCE GENERATOR FOR PASCAL PROGRAMS*)
| (*QUADRATIC QUOTIENT HASH METHOD*)
| (*MODIFIED SLIGHTLY BY A. MICKEL 75/12/08 AND D. LALIBERTE
|   78/03/15 TO PRODUCE PROCEDURE LIST AND SKIP COMPILER TITLE*)
| (*$T-,P-,R-,B4 TESTS OFF, PMD OFF, DYNAMIC STORAGE, BIG BUFFERS.*)
| LABEL 99;
| CONST P = 1499;     (*SIZE OF HASH TABLE*)
|   NK = 33;          (*NO. OF KEYWORDS*)
|   KLN = 10;         (*KEYLENGTH*)
|   LPPG = 55;        (*NO. OF LINES PER PAGE*)
|   LLMAX = 132;      (*LINE LENGTH DEFAULT MAX*)
|   LLMIN = 72;       (*LINE LENGTH MINIMUM*)
|   MAXN = 10000;     (*MAX NO. OF LINES*)
|   DGPN =  6;        (*NO. OF DIGITS PER NUMBER*)
|   LITL = 3;         (*NUMBER OF LINES IN COMPILER TITLE*)
|   ADDRWIDTH = 6;    (*NUMBER OF DIGITS IN CODE ADDRESS*)
|   EMPTY = '          ';
|   STARS = ' *****';
| TYPE INDEX = 0..P;
|   ALFA = PACKED ARRAY [1..KLN] OF CHAR;
|   REF = @ITEM;
|   WORD = RECORD KEY: ALFA;
|            FIRST: REF;
|          END ;
|   ITEM = PACKED RECORD
|            LNO: 0..MAXN;
|            NEXT: REF
|          END ;
|   PROCREF = @PROC;  (*PROCEDURE OR FUNCTION REFERENCE*)
|   PROC = PACKED RECORD
|            NAME: ALFA;
|            LNO: 0..MAXN;
|            NEXT: PROCREF
|          END ;
| VAR I: INDEX;
|   K: INTEGER;
|   M: INTEGER;       (*NO. OF LINES ON PAGE*)
|   N: INTEGER;       (*NO. OF LINES INPUT*)
|   LN: INTEGER;      (*CURRENT LINE NUMBER*)
|   LLNGOUT: INTEGER; (*LINE LENGTH FOR OUTPUT*)
|   LLNGIN: INTEGER;  (*LINE LENGTH FOR INPUT*)
|   CCOUNT: INTEGER;  (*CHARACTER COUNT IN LINE*)
|   NOPL: INTEGER;    (*NO. OF LINE-NUMBERS PER LINE*)
|   ID: RECORD CASE BOOLEAN OF
|              FALSE: (A: ALFA);
|              TRUE:  (ORD: INTEGER)
|       END ;
|   T: ARRAY [INDEX] OF WORD;    (*HASH TABLE*)
|   KEY: ARRAY [1..NK] OF ALFA;
|   PROCORFUNC,
|   COMPILERLISTING,
|   LINENUMBERS: BOOLEAN;
|   FIRSTPROC,
|   PROCPTR: PROCREF; (*POINTERS TO CHAIN OF PROCEDURES*)
| 
| 
|    FUNCTION LETTER(C: CHAR): BOOLEAN;
| 
|      BEGIN
|      LETTER := (('A' <= C) AND (C <= 'Z')) OR
|                (('a' <= C) AND (C <= 'i')) OR
|                (('j' <= C) AND (C <= 'r')) OR
|                (('s' <= C) AND (C <= 'z')) ;
|      END ;
| 
|    FUNCTION DIGIT(C: CHAR): BOOLEAN ;
| 
|      BEGIN
|      DIGIT := ('0' <= C) AND (C <= '9') ;
|      END ;
| 
|    FUNCTION SPECIAL(C: CHAR): BOOLEAN;
|      BEGIN  SPECIAL := (C = '$') OR (C = '_')  END ;
| 
| FUNCTION NOKEY: BOOLEAN;
|    VAR I,J,K: INTEGER;
| BEGIN I := 1; J := NK;   (*BINARY SEARCH*)
|   REPEAT K := (I+J) DIV 2;
|     IF KEY[K] <= ID.A THEN I := K+1 ELSE J := K-1
|   UNTIL I > J;
|   IF J = 0 THEN NOKEY := TRUE ELSE
|     NOKEY := KEY[J] <> ID.A
| END (*NOKEY*) ;
| 
| PROCEDURE COUNTLINE;
| BEGIN
|   IF M = LPPG THEN
|     BEGIN PAGE(OUTPUT); WRITELN(OUTPUT);    WRITELN(OUTPUT);
|       M := 0
|     END;
|   M := M + 1
| END (*COUNTLINE*) ;
| 
| PROCEDURE ADVANCE;
| BEGIN
|   WRITE(OUTPUT,INPUT@); GET(INPUT);
|   CCOUNT := CCOUNT + 1;
|   IF CCOUNT = LLNGIN THEN
|     WHILE NOT EOLN(INPUT) DO
|       BEGIN WRITE(OUTPUT,INPUT@); GET(INPUT);
|       END
| END (*ADVANCE*);
| 
| PROCEDURE SPACE(J: INTEGER);
| BEGIN
|   REPEAT J := J-1; WRITELN(OUTPUT); COUNTLINE
|   UNTIL J = 0
| END (*SPACE*) ;
| 
| PROCEDURE NEWLINE;
| BEGIN CCOUNT := 0;
|   IF N < MAXN THEN
|   BEGIN COUNTLINE;  N := N + 1;
|     IF COMPILERLISTING THEN
|       BEGIN IF NOT EOLN THEN
|         BEGIN ADVANCE;
|         IF NOT (INPUT@ IN ['0'..'9']) THEN  (* ERRORS *)
|         IF NOT DIGIT(INPUT@) THEN  (* ERRORS *)
|           WHILE NOT EOLN DO
|             ADVANCE
|         ELSE BEGIN
|           FOR I := 1 TO ADDRWIDTH + 1  DO
|             ADVANCE;
|           WHILE (INPUT@ = ' ') AND NOT EOLN DO
|             ADVANCE
|           END
|         END
|       END
|     ELSE WRITE(OUTPUT,' ');
|     IF LINENUMBERS THEN
|       BEGIN LN := 0;
|       WHILE DIGIT(INPUT@) DO
|       WHILE INPUT@ IN ['0'..'9'] DO
|         BEGIN LN := 10*LN + ORD(INPUT@) - ORD('0');
|           ADVANCE
|         END
|       END
|     ELSE BEGIN
|       LN := N;  WRITE(OUTPUT,LN:6, ' ')
|       END
|     END
|   ELSE BEGIN
|     WRITELN(STARS, ' TEXT TOO LONG', STARS);
|      GOTO 99;  EXIT(99);
|     END
| END (*NEWLINE*) ;
| 
| PROCEDURE SEARCH;   (*MODULO P HASH SEARCH*)
|   VAR H,D: INDEX;
|       X: REF; F: BOOLEAN;
|       K: INTEGER;
| BEGIN  I := ABS(ID.ORD);  H := I MOD P;
|   F := FALSE; D := 1;
|   NEW(X); X@.LNO := LN;
|   REPEAT
|     IF T[H].KEY = ID.A THEN
|     BEGIN (*FOUND*) F := TRUE;
|       X@.NEXT := T[H].FIRST; T[H].FIRST := X;
|     END ELSE
|     IF T[H].KEY = EMPTY THEN
|     BEGIN (*NEW ENTRY*) F := TRUE;
|       T[H].KEY := ID.A;
|       T[H].FIRST := X; X@.NEXT := NIL
|     END ELSE
|     BEGIN (*COLLISION*) H := H+D; D := D+2;
|       IF H >= P THEN H := H-P;
|       IF D = P THEN
|         BEGIN WRITELN(OUTPUT); WRITELN(STARS,' TABLE FULL',STARS);    GOTO 99
|         EXIT(99);
|         END
|     END
|   UNTIL F
| END (*SEARCH*) ;
| 
| PROCEDURE SORT(MIN, MAX: INTEGER);
| 
| (* QUICKSORT WITH BOUNDED RECURSION DEPTH *)
| (* REQUIRES MIN <= MAX *)
| 
|    VAR
|          LOW,
|         HIGH: INDEX;
|       MIDKEY: ALFA;
|         TEMP: WORD;
| 
|    BEGIN
|       REPEAT (*PICK SPLIT POINT*)
|          MIDKEY := T[(MIN + MAX) DIV 2].KEY;
|          LOW := MIN;
|          HIGH := MAX;
|          REPEAT (*PARTITION*)
|             WHILE T[LOW].KEY < MIDKEY DO
|                LOW := LOW + 1;
|             WHILE T[HIGH].KEY > MIDKEY DO
|                HIGH := HIGH - 1;
|             IF LOW <= HIGH THEN
|                BEGIN
|                   TEMP := T[LOW];
|                   T[LOW] := T[HIGH];
|                   T[HIGH] := TEMP;
|                   LOW := LOW + 1;
|                   HIGH := HIGH - 1
|                END;
|          UNTIL LOW > HIGH;
| 
|          (*RECURSIVELY SORT SHORTER SUB-SEGMENT*)    (*A NOTE *)
|          IF HIGH - MIN < MAX - LOW
|          THEN    ¯ ANOTHER NOTEò  ¯ A FORTH ONE ò
|             BEGIN
|                IF MIN < HIGH THEN
|                   SORT(MIN, HIGH);
|   ¯THIS ONE ò  MIN := LOW
|             END
| " "      ELSE
|             BEGIN
|                IF LOW < MAX THEN
|                   SORT(LOW, MAX);
|                MAX := HIGH
|                END
|         UNTIL MAX <= MIN
|    END " SORT" """(*SORT*)";
| 
| 
| PROCEDURE " HERE " NOTEPROC;   (*NOTE INSTANCE OF PROCEDURE OR FUNCTION*)
|   VAR P: PROCREF;
| BEGIN PROCORFUNC := FALSE;
|   NEW(P); PROCPTR@.NEXT := P;
|   P@.NAME := ID.A; P@.LNO := LN; P@.NEXT := NIL;
|   PROCPTR := P
| END (*NOTEPROC*) ;
| 
| PROCEDURE PRINTWORD(W: WORD);
|   VAR L: INTEGER; X,Y,Z: REF;
| BEGIN COUNTLINE; WRITE(OUTPUT,' ', W.KEY);
|   X := W.FIRST; Y := X@.NEXT; X@.NEXT := NIL;
|   WHILE Y <> NIL DO
|     BEGIN Z := Y@.NEXT; Y@.NEXT := X; X := Y; Y := Z
|     END ;
|   L := 0;
|   REPEAT
|     IF L = NOPL THEN
|       BEGIN L := 0; WRITELN(OUTPUT); COUNTLINE; WRITE(OUTPUT,' ', EMPTY)
|       END;
|     L := L+1; WRITE(OUTPUT,X@.LNO: DGPN); X := X@.NEXT
|   UNTIL X = NIL;
|   WRITELN(OUTPUT);
| END (*PRINTWORD*) ;
| 
| PROCEDURE PRINTTABLE;
|   VAR I,M: INDEX;
| BEGIN M := 0;    (*COMPRESS TABLE*)
|   FOR I := 0 TO P-1 DO
|     IF T[I].KEY <> EMPTY THEN
|       BEGIN T[M] := T[I]; M := M+1
|       END ;
|   IF M > 0 THEN SORT(0,M-1);
|   NOPL := (LLNGOUT-KLN-1) DIV DGPN;
|   SPACE(2); WRITELN(' CROSS REFERENCE OF IDENTIFIERS,',
|             ' LABEL DECLARATIONS AND GOTO STATEMENTS:');
|   COUNTLINE; SPACE(1);
|   FOR I := 0 TO M-1 DO PRINTWORD(T[I])
| END (*PRINTTABLE*) ;
| 
| PROCEDURE PRINTPROCS;
| BEGIN SPACE(1); COUNTLINE;
|   WRITELN(' LIST OF PROCEDURES AND FUNCTIONS:');
|   COUNTLINE; SPACE(1);
|   PROCPTR := FIRSTPROC@.NEXT;
|   WHILE PROCPTR <> NIL DO
|     BEGIN WITH PROCPTR@ DO WRITELN(NAME:24,LNO:10);
|       COUNTLINE; PROCPTR := PROCPTR@.NEXT
|     END
| END (*PRINTPROCS*) ;
| 
| PROCEDURE INITIALIZE;
|   TYPE SETTING = PACKED RECORD
|                    CASE SWITCH: BOOLEAN OF
|                      TRUE: (ONOFF: CHAR);
|                      FALSE: (SIZE: 0..999999)
|                    END;
|   VAR S: SETTING;
|   FUNCTION OPTION(NAME: CHAR; VAR S: SETTING): BOOLEAN;
|     EXTERNAL;
| BEGIN N := 0; M := 0;
|   LLNGIN := LLMAX; LLNGOUT := LLMAX;
|    IF OPTION('U',S) THEN
|     IF S.SWITCH AND (S.ONOFF = '+')
|       THEN LLNGIN := LLMIN;
|   IF OPTION('W',S) THEN
|     IF S.SWITCH AND (S.ONOFF = '+')
|       THEN LLNGOUT := LLMIN;
|   FOR I := 0 TO P-1 DO T[I].KEY := EMPTY;
|   NEW(PROCPTR); FIRSTPROC := PROCPTR; PROCPTR@.NEXT := NIL;
|   PROCORFUNC := TRUE;   (*TO GET P R O G R A M NAME IN PROCEDURE INDEX*)
|   KEY[ 1] := 'AND       '; KEY[ 2] := 'ARRAY     ';
|   KEY[ 3] := 'BEGIN     '; KEY[ 4] := 'CASE      ';
|   KEY[ 5] := 'CONST     '; KEY[ 6] := 'DIV       ';
|   KEY[ 7] := 'DOWNTO    '; KEY[ 8] := 'DO        ';
|   KEY[ 9] := 'ELSE      '; KEY[10] := 'END       ';
|   KEY[11] := 'FILE      '; KEY[12] := 'FOR       ';
|   KEY[13] := 'FUNCTION  '; KEY[14] := 'IF        ';
|   KEY[15] := 'IN        '; KEY[16] := 'MOD       ';
|   KEY[17] := 'NIL       '; KEY[18] := 'NOT       ';
|   KEY[19] := 'OF        '; KEY[20] := 'OR        ';
|   KEY[21] := 'PACKED    '; KEY[22] := 'PROCEDURE ';
|   KEY[23] := 'PROGRAM   '; KEY[24] := 'RECORD    ';
|   KEY[25] := 'REPEAT    '; KEY[26] := 'SET       ';
|   KEY[27] := 'THEN      '; KEY[28] := 'TO        ';
|   KEY[29] := 'TYPE      '; KEY[30] := 'UNTIL     ';
|   KEY[31] := 'VAR       '; KEY[32] := 'WHILE     ';
|   KEY[33] := 'WITH      '
| END (*INITIALIZE*) ;
| 
| PROCEDURE SCANANDLISTINPUT;
| BEGIN
|   WHILE NOT EOF(INPUT) DO
|   BEGIN NEWLINE;
|     WHILE NOT EOLN(INPUT) DO
|     CASE INPUT@ OF
|      'a','b','c','d','e','f','g','h','i','j','k','l','m',
|      'n','o','p','q','r','s','t','u','v','w','x','y','z',
|      'A','B','C','D','E','F','G','H','I','J','K','L','M',
|      'N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
|       BEGIN K := 0; ID.A := EMPTY;
|         REPEAT
|           IF K < KLN THEN
|             BEGIN K := K+1; ID.A[K] := INPUT@
|             END;
|           ADVANCE
|         UNTIL NOT(INPUT@ IN ['A'..'Z', '0'..'9']);
|         UNTIL NOT(LETTER(INPUT@) OR DIGIT(INPUT@) OR SPECIAL(INPUT@));
|         IF NOKEY THEN
|         BEGIN SEARCH;
|           IF PROCORFUNC THEN NOTEPROC
|         END ELSE
|         IF (ID.A = 'PROCEDURE ') OR (ID.A = 'FUNCTION  ') THEN
|           PROCORFUNC := TRUE
|       END;
|      '0','1','2','3','4','5','6','7','8','9':
|         REPEAT ADVANCE;
|         UNTIL NOT (INPUT@ IN ['B','E','0'..'9']);
|         UNTIL NOT DIGIT(INPUT@) ;
|      '''':
|       BEGIN (*STRING*)
|         REPEAT ADVANCE;
|         UNTIL (INPUT@ = '''') OR EOLN(INPUT);
|         IF NOT EOLN(INPUT) THEN
|           ADVANCE
|       END;
| #    '"':
|       BEGIN (*COMMENT*)
|         REPEAT ADVANCE;
|           WHILE EOLN(INPUT) DO
|             BEGIN WRITELN(OUTPUT); GET(INPUT); NEWLINE
|             END
|         UNTIL INPUT@ = '"';
|         ADVANCE
|       END;
|      '(':
|       BEGIN ADVANCE;
|         IF INPUT@ = '*' THEN
|         BEGIN (*COMMENT*) ADVANCE;
|           REPEAT
|             WHILE INPUT@ <> '*' DO
|             BEGIN
|               IF EOLN(INPUT) THEN
|                 BEGIN GET(INPUT); WRITELN(OUTPUT); NEWLINE
|                 END ELSE
|                 ADVANCE
|             END ;
|             ADVANCE
|           UNTIL INPUT@ = ')';
|           ADVANCE
|         END
|       END;
|      '+','-','*','/',')','$','=',' ',',','.','[',']',
|      ':','!','×','&','@','?','<','>','Ö','\','^',';','#','_','%','ò':
|       ADVANCE
|     END (*CASE*) ;
|     WRITELN(OUTPUT); GET(INPUT)
|   END ;
| END (*SCANANDLISTINPUT*) ;
| 
| PROCEDURE SKIPCOMPILERTITLE;
|   VAR I: INTEGER;
| BEGIN
|   COMPILERLISTING := INPUT@ = '1';
|   IF COMPILERLISTING THEN
|   BEGIN I := 0; GET(INPUT);
|     WHILE I < LITL DO
|       BEGIN I := I + 1;
|         WHILE NOT EOLN(INPUT) DO
|           ADVANCE;
|         READLN; WRITELN(OUTPUT);
|       END;
|     COUNTLINE;
|     LINENUMBERS := TRUE
|   END ELSE
|   BEGIN WRITELN(OUTPUT); WRITELN(OUTPUT);
|     LINENUMBERS :=    INPUT@ IN ['0'..'9']    DIGIT(INPUT@)
|   END
| END (*SKIPCOMPILERTITLE*) ;
| 
| BEGIN (*CROSSREF*)
|    LINELIMIT(OUTPUT, MAXN);     PAGE(OUTPUT); INITIALIZE;
|   IF NOT EOF(INPUT) THEN
|   BEGIN SKIPCOMPILERTITLE;
|     SCANANDLISTINPUT;    LINELIMIT(OUTPUT, MAXN);
|     PRINTTABLE; PRINTPROCS
|   END ELSE WRITELN(STARS,' NO PROGRAM FOUND TO CROSS REFERENCE',STARS);
| 99:END .
> Member PINTERP
| (*$L+,C+,M-,D-*)
| PROGRAM PCODE_INTERPRETER(OUTPUT);
| 
| (* ASSEMBLER AND INTERPRETER OF PASCAL CODE.  K.JENSEN, N.WIRTH, E.T.H. 15.3.73
| 
| 
| NOTE FOR THE IMPLEMENTATION.
| ===========================
| THIS INTERPRETER IS WRITTEN FOR THE CASE WHERE ALL THE FUNDAMENTAL
| TYPES TAKE ONE STORAGE UNIT.
| IN AN IMPLEMENTATION ALL THE HANDLING OF THE SP POINTER HAS TO TAKE
| INTO ACCOUNT THE FACT TAHT THE TYPES MAY HAVE A LENGTH DIFFERENT FROM
| ONE. SO IN PUSH AND POP OPERATIONS THE IMPLEMENTOR HAS TO INCREASE
| AND DECREASE THE SP NOT BY 1 BUT BY A NUMBER DEPENDING ON THE TYPE
| CONCERNED.
| WHERE A COMMENT SAYS THAT SOME VARIABLE IS EXPRESSED 'IN UNITS OF
| STORAGE' THE VALUE OF THIS VARIABLE MUST NOT BE CORRECTED, BECAUSE
| THE COMPILER HAS COMPUTED IT TAKING INTO ACCOUNT THE LENGTHS OF THE
| TYPES INVOLVED.
| THE SAME HOLDS FOR THE HANDLING OF THE NP POINTER (WHICH MUST NOT BE
| CORRECTED)                                                       *)
| 
| (* MODIFIED 20.7.76, S. WOOD, STANFORD.
|    ===================================
| THIS INTERPRETER HAS BEEN MODIFIED TO ACCEPT 'TYPED' P-CODE, AS
| GENERATED BY THE S.L.A.C. COMPILER.
| IN ADDITION, A DYNAMIC TRACE FEATURE HAS BEEN ADDED.  THE TRACE IS
| TURNED ON OR OFF BY THE P-INSTRUCTIONS 'TON' AND 'TOF', RESPECTIVELY.
| THE PRESENCE OF A 'TON' INSTRUCTION ANYWHERE IN THE SOURCE P-CODE
| ALSO CAUSES A DUMP OF THE OBJECT CODE AFTER LOADING.
| *)
| (*$E*)
|   (**********************************************************************
|    *                                                                    *
|    *                                                                    *
|    *   P_Code Interpreter                                               *
|    *                                                                    *
|    *   This interpreter  interprets  the  P_Code  generated  by  the    *
|    *   Stanford  Pascal  Compiler  when used in "PM"+"CM" mode (i.e.    *
|    *   allocating one storage unit per basic data item).   It  reads    *
|    *   the  P_Code  program to be interpreted from file 'PFILE', and    *
|    *   sends its messages to the file 'OUTPUT'.  The  file  'OUTPUT'    *
|    *   and  other predefined Pascal files may be used by the program    *
|    *   being interpreted.                                               *
|    *                                                                    *
|    *   The   interpreter   can   provide   (optional)    statistical    *
|    *   information about the program it is interpreting.  The P_Code    *
|    *   related  statistics  are  sent  to  'SFL'  and  stack related    *
|    *   information is directed to 'TRFILE'.  The size of the largest    *
|    *   program that can be interpreted is determined by 'MAXPC'  and    *
|    *   the  size  of  the  run  time  stack  is set by 'MAXSTK'.  By    *
|    *   setting  'MAXPC  =  18500'  and  'STKMAX  =  30000'  you  can    *
|    *   interpret the Compiler compiling  a  reasonably  large  (i.e.    *
|    *   5000  lines)  program  and  the  interpreter will need a 600k    *
|    *   region for such a compilation.  Also note that running Pascal    *
|    *   programs in this nterpretive form is very expensive in  terms    *
|    *   of  the  CPU  time  and  is not suggested as a normal mode of    *
|    *   operation.                                                       *
|    *                                                                    *
|    *   further updates and new features will be listed below.           *
|    *                                                                    *
|    *                                                                    *
|    *   -THE  PROBLEM  ASSOCIATED   WITH   'FORWARD   REFERENCE'   TO    *
|    *   PROCEDURES IS FIXED AND SIZE OF 'STORE' AND 'CODE' ARRAYS ARE    *
|    *   INCREASED   SO  THAT  THE  INTERPRETER  MAY  'INTERPRET'  THE    *
|    *   P_COMPILER WHILE COMPILING AVERAGE SIZE PROGRAMS.                *
|    *                                                                    *
|    *   -THE  INTERPRETER  CAN  NOW  PROVIDE   DYNAMIC   AND   STATIC    *
|    *   INFORMATION  ABOUT  THE  OCCURANCE  FREQUENCIES OF INDIVIDUAL    *
|    *   P_INSTRUCTIONS AS WELL AS INSTRUCTION PAIRS.                     *
|    *                                                                    *
|    *       GETSTAT  -->  ENABLES 'COUNTING' PROCEDURES                  *
|    *       STAT1    -->  PRINT DETAILED BREAKDOWN FOR EACH              *
|    *                     INSTRUCTION BY THE OPERAND TYPE                *
|    *       STAT2    -->  PRINT FREQUENCY OF ADDRESS/OPERAND             *
|    *                     FOR LOD, STR, INC, DEC, IXA... ETC.            *
|    *       STAT3    -->  PRINT FREQUENCY AND BRANCH DISTANCE            *
|    *                     FOR JUMP INSTRUCTIONS.                         *
|    *       STAT4    -->  PRINT INSTRUCTION PAIR STATISTICS              *
|    *       STAT5    -->  PRINT MATRIX OF INSTRUCTION PAIR FREQUENCY.    *
|    *       STAT6    -->  GENERATE PUSH/POP, CALL/RETURN STACK TRACE.    *
|    *       STAT9    -->  PRINT FULL DETAILS OF THE ABOVE TABLES.        *
|    *                                                                    *
|    *       STAT4, STAT2 AND STAT3, IF ENABLED WHILE INTERPRETING,       *
|    *       COULD BE QUITE COSTLY WITH THE COST INCREASING IN THAT       *
|    *       ORDER. THE ADDED COST FOR THE STATIC STATISTICS              *
|    *       (COLLECTED DURING THE LOADING PHASE) IS LESS DRAMATIC        *
|    *       THOUGH.                                                      *
|    *                                                                    *
|    *                                                                    *
|    *   -THE INTERPRETER HAS BEEN MODIFIED AND FIXED  TO  CONFORM  TO    *
|    *   THE NEW P_CODE AS GENERATED BY THE APR_79 VERSION OF THE SLAC    *
|    *   PASCAL  COMPILER,  THE MODIFICATION INVOLVES THE 'DEF', 'XJP'    *
|    *   'NEW', 'SAV' AND 'RST' INSTRUCTIONS.                             *
|    *                                                                    *
|    *                                                                    *
|    *                                Sassan Hazeghi,                     *
|    *                                Computation Research Group,         *
|    *                                Stanford Linear Accelerator Center  *
|    *                                                                    *
|    *                                                                    *
|    *                                updated:  july 76                   *
|    *                                          sep. 76                   *
|    *                                          oct. 76                   *
|    *                                          may  77                   *
|    *                                          feb. 79                   *
|    *                                          may. 79                   *
|    *                                                                    *
|    *                                                                    *
|    **********************************************************************)
| 
| (*----------------------------------------------------------------------------*)
| 
| 
| CONST  MAXPC       = 20000; (* SIZE OF PROGRAM AREA *)
|        MAXCODE     = MAXPC; (* PROGRAM COUNTER RANGE *)
|        MAXSTK      = 40000; (* TOTAL SIZE OF STACK+HEAP+CONSTANT POOL*)
| """    MAXSTK      = 30000; (* SIZE OF RUNTIME STACK *)
|        OVERI       = 32010; (* SIZE OF INTEGER CONSTANT TABLE = 10 *)
|        OVERR       = 32220; (* SIZE OF REAL CONSTANT TABLE = 210 *)
|        OVERS       = 32300; (* SIZE OF SET CONSTANT TABLE =  80 *)
|        OVERB       = 32400; (* SIZE OF BOUNDARY CONSTANT TABLE = 200 *)
|        OVERM       = 35900; (* SIZE OF MULTIPLE CONSTANT TABLE = 2500 *) """
|        LARGEINT    = 524288;  (* = 2**19 *)
|       "MAXINT      = 2147483641 ;"
|        MAXADR      = MAXINT     ;
|        LTSIZE      = 550  ;   (* SIZE OF THE LINEARIZED 'COUNT' TABLE *)
|        STRNGLEN    = 64;      (* MAX STRING LENGHT *)
|        INPUTADR    = 6  ;     (* ABSOLUTE ADDRESS *)
|        OUTPUTADR   = 7  ;
|        PRDADR      = 8  ;
|        PRRADR      = 9  ;
|        QRDADR      = 10 ;
|        QRRADR      = 11 ;
|        LSTBUF      = 15 ;
|        NILVAL      = MAXSTK;
|        BLNK3       = '   ' ;  BLNK8 = '        ' ;
|        MAXLBLCNT   = 1200 ; (* COUNT OF LABELS *)
|        MAXLABEL    = 650 ;  (* COMPLETE COMPILER PROCESSING *)
|        MINLABEL    = 360 ;  (*NEGATIVE INDICIES FOR PROCEDURE LABELS*)
|        MAXPROC     = MINLABEL ;
|        MINPROC     = 0 ;
|        PTRSIZE     = 1 ;     (* HAS TO BE UPDATED FOR DIFFERENT DATA SIZES*)
|        OSPARMLOC   = 16;     (* LOCATION FOR OSPARM VARIABLE *)
|        LCAFTMST    = 16;     (* LOCATION AFTER MARK STACK *)
|        SAVEAREA    = 16;     (* SAVE AREA FOR THE 370 IMPLEMENTATION*)
|        TIMEDATELOC = 20;     (* LOCATION OF TIME/DATE PREDEF. VARS *)
|        FUNCRSLT    = 0 ;     (* LOCATION (OFF MP) OF THE FUNC RESULT *)
| 
|        (* P-CODE INSTRUCTION MNEMONICS *)
| 
|        PABI =  0 ;   PABR =  1 ;   PADI =  2 ;   PADR =  3 ;
|        PAND =  4 ;   PCHK =  5 ;   PCHR =  6 ;   PCSP =  7 ;
|        PCUP =  8 ;   PDEC =  9 ;   PDEF = 10 ;   PDIF = 11 ;
|        PDVI = 12 ;   PDVR = 13 ;   PENT = 14 ;   PEOF = 15 ;
|        PEQU = 16 ;   PFJP = 17 ;   PFLO = 18 ;   PFLT = 19 ;
|        PGEQ = 20 ;   PGRT = 21 ;   PINC = 22 ;   PIND = 23 ;
|        PINN = 24 ;   PINT = 25 ;   PIOR = 26 ;   PIXA = 27 ;
|        PLAO = 28 ;   PLCA = 29 ;   PLDA = 30 ;   PLDC = 31 ;
|        PLDO = 32 ;   PLEQ = 33 ;   PLES = 34 ;   PLOC = 35 ;
|        PLOD = 36 ;   PMOD = 37 ;   PMOV = 38 ;   PMPI = 39 ;
|        PMPR = 40 ;   PMST = 41 ;   PNEQ = 42 ;   PNEW = 43 ;
|        PNGI = 44 ;   PNGR = 45 ;   PNOT = 46 ;   PODD = 47 ;
|        PORD = 48 ;   PPRE = 49 ;   PRET = 50 ;   PRST = 51 ;
|        PSAV = 52 ;   PSBI = 53 ;   PSBR = 54 ;   PSGS = 55 ;
|        PSQI = 56 ;   PSQR = 57 ;   PSRO = 58 ;   PSTO = 59 ;
|        PSTP = 60 ;   PSTR = 61 ;   PUJP = 62 ;   PXJP = 63 ;
|        PTON = 64 ;   PTRC = 65 ;   PSUC = 66 ;   PUNI = 67 ;
|        PTOF = 68 ;   PBGN = 69 ;   PLCI = 70 ;   PCMP = 71 ;
|        PNOP = 72 ;
| 
|        SPCNT = 32 ;                (* COUNT OF STANDARD PROCS *)
| 
|        UNDEF = '0' ;  INT = '1' ;  REEL = '2' ;  BOOL = '3' ;
|        SETT  = '4' ;  ADR = '5' ;  MARK = '6' ;  INDEX= '7' ;
| """    UNDEF = 0 ;  INT = 1 ;  REEL = 2 ;  BOOL = 3 ;
|        SETT  = 4 ;  ADR = 5 ;  MARK = 6 ;  INDEX= 7 ;   """
| 
|       "ENTERED = 0 ;  DEFINED = 1 ;"
| (*----------------------------------------------------------------------------*)
| 
| TYPE  BIT4         = 0..MAXLBLCNT ;
|       BIT7         = 0..70;
|       BIT20        = -524287..524287;
|       OPRNG        = 0..PNOP;
|       DATATYPE     = CHAR (* I.E. UNDEF..INDEX *) ;
|       LBLRNG       = MINPROC..MAXLABEL ;
|       LBLCNTRNG    = 0..MAXLBLCNT ;
|       ADDRESS      = -1..MAXSTK;
|       POSINT       = 0..MAXADR ;
|       ALFA         = PACKED ARRAY [1..8] OF CHAR ;
|       SHRTALFA     = PACKED ARRAY [1..3] OF CHAR ;
|       BETA         = PACKED ARRAY[1..20] OF CHAR; (*ERROR MESSAGE*)
|       COUNTER      = 0..MAXINT ;
|       COUNTER1     = -1..MAXINT ;
| 
|       LABELST      = (ENTERED,DEFINED);  (* LABEL SITUATION *)
|       LABELREC     = RECORD
|          VAL: -1..MAXADR  ;
|          ST: LABELST
|          END ;
| 
|       TEXT         = FILE OF CHAR ;
| 
|       CNTBIN       = RECORD
|                        VAL :  INTEGER ;
|                        CNT :  COUNTER ;
|                        NXT :  @ CNTBIN
|                      END ;
| 
| (*----------------------------------------------------------------------------*)
| VAR
|      (* INSTRUCTION REGISTER, OPCODE, T, P AND Q FIELDS *)
| 
|      OP, OLDOP     : -1..PNOP;
|      T             : DATATYPE;
|      P             : ADDRESS;
|      Q             : INTEGER;
| 
|      (* MP:      ACTIVATION RECORD POINTER,
|         SP:      TOP ELEMENT OF EXPRESSION EVALUATION STACK,
|         NP:      POINTER TO NEXT AVAILABLE HEAP AREA (GROWS DOWN !)
|         EP:      PROGRAM ENTRY POINT,
|         CPL:     END OF THE HEAP, BEGINING OF CONSTANT POOL,
|         PC:      P_PROGRAM COUNTER,
|         CURLVL:  STATIC LEVEL OF CURRENTLY ACTIVE PROCEDURE,         *)
| 
|      MP,
|      SP,
|      NP,
|      EP,
|      CPL           : ADDRESS;
|      PC            : 0..MAXPC;
|      CURLVL        : BIT4;
| 
|      (* VARIOUS SWITCHES AND COUNTERS *)
| 
|      LOADING,
|      STRACE,
| (*   CTRACE,                                                              (*+*)
|      INTERPRETING,
|      GETSTAT,
|      STAT1,
|      STAT4,
|      STAT2,
|      STAT3,
|      STAT5,
|      STAT6,
|      STAT9,
|      TRCE, DMP      : BOOLEAN;
| 
|      PUSHCNT,
|      POPCNT,
|      MAXCALL,
|      CSTP,
|      TBUFP,
|      INSTRCNT      : INTEGER;
| 
|      STK_LMT,
|      HEAP_LMT      : ADDRESS;
| 
|      (* VARIOUS TABLES, BUFFERS AND COUNTER ARRAYS *)
| 
|      INSTR         : ARRAY[PABI..PNOP] OF SHRTALFA;(*MNEMONIC INST. CODES *)
|      DISPLAY       : ARRAY [1..10] OF ADDRESS ;
| 
|      PINX, QINX,                                       (* INDEX TO SCNT *)
|      PCNT          : ARRAY [PABI..PNOP] OF INTEGER ;   (* P_INST. COUNTS *)
|      ACNT          : ARRAY [PABI..PNOP] OF @ CNTBIN ;  (* CONST. VALUE COUNTS *)
|      SCNT          : ARRAY [0..LTSIZE] OF INTEGER ;    (* SPECIAL INST. COUNT.*)
|      TBUF:           ARRAY[0..79] OF CHAR;            (* PUSH/POP TRACE BUF *)
| 
|      (* P_MACHINE CODE AND DATA SPACES *)
| 
|      CODE          : ARRAY[0..MAXCODE] OF   (* THE PROGRAM *)
|                      PACKED RECORD  OP1    :INTEGER; ":BIT7;"
|                                    "P1     :BIT4;"
|                                     Q1     :INTEGER";
|                                     T1     :DATATYPE ;
|                                     OP2    :BIT7;
|                                     P2     :BIT4;
|                                     Q2     :INTEGER ;
|                                     T2     :DATATYPE  "
|                             END;
| 
|      STYPE:          ARRAY [ADDRESS] OF DATATYPE;
| 
|      STORE         : ARRAY [ADDRESS] OF
|                         RECORD   CASE "STYPE :"DATATYPE OF
|                                 INT        :(VI :INTEGER);
|                                 REEL       :(VR :REAL);
|                                 BOOL       :(VB :BOOLEAN);
|                                 SETT       :(VS :SET OF 0..63);
|                                 ADR        :(VA :ADDRESS); (*ADDRESS IN STORE*)
|                                 MARK       :(VM :INTEGER)
|                         END;
| 
|      SPTABLE       : ARRAY[0..SPCNT] OF SHRTALFA;   (* STANDARD FNS AND PROCS *)
|         PROCTAB       : ARRAY [MINPROC..MAXPROC] OF ALFA ;
|      BDCNT         : ARRAY [LBLCNTRNG] OF
|                            RECORD  CNT: COUNTER1 ;  VAL : INTEGER  END ;
| 
|      CORTBL        : ARRAY[PABI..PNOP,PABI..PNOP] OF INTEGER ;  (* INST. PAIR *)
| 
|      STRBUF:         ARRAY[0..STRNGLEN] OF CHAR;  (* BUFFER FOR STRING CONST. *)
|      HEADLN:         ARRAY[1..36] OF CHAR;        (* HEADING OF THE P_PROGRAM *)
|      IVECTOR       : ARRAY['A'..'Z'] OF INTEGER ; (* INDEX INTO P_CODE TABLE *)
|      CALLSTK:        ARRAY[0..100] OF INTEGER;    (* NEST OF CALL STACK *)
| 
|      NEEDOPNDS     : SET OF 0..63 ;  (* OPCODES THAT HAVE OPERANDS *)
| 
|      NXTUJP,NXTFJP : LBLCNTRNG ;
|      TIMER,
|      RETCDE,
|      GAC, IAC, LAC:  INTEGER;               (* GLOBAL/LOCAL/INT. ACCESS *)
| 
|      (* INTERPRETER I/O FILE DEFINITIONS *)
| 
|      PFILE         : TEXT ;                 (* P_CODE INPUT FILE *)
| 
|      SFL           : TEXT ;                 (* INTERP. STATISTICS OUTPUT FILE *)
| 
|      TRFILE        : TEXT ;                 (* STACK ACTIVITY TRACE FILE *)
| 
| 
| (*$D-*)
| (*----------------------------------------------------------------------------*)
| 
| PROCEDURE STK_TRACE ;
| 
|    (* TO GENERATE THE TRACE OF STACK ACTIVITY PUSH/POP AS WEEL AS CALL/RET. *)
|    (* OUTPUTS AN 'A' TO 'TRFILE' FILE TO INDICATE A  PUSH         *)
|    (*            'S' "    "      "        "          POP          *)
|    (*            'P' "    "      "        "          POP PARM.    *)
|    (*            'C' "    "      "        "          CALL         *)
|    (*            'R' "    "      "        "          RETURN       *)
|    (*                                                             *)
| 
|    VAR I, J: INTEGER;
| 
|    PROCEDURE DOPUSH(C: CHAR) ;
| 
|       BEGIN
|       IF STRACE "AND (C IN ['C', 'R'])" THEN
|          BEGIN  PUSHCNT := PUSHCNT+1;  TBUF[TBUFP] := C;  TBUFP := TBUFP+1;
|          IF TBUFP = 80 THEN  BEGIN  WRITE(TRFILE,TBUF);  TBUFP := 2;  END;
|          END;
|       END (*DOPUSH*);
| 
| 
|    PROCEDURE DOPOP(C: CHAR);
| 
|       BEGIN
|       IF STRACE "AND (C IN ['C', 'R'])" THEN
|          BEGIN  POPCNT := POPCNT+1;  TBUF[TBUFP] := C;  TBUFP := TBUFP+1;
|          IF TBUFP = 80 THEN  BEGIN  WRITE(TRFILE, TBUF);  TBUFP := 2  END;
|          END;
|       END (*DOPOP*);
| 
| 
| 
|    BEGIN
| 
|       CASE OP OF
| 
|       PLCA, PLCI, PLDC, PLOD, PLDA :
|          DOPUSH('A');
| 
|       PABI, PABR, PNGI, PNGR, PNOT:
|          BEGIN  DOPOP('S');  DOPUSH('A');  END;
| 
|       PEQU, PNEQ, PGRT, PGEQ, PLES, PLEQ,
|       PADI, PSBI, PMPI, PDVI, PMOD, PADR,
|       PSBR, PMPR, PDVR, PAND, PIOR,
|       PDIF, PINT, PUNI, PINN:
|          BEGIN  DOPOP('S');  DOPOP('S');  DOPUSH('A')  END;
| 
|       PSTR, PIXA, PXJP, PFJP,
|       PNEW, PSAV, PRST:
|          DOPOP('S');
| 
|       PSTO, PMOV :
|          BEGIN  DOPOP('S'); DOPOP('S') END ;
| 
|       PMST :
|          BEGIN  CSTP := CSTP+1 ;  CALLSTK[CSTP] := PUSHCNT-POPCNT ; END ;
| 
|       PCUP :
|          BEGIN  J := (PUSHCNT-POPCNT)-CALLSTK[CSTP] ;
|          FOR I := 1 TO J DO DOPOP('P') ;  (*POPS PARAMETERS OFF THE STACK*)
|          IF LOADING THEN
|             BEGIN
|             IF T <> UNDEF THEN DOPUSH('A');  (*FUNCTION CALL LEAVES A RESULT*)
|             IF MAXCALL < CSTP THEN  MAXCALL := CSTP;
|             CSTP := CSTP-1;
|             END
|          ELSE  (*I.E. INTERPRETING*)  DOPUSH('C');
| 
|          END ;
| 
|       PCSP :
|          BEGIN
|          IF Q = 28 (*PSIO*) THEN  STRACE := FALSE
|          ELSE IF Q = 29 (*PEIO*) THEN  BEGIN  STRACE := TRUE;  DOPOP('S')  END
|          ELSE IF Q IN [24, 7 (*PEOF, PELN*)] THEN
|             BEGIN STRACE := TRUE; DOPUSH('A');  STRACE := FALSE END
|          ELSE IF Q IN [14, 15, 16, 17, 18, 19
|                       (*PSIN, PCOS, PATN, PEXP, PLOG, PSQT*)] THEN
|                       BEGIN  DOPOP('S');  DOPUSH('A');  END
|          ELSE IF Q IN [2, 4, 20 (*PRST, PNEW, PSAV*)] THEN  DOPOP('S')
|          END ;
| 
|       PRET :
|          IF INTERPRETING THEN
|             BEGIN
|             IF MAXCALL < CSTP THEN MAXCALL := CSTP;
|             IF T <> UNDEF THEN DOPUSH('A');
|             DOPOP('R');  (*FLAG PROC. RETURN*)
|             CSTP := CSTP-1;
|             END;
| 
| 
|       END (*CASE OP OF*);
| 
| 
|    END (*STK_TRACE*);
| 
| (*----------------------------------------------------------------------------*)
| 
| 
| FUNCTION  WRF(VAR F:TEXT; X: REAL; M,N: INTEGER): CHAR;
|    (* WRITE REAL NUMBER X IN FIXED-POINT FORMAT;
|     M CHARACTERS, N AFTER THE '.' *)
|    CONST T31 = 214731364(*7*);  (* (2**32-1) DIV 10 *)
|          REALT31 = 214731364.0;
|      (*  Z = 27; *)   (* ORD('0') *)
|    TYPE POSINT = 0..99;
|    VAR C,D,E,R,K2,K3,I: INTEGER;
|        SIGN: CHAR;
| 
| BEGIN
|    IF ABS(X) > T31*10  THEN
|    BEGIN FOR I:=1 TO N-1 DO BEGIN F@:='#'; PUT(F) END;
|       F@:='U'; PUT(F)
|    END ELSE
|    BEGIN
|       IF X<0 THEN
|          BEGIN SIGN := '-'; X := -X
|          END ELSE SIGN := ' ';
| 
|      IF X < 1.0E-10 THEN X := 0;
| 
|       (* X = 0: A SPECIAL CASE *)
|       IF X=0 THEN
|       BEGIN  REPEAT  F@ := ' '; PUT(F); M := M-1 UNTIL M<=1;
|              F@ := '0'; PUT(F)
|       END ELSE
|       BEGIN (* CHECK SIGN AND DETERMINE SCALE FACTOR *)
|          (*E := EXPO(X);*)   E := 0;
|          IF X >= 1.0 THEN
|             REPEAT  X := X(*/10.0*) * 0.1; E := E + 1   UNTIL X < 1.0
| 
|          ELSE  IF X < 0.1 THEN
|                   REPEAT  X := X * 10.0; E := E - 1   UNTIL X >= 0.1 ;
| 
|          (* 0.1 <= X < 1.0 *)
|          R := N+E;
| 
|          IF (R >= 1) OR (R <= 9) THEN
| 
|             CASE R OF      (* ROUNDING *)
|               1: X := X+0.5E-1;
|               2: X := X+0.5E-2;
|               3: X := X+0.5E-3;
|               4: X := X+0.5E-4;
|               5: X := X+0.5E-5;
|               6: X := X+0.5E-6;
|               7: X := X+0.5E-7;
|               8: X := X+0.5E-8;
|               9: X := X+0.5E-9;
|              10: X := X+0.5E-10;
|              11: X := X+0.5E-11;
|              12: X := X+0.5E-12;
|              13: X := X+0.5E-13
|             END
| 
|          ELSE X := X+0.5E-9;
| 
|          IF X >= 1.0 THEN  BEGIN X := X * 0.1; E := E+1 END ;
|          IF E>0 THEN BEGIN M := M-N-E-2;  K2 := E;  K3 := 0  END
|          ELSE
|          BEGIN M := M-N-3;  K2 := 0;
|             IF N+E >= 0 THEN K3 := -E ELSE K3 := N;
|             N := N-K3
|          END;
|          IF M <= 0 THEN M := (*1*) 0;
|          (* M BLANKS, SIGN, K2 DIGITS, '.', K3 ZEROES, N DIGITS *)
|          WHILE M > 0 DO BEGIN    F@ := ' '; PUT(F); M := M-1  END ;
|          F@ := SIGN; PUT(F);
|          C := TRUNC(X*REALT31+0.5); D := 0;
|          IF K2=0 THEN BEGIN F@ := '0'; PUT(F) END ELSE
|             REPEAT C := (C - D*T31) * 10;
|                    D := C DIV T31;
|                   F@ := CHR(D+ ORD('0') ); PUT(F);  K2 := K2-1
|             UNTIL K2=0;
|          F@ := '.'; PUT(F);
|          WHILE K3<>0 DO
|             BEGIN F@ := '0'; PUT(F); K3 := K3-1
|             END;
|          WHILE N<>0 DO
|          BEGIN C := (C - D*T31) * 10;
|                D := C DIV T31;
|                F@ := CHR(D+ ORD('0') ); PUT(F); N := N-1
|          END
|       END
|    END ;
|    WRF := ' ';
| END (* WRF *);
| 
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE PRINT_HEADLN(VAR F: TEXT);
| 
|    BEGIN
|    REWRITE(F);
|    WRITELN(F, '    < Stanford P_Code Interpreter, Version of May 79. >');
|    WRITELN(F);  WRITELN(F);
| 
|    IF LOADING THEN
|       BEGIN
|       WRITELN(F, '    < P_INSTRUCTIONS'' STATIC STATISTICS >') ;
|       WRITELN(F);  WRITELN(F);
|       WRITELN(F, '    >>>>  LOADING: ', HEADLN);
|       WRITELN(F);  WRITELN(F);
|       WRITELN(F, '>>>>  ':10,  PC:5, ' INSTRUCTIONS AND  ',
|                  MAXSTK-CPL-1:1, ' CONSTANTS LOADED, ',
|                  WRF(F, TIMER/1000, 6, 1):01, ' SECONDS IN LOADING.') ;
|       END
|    ELSE
|       BEGIN
|       WRITELN(F, '    < P_INSTRUCTIONS'' DYNAMIC STATISTICS >') ;
|       WRITELN(F);  WRITELN(F);
|       WRITELN(F, '    >>>>  INTERPRETING: ', HEADLN);
|       WRITELN(F);  WRITELN(F);
|       WRITELN(F,'    --->  I_CNT:  ',INSTRCNT:4,',  SP: ', SP:5,',  NP: ', NP:4,
|                 ',  MP: ',MP:4, ',  PC: ',  PC:5, '  OP =', INSTR[OP]:4,
|                 '  (', OP:3, '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:5, ')' );
|       WRITELN(F);  WRITELN(F);
|       WRITELN(F, '>>>>  ':10, INSTRCNT:5, ' INSTRUCTIONS INTERPRETED IN  ',
|                  WRF(F, TIMER/1000, 8, 1):01, ' SECONDS.' ) ;
|       WRITELN(F);  WRITELN(F);
|       WRITELN(F, '>>>>  ':10, ' TOTAL STACK USAGE= ',STK_LMT:2,
|                  ',  HEAP USAGE= ', CPL-HEAP_LMT:2, '  STORAGE UNITS.');
|       END (*IF INTERPRETING*);
| 
|    END (*PRINT_HEADLN*);
| 
| (*------------------------------------------------------------------------*)
| 
| 
| PROCEDURE CLEARCOUNTS ;      (*TO CLEAR STATIC/DYNAMIC COUNTERS*)
|    VAR  I, J : INTEGER ;   PTR : @CNTBIN ;
|    BEGIN   OLDOP := PNOP ;
| 
|    FOR I := PABI TO PNOP DO
|       BEGIN  PCNT[I] := 0 ;  PINX[I] := 0 ;
|       PTR := ACNT[I] ;
|       REPEAT  PTR@.CNT := 0 ;  PTR := PTR@.NXT ;   UNTIL PTR = NIL ;
|       FOR  J := PABI TO PNOP DO  CORTBL[I,J] := 0 ;
|       END ;
| 
|    PINX[PRET] :=   0 ;  PINX[PLDA] :=  10 ;  PINX[PEQU] :=  20 ;
|    PINX[PGEQ] :=  26 ;  PINX[PGRT] :=  32 ;  PINX[PLDC] :=  38 ;
|    PINX[PLEQ] :=  44 ;  PINX[PLES] :=  50 ;  PINX[PNEQ] :=  56 ;
|   "PINX[PRET] :=  62 ;" PINX[PIND] :=  68 ;  PINX[PLDO] :=  74 ;
|    PINX[PSRO] :=  80 ;  PINX[PSTO] :=  86 ;  PINX[PCUP] :=  92 ;
|    PINX[PLOD] := 152 ;  PINX[PSTR] := 212 ;  PINX[PCSP] := 272 ;
|    PINX[PMST] := 304 ;  PINX[PENT] := 320 ;
| 
|    QINX[PLOD] := 380 ;  QINX[PSTR] := 450 ;  QINX[PLDA] := 520 ;
|    QINX[PMST] := 530 ;
| 
|    FOR I := 0 TO LTSIZE DO SCNT[I] := 0 ;
| 
|    FOR I := 0 TO MAXLBLCNT DO BDCNT[I].CNT := 0 ;
| 
|    PUSHCNT := 0;  POPCNT := 0;  CSTP := 0;                 (*++++++++*)
|    TBUFP := 2;  MAXCALL := 0;  STRACE := TRUE;             (*++++++++*)
| (*    CTRACE := TRUE;                                                     (*+*)
|    TBUF[0] := '$';  TBUF[1] := ' ';                        (*++++++++*)
|    IF INTERPRETING THEN TBUF[0] := '#';                    (*++++++++*)
|    END (*CLEARCOUNTS*) ;
| (*----------------------------------------------------------------------------*)
| 
| PROCEDURE COUNT ;            (*TO ACCUMULATE STSTIC/DYNAMIC INSTR. COUNTS*)
|    VAR  J, K, TT : INTEGER ;   PTR, PTR2: @ CNTBIN ;
|    BEGIN
|    IF STAT6 THEN  STK_TRACE;                                       (*+++++++++*)
|    PCNT[OP] := PCNT[OP]+1 ;
| 
|      IF STAT1 THEN
| 
|        BEGIN   TT := ORD(T)-ORD(UNDEF);  J := PINX[OP];
| 
|        CASE OP OF
| 
|           PLDA,PMST:  (* SEGREGATE BY LEVEL *)
|              BEGIN
|              SCNT[ J  + P] := SCNT[ J  + P] + 1 ;
|              K := CURLVL-P;
|              SCNT[QINX[OP]+K+ TT] := SCNT[QINX[OP]+K+ TT]+1;
| 
|              IF LOADING THEN
|                 IF OP = PLDA THEN
|                    IF P = 1 THEN GAC := GAC+1
|                    ELSE IF P = CURLVL THEN LAC := LAC+1
|                    ELSE               IAC := IAC+1;
| 
|              END;
| 
|           PRET,PEQU,PGEQ,PGRT,PLDC,PLEQ,PLES,PNEQ:
|           (* SEGREGATE BY TYPE *)
|              SCNT[ J  + P] := SCNT[ J  + P] + 1 ;
| 
|           PIND,PSTO",PLDO,PSRO":  (* SEGREGATE BY TYPE *)
|              BEGIN
|                 SCNT[ J  + TT] := SCNT[ J  + TT] + 1  ;
|              END  (* IND,STO",LDO,SRO" *) ;
| 
|           PLOD,PSTR:  (* SEGREGATE BY TYPE AND LEVEL *)
|              BEGIN
|                 SCNT[ J  + P * 6 + TT] := SCNT[ J  + P * 6 + TT] + 1;;
|                 K := 6*(CURLVL-P);
|                 SCNT[QINX[OP]+K+ TT] := SCNT[QINX[OP]+K+ TT]+1;
| 
|              IF LOADING THEN
|                 IF P = 1 THEN GAC := GAC+1
|                 ELSE IF P = CURLVL THEN LAC := LAC+1
|                 ELSE               IAC := IAC+1;
| 
|              END  (* PLOD,PSTR *) ;
| 
|           PCUP,PENT:  (* SEGREGATE BY TYPE AND LEVEL *)
|              BEGIN
|                 SCNT[ J  + P * 6 + TT] := SCNT[ J  + P * 6 + TT] + 1;;
|              END  (* PCUP,PENT *) ;
| 
|           PCSP:  (* SEGREGATE BY PROCEDURE NUMBER *)
|              SCNT[ J  + Q] := SCNT[ J  + Q] + 1 ;
| 
|           PABI,PABR,PADI,PADR,PAND,PCHK,PCHR,PDEC,PDIF,PDVI,PDVR,
|           PEOF,PFJP,PFLO,PFLT,PINC,PINN,PINT,PIOR,PIXA,PLAO,PLCA,
|           PLOC,PMOD,PMOV,PMPI,PMPR,PNGI,PNGR,PNOT,PODD,PORD,
|           PPRE,PSBI,PSBR,PSGS,PSQI,PSQR,PSTP,PSUC,PTOF,PTON,PTRC,
|           PUJP,PUNI,PXJP,PLCI:
|              PINX[OP] := PINX[OP] + 1
| 
|        END  (* CASE OP *) ;
| 
| 
|     """IF OP <= PSTR THEN
|           BEGIN
| 
|           IF OP IN [PLOD, PSTR, PLDA, PMST] THEN
|              BEGIN
|              IF OP IN [PMST, PLDA] THEN  K := CURLVL-P  ELSE  K := 6*(CURLVL-P);
|              SCNT[QINX[OP]+K+ TT] := SCNT[QINX[OP]+K+ TT]+1;
|              END;
| 
|           IF LOADING THEN
|              IF OP IN [PLOD, PSTR, PLDA] THEN
|                 IF P = 1 THEN GAC := GAC+1
|                 ELSE IF P = CURLVL THEN LAC := LAC+1
|                 ELSE               IAC := IAC+1;
| 
|           END (* OP <= PSTR *); """
| 
| 
|       END (* IF STAT1 *);
| 
|    IF STAT2 THEN  (* COLLECT DATA OCCURANCE COUNTS *)
|       IF OP <= 63 THEN
|          IF OP IN [PNEW,PINC,PDEC,PIND,PLDA,PLOD,PSTR,PCSP,PMOV,PIXA,PLDC] THEN
|             IF (OP <> PLDC) OR (P = 1) THEN
|                BEGIN   PTR := ACNT[OP] ;      (* OCCURANCE COUNT OF CONSTANS *)
| 
|                WHILE (PTR@.VAL < Q)"AND (PTR@.NXT <> NIL)"DO  PTR := PTR@.NXT ;
| 
|                IF PTR @.VAL <>  Q THEN
|                   BEGIN  NEW(PTR2) ;
|                   PTR2@ := PTR@ ;
|                   PTR@.NXT := PTR2 ;  PTR@.CNT := 0 ;  PTR@.VAL := Q ;
|                   END ;
|                PTR@.CNT := PTR@.CNT+1 ;
|                END (* COUNTING OCCURANCES OF CONSTANT VALUES *) ;
| 
|    IF STAT4 THEN  BEGIN  CORTBL[OLDOP,OP] := CORTBL[OLDOP,OP]+1 ;
|                   OLDOP := OP ;
|                   END ;
|    END (*COUNT*) ;
| (*----------------------------------------------------------------------------*)
| 
| 
| PROCEDURE PRINTCOUNTS ;     (*TO PRINT STATIC/DYNAMIC STATISTICS*)
|    VAR   I, J, K, L, M, S,
|          COLS:                INTEGER ;
|          SL                 : REAL;       (* SCALED TOTAL CNT *)
|          PTR                : @ CNTBIN ;
|          COLNDX             : ARRAY [0..30] OF INTEGER ;
|          OPMAP               : ARRAY [0..5] OF OPRNG;
|                                     (*INDEX OF NON ZERO COLS*)
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE PRINT_STK_TRACE;
|       BEGIN
|       WRITELN(TRFILE, TBUF:TBUFP);  WRITELN(TRFILE);        (*++++++*)
| 
|       WRITELN(TRFILE,'    PUSHCNT, POPCNT, MAXCALL: ',
|               PUSHCNT:10,POPCNT:10, MAXCALL:5);
|       WRITELN(SFL);
|       WRITELN(SFL, '    PUSHCNT, POPCNT, MAXCALL: ',
|               PUSHCNT:10,POPCNT:10, MAXCALL:5);
|       WRITELN(SFL);
|       END (*PRINT_STK_TRACE*);
| 
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE SORTJ(LB,UB: LBLCNTRNG) ;  (*TO SORT/PRINT JUMP DISTANCE TABLES*)
|       VAR  I, N      : LBLCNTRNG ;
|            J, K, L1  : INTEGER ;
|            TCNT, NEGCNT, BINCNT,
|            CUMCNT    : COUNTER ;
|            INX       : ARRAY [LBLCNTRNG] OF LBLCNTRNG ;
|       BEGIN     (* TO SORT AND PRINT BRANCH DISTANCES *)
|       INX[0] := NXTFJP ;   BDCNT[NXTFJP].VAL := MAXADR ;
|       TCNT := 0 ;  NEGCNT := 0 ;
|       FOR I := LB TO UB DO
|          BEGIN
|          WITH BDCNT[I] DO
|             BEGIN   K := VAL ;
|             TCNT := TCNT+CNT ;   IF K < 0 THEN NEGCNT := NEGCNT+CNT ;
|             END ;
|          J := -1 ;
|          REPEAT   J := J+1   UNTIL K < BDCNT[ INX[J] ].VAL ;
|          FOR  N := I-LB DOWNTO J DO   INX[N+1] := INX[N]  ;
|          INX[J] := I ;
|          END ;
| 
|       IF TCNT > 0 THEN
|          BEGIN
|          WRITELN(SFL,'1--> ', INSTR[OP], '   (BRANCH  DISTANCE  COUNTS.)',
|                      '   TOTAL COUNT: ', TCNT:4, WRF(SFL, TCNT*SL, 8, 2):0);
|          WRITELN(SFL) ;       (* PRINT BACKWARD BRANCH DISTANCES *)
|          L1 := -1024 ;   BINCNT := 0 ;  CUMCNT := 0  ;   I := 0 ;
| 
|          IF NEGCNT > 0 THEN
|             REPEAT
|             WITH BDCNT[ INX[I] ] DO
|                IF VAL <= L1 THEN  BEGIN  BINCNT := BINCNT+CNT ;  I := I+1  END
|                ELSE
|                   BEGIN   CUMCNT := CUMCNT+BINCNT ;
|                   WRITELN(SFL, L1:16, BINCNT:8, CUMCNT:8, NEGCNT-CUMCNT:10,
|                                WRF(SFL, (NEGCNT-CUMCNT)/TCNT*100, 8, 2):0) ;
|                   L1 := L1 DIV 2 ;  BINCNT := 0 ;
|                   END ;
|             UNTIL L1 = 0 ;
| 
|          WRITELN(SFL) ;   (* NOW PRINT FORWARD BRANCH DISTANCES *)
| 
|          CUMCNT := TCNT-CUMCNT ;  NEGCNT := CUMCNT ;   L1 := 1 ;
| 
|          IF NEGCNT > 0 THEN
|             BEGIN
|             REPEAT
|             WITH BDCNT[ INX[I] ] DO
|                IF VAL < L1 THEN  BEGIN  BINCNT := BINCNT+CNT ;  I := I+1   END
|                ELSE
|                   BEGIN
|                   WRITELN(SFL,L1 DIV 2:16, BINCNT:8, CUMCNT:8, NEGCNT-CUMCNT:10,
|                               WRF(SFL, (NEGCNT-CUMCNT)/TCNT*100, 8, 2):0) ;
|                   CUMCNT := CUMCNT-BINCNT ;  L1 := L1*2 ;  BINCNT := 0 ;
|                   END ;
|             UNTIL CUMCNT = 0 ;
| 
|             WRITELN(SFL, L1 DIV 2:16, BINCNT:8, CUMCNT:8, NEGCNT-CUMCNT:10,
|                          WRF(SFL, (NEGCNT-CUMCNT)/TCNT*100, 8, 2):0) ;
|             END (* IF NEGCNT > 0 ... *);
|          WRITELN(SFL);
|          WRITELN(SFL, '     BKWRD JUMPS,  FRWRD JUMPS,  RATIOS: ',
|                       TCNT-NEGCNT:6, ' ',NEGCNT:6,
|                       WRF(SFL, (TCNT-NEGCNT)/TCNT*100, 10, 2):0,
|                       WRF(SFL, (NEGCNT)/TCNT*100, 10, 2):0 );
| 
|          WRITELN(SFL) ;
| 
|          END (* IF TCNT > 0 ... *);
| 
|       IF (OP = PFJP) AND (PCNT[PFJP] > 0) THEN
|          IF NOT(INTERPRETING OR LOADING) THEN
|             (* SUCCESSFUL/UNSUCCESSFULL BRANCHES *)
|             WRITELN(SFL, '     TOTAL ''FJP'' COUNT,  SUCC. BRANCHES,  RATIO : ',
|                          PCNT[PFJP]:6, ' ', TCNT:6,
|                          WRF(SFL, TCNT/PCNT[PFJP]*100, 10, 2):0);
| 
|       IF STAT9 AND (TCNT > 0) THEN
|          BEGIN   WRITELN(SFL);  WRITELN(SFL);
|          FOR I := 0 TO UB-LB DO
|             WRITELN(SFL,BDCNT[ INX[I] ].VAL:16, BDCNT[ INX[I] ].CNT:8) ;
|          END (* IF STAT9 *) ;
| 
|       WRITELN(SFL) ;
| 
|       END (*SORTJ*) ;
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE SORTP ;       (*TO SORT/PRINT INSTRUCTION PAIR FREQUENCIES*)
|       CONST ML = 120 ;   ML1 = 121 ;
|       VAR  I, J       : PABI..PNOP ;
|            K          : INTEGER ;
|            N          : 0..ML ;
|            M          : 0..MAXADR ;
|            R          : REAL ;
|            INX        : ARRAY [0..ML1] OF  RECORD  X, Y: PABI..PNOP  END ;
| 
|       BEGIN   CORTBL[PNOP,PNOP] := 0 ;
|       INX[0].X := PNOP ;  INX[0].Y := PNOP ;  INX[ML1] := INX[0] ;
|       FOR I := PABI TO PNOP-1 DO
|          FOR J := PABI TO PNOP-1 DO
|             BEGIN   M := CORTBL[I,J] ;
|             IF M >= 0 THEN
|                BEGIN   K := -1 ;
|                REPEAT  K := K+1  UNTIL M >= CORTBL[INX[K].X,INX[K].Y] ;
|                IF K < ML THEN
|                   BEGIN
|                   FOR N := ML-1 DOWNTO K DO  INX[N+1] := INX[N] ;
|                   INX[K].X := I ;  INX[K].Y := J ;
|                   END  ;
|                END (* M > 0 *) ;
|             END (* FOR I,.. FOR J... *) ;
| 
|       WRITELN(SFL,'1 INSTRUCTION PAIR OCCURANCES (COUNT   %   CUMUL.) ',
|                    '  TOTAL # OF PAIRS: ', INSTRCNT:8) ;
|       WRITELN(SFL) ;     M := 0 ;
| 
|       FOR  N := 0 TO ML DO      (* ASSUMES ALL ENTRIES USEFULL *)
|          BEGIN   I := INX[N].X ;   J := INX[N].Y ;  K := CORTBL[I,J] ;
|          M := M+K ;    R := K*SL ;
|          IF R >= 0.1 THEN
|             WRITELN(SFL,N:4,')',INSTR[I]:12,INSTR[J]:6,K:10,
|                         WRF(SFL, R, 8, 3):01, WRF(SFL, M*SL,10,2):1) ;
|          END (* FOR N ... *) ;
| 
|       END (*SORTP*) ;
| 
| (*----------------------------------------------------------------------------*)
| (*$D-*)
|    PROCEDURE SORTO(SORTOPC, DETAILED: BOOLEAN);  (*TO SORT/PRINT OPCODE DIST.*)
|       VAR  INX            : ARRAY [PABI..PNOP] OF PABI..PNOP ;
|            WR, ENTROPY    : REAL ;
|            OP, OP1        : PABI..PNOP ;
|            M, TC          : INTEGER ;
| 
|       PROCEDURE PRINTO(*PRINT OPCODE DISTRIBUATION TABLE*);
| 
|          VAR  J:              INTEGER;
| 
|          BEGIN
|          FOR OP1 := PABI TO PNOP DO
| 
|             BEGIN   IF SORTOPC THEN  OP := INX[OP1]  ELSE  OP := OP1 ;
|             TC := PCNT[OP];
|             IF TC > 0 THEN
|                BEGIN WR := L/TC ;
|                ENTROPY := ENTROPY + LN(WR)/WR ;
| 
|                IF DETAILED THEN
| 
|                   CASE OP OF
|                      PABI,PABR,PADI,PADR,PAND,PCHK,PCHR,PDEC,PDIF,PDVI,PDVR,
|                      PEOF,PFJP,PFLO,PFLT,PINC,PINN,PINT,PIOR,PIXA,PLAO,PLCA,
|                      PLOC,PMOD,PMOV,PMPI,PMPR,PNGI,PNGR,PNOT,PODD,PORD,
|                      PPRE,PSBI,PSBR,PSGS,PSQI,PSQR,PSTP,PSUC,PTOF,PTON,PTRC,
|                      PUJP,PUNI,PXJP,PLCI,PNEW:
|                         BEGIN  K := PINX[OP] ;
|                         IF K <> 0 THEN
|                            WRITELN(SFL, INSTR[OP]:10, K:20,
|                                         WRF(SFL,K*SL,10,2):01) ;
|                         END ;
| 
|                      PRET,PLDA,PMST:
|                         BEGIN  S := 0 ;
|                         FOR I := PINX[OP] TO PINX[OP] + 9 DO
|                            BEGIN  K := SCNT[I] ;
|                            IF K <> 0 THEN
|                                BEGIN  S := S+K ;
|                                WRITELN(SFL,INSTR[OP]:10,(I-PINX[OP]):5,
|                                        K:15,WRF(SFL, K*SL,10,2):01,
|                                        WRF(SFL, K*100.0/TC, 10, 2):0 );
|                                END ;
|                            END ;
| 
|                         IF S > 0 THEN
|                            BEGIN
|                            WRITELN(SFL,INSTR[OP]:10,'*':5,S:15,
|                                        WRF(SFL, S*SL, 10, 2):01,
|                                        WRF(SFL, S*100.0/S, 10, 2):01);
|                            WRITELN(SFL) ;
|                            END ;
| 
|                         IF OP <> PRET THEN
|                            BEGIN  S := 0 ;
|                            FOR I := QINX[OP] TO QINX[OP] + 9 DO
|                               BEGIN  K := SCNT[I] ;
|                               IF K <> 0 THEN
|                                   BEGIN  S := S+K ;
|                                   WRITELN(SFL, '#':7, INSTR[OP], (I-QINX[OP]):5,
|                                                 K:15,WRF(SFL, K*SL,10,2):01,
|                                                 WRF(SFL, K*100.0/TC, 10, 2) );
|                                   END ;
|                                END;
| 
|                            WRITELN(SFL, '#':7, INSTR[OP], '*':5,S:15,
|                                         WRF(SFL, S*SL, 10, 2):01,
|                                         WRF(SFL, S*100.0/S, 10, 2):01 ) ;
|                            WRITELN(SFL) ;
|                            END ;
| 
|                         END ;
| 
|                      PIND,PLDC,PLDO,PSRO,PSTO:
|                         BEGIN  S := 0 ;
|                         FOR I := PINX[OP] TO PINX[OP] + 5 DO
|                            BEGIN  K := SCNT[I] ;
|                            IF K <> 0 THEN
|                               BEGIN  S := S+K ;
| 
|                                  WRITE(SFL,INSTR[OP]:10) ;
|                                  CASE (I - PINX[OP]) OF
|                                     0: IF OP = PLDC THEN WRITE(SFL,'N':5)
|                                        ELSE WRITE(SFL,'P':5) ;
|                                     1: WRITE(SFL,'I':5) ;
|                                     2: WRITE(SFL,'R':5) ;
|                                     3: WRITE(SFL,'B':5) ;
|                                     4: IF OP = PRET THEN WRITE(SFL,'C':5)
|                                           ELSE WRITE(SFL,'S':5) ;
|                                     5: WRITE(SFL,'A':5)
|                                  END  (* CASE K-PINX ... *) ;
|                                  WRITELN(SFL,K:15, WRF(SFL, K*SL,10,2):01  ) ;
|                               END ;
|                            END (* FOR I...*) ;
|                         WRITELN(SFL,INSTR[OP]:10,'*':5,S:15,
|                                     WRF(SFL, S*SL, 10, 2):01 ) ;
|                         WRITELN(SFL) ;
|                         END  (* PIND, ... ,PSTO *) ;
| 
|                      PCMP (*PEQU,PGEQ,PGRT,PLEQ,PLES,PNEQ*) :
|                         BEGIN
|                         FOR J := 0 TO 5 DO
|                            BEGIN   S := 0;   OP := OPMAP[J];
|                            FOR I := PINX[OP] TO PINX[OP] + 5 DO
|                               BEGIN  K := SCNT[I] ;
|                               IF K <> 0 THEN
|                                  BEGIN  S := S+K ;
| 
|                                     WRITE(SFL,INSTR[OP]:10) ;
|                                     CASE (I - PINX[OP]) OF
|                                        0: WRITE(SFL,'A':5);
|                                        1: WRITE(SFL,'I':5) ;
|                                        2: WRITE(SFL,'R':5) ;
|                                        3: WRITE(SFL,'B':5) ;
|                                        4: WRITE(SFL,'S':5) ;
|                                        5: WRITE(SFL,'M':5)
|                                     END  (* CASE K-PINX ... *) ;
|                                     WRITELN(SFL,K:15, WRF(SFL, K*SL,10,2):01  );
|                                  END ;
|                               END (* FOR I...*) ;
| 
|                            IF S > 0 THEN
|                               BEGIN
|                               WRITELN(SFL, INSTR[OP]:10, '*':5, S:15,
|                                            WRF(SFL, S*SL, 10, 2):01,
|                                            WRF(SFL, S*100.0/TC, 10, 2):01 );
|                               WRITELN(SFL) ;
|                               END (* IF S > 0 *);
|                            END (*FOR J :=0... *);
| 
|                         WRITELN(SFL, INSTR[PCMP]:10, '*':5, TC:15,
|                                      WRF(SFL, TC*SL, 10, 2):01,
|                                      WRF(SFL, TC*100.0/TC, 10, 2):2 );
|                         WRITELN(SFL);
|                         END  (* PCMP ::= PEQU, ... ,PGRT *) ;
| 
|                      PCUP,PLOD,PSTR,PENT:
|                         BEGIN  S := 0 ;
|                         FOR I := 0 TO 9 DO
|                            BEGIN  M := 0;
|                            FOR J := 0 TO 5 DO
|                               BEGIN  K := SCNT[PINX[OP]+I*6+J] ;
|                               IF K <> 0 THEN
|                                  BEGIN
|                                  S := S+K ;   M := M+K;
|                                  WRITE(SFL,INSTR[OP]:10,'    ') ;
|                                     CASE J OF
|                                     0: WRITE(SFL,'P') ;
|                                     1: WRITE(SFL,'I') ;
|                                     2: WRITE(SFL,'R') ;
|                                     3: WRITE(SFL,'B') ;
|                                     4: WRITE(SFL,'S') ;
|                                     5: WRITE(SFL,'A')
|                                     END  (* CASE J *) ;
|                                  WRITELN(SFL,',',I:1,K:13,
|                                              WRF(SFL, K*SL,10,2):01 ) ;
|                                  END ;
|                               END (* FOR J := 0 TO 5 *);
| 
|                            IF M > 0 THEN
|                               BEGIN
|                               WRITELN(SFL, INSTR[OP]:10, '*,':6, I:1, M:13,
|                                             WRF(SFL, M*SL, 10, 2):01,
|                                             WRF(SFL, M*100.0/TC, 10, 2):01);
|                               WRITELN(SFL);
|                               END;
| 
|                            END ;
| 
|                            WRITELN(SFL,INSTR[OP]:10,'*,*':7,S:13,
|                                        WRF(SFL, S*SL, 10, 2):01,
|                                        WRF(SFL, S*100.0/S, 10, 2):01 );
|                            WRITELN(SFL) ;
| 
|                         IF OP IN [PLOD, PSTR] THEN
|                            BEGIN  S := 0 ;
|                            FOR I := 0 TO 9 DO
|                               BEGIN  M := 0;
|                               FOR J := 0 TO 5 DO
|                                  BEGIN  K := SCNT[QINX[OP]+I*6+J] ;
|                                  IF K <> 0 THEN
|                                     BEGIN
|                                     S := S+K ;   M := M+K ;
|                                     WRITE(SFL, '#':7, INSTR[OP],'    ') ;
|                                        CASE J OF
|                                        0: WRITE(SFL,'P') ;
|                                        1: WRITE(SFL,'I') ;
|                                        2: WRITE(SFL,'R') ;
|                                        3: WRITE(SFL,'B') ;
|                                        4: WRITE(SFL,'S') ;
|                                        5: WRITE(SFL,'A')
|                                        END  (* CASE J *) ;
|                                     WRITELN(SFL,',',I:1,K:13,
|                                                 WRF(SFL, K*SL,10,2):01);
|                                     END (* IF K > 0 *);
| 
|                                  END (* FOR J := 0 TO 5 *);
| 
|                               IF M > 0 THEN
|                                  BEGIN
|                                  WRITELN(SFL, '#':7, INSTR[OP], '*,':6, I:1,
|                                               M:13,
|                                               WRF(SFL, M*SL, 10 ,2):01,
|                                               WRF(SFL, M*100.0/TC,10,2):01);
|                                  WRITELN(SFL);
|                                  END ;
| 
| 
|                               END ;
| 
|                            WRITELN(SFL, '#':7, INSTR[OP],'*,*':7, S:13,
|                                         WRF(SFL, S*SL, 10, 2):01,
|                                         WRF(SFL, S*100.0/S, 10, 2):01 );
|                            WRITELN(SFL) ;
|                            END ;
| 
|                         END  (* PCUP,PLOD,PSTR *) ;
| 
|                        PCSP:
|                         BEGIN  S := 0 ;
|                           FOR J := 0 TO SPCNT-1 DO
|                           BEGIN  K := SCNT[PINX[OP]+J] ;    S:= S+K ;
|                             IF K <> 0 THEN
|                               WRITELN(SFL, INSTR[OP]:10, SPTABLE[J]:7,
|                                            K:13, WRF(SFL, K*SL, 10, 2):01 );
|                           END ;
|                           WRITELN(SFL,INSTR[OP]:10,'*':5,S:15,
|                                       WRF(SFL, S*SL, 10, 2):01) ;
|                           WRITELN(SFL) ;
|                         END (*PCSP*)
|                   END  (* CASE OP *)
| 
|                ELSE (* NOT STAT1 *)
| 
|                   BEGIN    S := S+TC;  M := M+1;
|                   WRITELN(SFL, M:6, ')', INSTR[OP]:5, TC:10,
|                                WRF(SFL, TC*SL, 7,2):01, WRF(SFL, S*SL,10,2):01);
|                   END ;
| 
|                END (*IF TC > 0*);
| 
| 
|             END (* FOR OP := PABI...*) ;
|          END (*PRINTO*);
| 
| 
|       BEGIN    PCNT[PNOP] := 0 ;   INX[0] := PNOP ;
| 
|       FOR OP := PABI TO PNOP-1 DO
|          BEGIN   S := PCNT[OP] ;   K := -1 ;
|          REPEAT    K := K+1   UNTIL  S >= PCNT[ INX[K] ] ;
|          FOR I := OP-PABI DOWNTO K DO  INX[I+1] := INX[I] ;
|          INX[K] := OP ;
|          END (* FOR OP := PABI.. *) ;
| 
|       ENTROPY := 0.0 ;  S := 0 ;  M := 0 ;
|       IF DETAILED THEN WRITE(SFL, '1   DETAILED')
|       ELSE WRITE(SFL, '1   SUMMARY');
| 
|       WRITELN(SFL,' P_INSTRUCTION COUNTS, ABSOLUT AND RELATIVE FIGURES.');
|       WRITELN(SFL, '    ( TOTAL OF: ', L:3, ' INSTRUCTIONS )' ) ;
|       IF SORTOPC THEN WRITELN(SFL, '    ( SORTED BY COUNTS )')
|       ELSE  WRITELN(SFL, '    ( SORTED BY OPCODES )' );
|       WRITELN(SFL) ;  WRITELN(SFL) ;
| 
|       PRINTO;
| 
|       WRITELN(SFL) ;
|       WRITELN(SFL, '    TOTAL COUNT = ', L:6 ,
|                    ',   ENTROPY =', WRF(SFL, ENTROPY/LN(2.0),8, 3):01 );
| 
|       END (* SORTO *) ;      (*$D-*)
| 
| (*----------------------------------------------------------------------------*)
| 
| BEGIN  (*PRINTCOUNT*)
|    WRITELN(SFL);  WRITELN(SFL);
|    IF GETSTAT THEN WRITELN(SFL, '    GETSTAT  -->  ENABLE ''COUNTING'' ',
|                                 'PROCEDURES.');
|    IF STAT1   THEN WRITELN(SFL, '    STAT1    -->  PRINT DETAILED BREAKDOWN ',
|                                 'FOR EACH INSTRUCTION BY THE OPERAND TYPE.');
|    IF STAT2   THEN WRITELN(SFL, '    STAT2    -->  PRINT FREQUENCY OF ADDRESS/',
|                                 'OPERAND FOR LOD, STR, INC, DEC, IXA... ETC.');
|    IF STAT3   THEN WRITELN(SFL, '    STAT3    -->  PRINT FREQUENCY AND BRANCH ',
|                                 'DISTANCE FOR JUMP INSTRUCTIONS.');
|    IF STAT4   THEN WRITELN(SFL, '    STAT4    -->  PRINT INSTRUCTION ',
|                                 'PAIR STATISTICS.');
|    IF STAT5   THEN WRITELN(SFL, '    STAT5    -->  PRINT MATRIX OF ',
|                                'INSTRUCTION PAIR FREQUENCIES.');
|    IF STAT6   THEN WRITELN(SFL, '    STAT6    -->  GENERATE PUSH/POP, ',
|                                 'CALL/RETURN STACK TRACE.');
|    IF STAT9   THEN WRITELN(SFL, '    STAT9    -->  PRINT FULL DETAILS OF ',
|                                 'THE ABOVE TABLES.');
|    WRITELN(SFL);  WRITELN(SFL);
| 
| 
|    IF STAT6 THEN  PRINT_STK_TRACE;                                (*++++++++++*)
| 
|    (* PATCH UP COUNT TABLES *)
|    OPMAP[0] := PEQU;   OPMAP[1] := PNEQ;
|    OPMAP[2] := PLEQ;   OPMAP[3] := PLES;
|    OPMAP[4] := PGEQ;   OPMAP[5] := PGRT;
| 
|    FOR I := 0 TO 5 DO  (*PEQU..PGRT*)
|       BEGIN  OP := OPMAP[I];
|       M := PCNT[PCMP]+PCNT[OP];   PCNT[OP] := 0;  PCNT[PCMP] := M;
| 
|       FOR J := 0 TO PNOP DO
|          BEGIN
|          M := CORTBL[PCMP,J]+CORTBL[OP,J];  CORTBL[OP,J] := 0;
|          CORTBL[PCMP,J] := M;
|          M := CORTBL[J,PCMP]+CORTBL[J,OP];  CORTBL[J,OP] := 0;
|          CORTBL[J,PCMP] := M;
|          END;
| 
|       END (*FOR I := 0... *);
| 
|    (* SORT AND/OR PRINT TABLES *)
| 
|    L := INSTRCNT;   SL := 100/L;  (*SCALE FACTOR*)
| 
|    SORTO(TRUE  (*OPCODE SORTED LIST*), FALSE (*SUMMARY TABLE*));
| 
|    IF STAT9 THEN  SORTO(FALSE (*ALPHABETIC LISTING*), FALSE ) ;
| 
|    IF STAT1 THEN SORTO(TRUE  (*OPCODE SORTED LIST*), TRUE  (*DETAILED TABLE*));
| 
|    IF STAT2 THEN
|       BEGIN   WRITELN(SFL,'1') ;
|       FOR OP := PABI TO PSTR DO       (* PSTR = 61 <= 63 *)
|          IF PCNT[OP] > 0 THEN
|             IF OP IN [PNEW,PINC,PDEC,PIND,PLDA,PLOD,PSTR,PCSP,PMOV,PIXA,PLDC]
|                THEN
|                BEGIN  M := PCNT[OP];  WRITELN(SFL) ; WRITELN(SFL) ;
|                WRITELN(SFL, '-->':4, INSTR[OP]:4,
|                            '   (VALUE      COUNT      CUMUL.C.)',
|                             ',   TOTAL COUNT: ',M:7,
|                             WRF(SFL, PCNT[OP]*SL, 7, 2):01) ;
|                WRITELN(SFL) ;
|                PTR := ACNT[OP] ;    S:= 0 ;   J := 0 ;   I := 0 ;   K := 1 ;
|                   REPEAT
|                   WITH PTR@ DO
|                       BEGIN
|                       IF OP IN [PLOD,PSTR,PLDA,PLDC] THEN
|                          IF VAL < K THEN
|                             BEGIN  I := I+CNT ;  S := S+CNT ;
|                             IF CNT > 0 THEN  J := J+1 ;
|                             PTR := NXT ;
|                             END
|                          ELSE
|                             BEGIN
|                             WRITELN(SFL, K DIV 2:16, I:8,
|                                          WRF(SFL, I*100.0/M, 8, 2):0,
|                                          WRF(SFL, S*100.0/M, 10, 2):0 ) ;
|                             I := 0 ;  K := K*2 ;
|                             END
| 
|                       ELSE (* NOT (OP IN [... *)
| 
|                          BEGIN
|                          IF CNT > 0 THEN
|                             BEGIN   J := J+1 ;    S := S+CNT ;
|                             IF OP = PCSP THEN  WRITE(SFL, SPTABLE[VAL]:16)
|                             ELSE  WRITE(SFL, VAL:16);
|                             WRITELN(SFL, CNT:8, WRF(SFL, CNT*100.0/M, 8, 2):0,
|                                          WRF(SFL, S*100.0/M, 10, 2):0 ) ;
|                             END ;
|                          PTR := NXT ;
|                          END ;
| 
|                       END ;
|                    UNTIL (PTR = NIL) OR (S = M) OR (K >= 1073741824)  ;
| 
|                 IF OP IN [PLOD,PSTR,PLDA,PLDC] THEN
|                    WRITELN(SFL, K DIV 2:16, I:8, WRF(SFL, I*100.0/M, 8, 2):0,
|                                 WRF(SFL, S*100.0/ PCNT[OP], 10, 2):01);
|                 WRITELN(SFL);
|                 WRITELN(SFL, '     COUNT OF DISTINCT VALUES: ', J:3) ;
| 
|                END (* FOR OP := PABI TO ...*) ;
| 
|       END (* STAT2 *) ;
| 
| 
|    IF STAT3 THEN
|       BEGIN  (* PRINT BRANCH DISTANCES *)
|       IF NXTUJP > 0 THEN  BEGIN  OP := PUJP;  SORTJ(0, NXTUJP-1)  END;
|       IF NXTFJP < MAXLBLCNT THEN
|          BEGIN  OP := PFJP;  SORTJ(NXTFJP+1, MAXLBLCNT) END;
|       END (* STAT3 *) ;
| 
| 
|    IF STAT4 THEN SORTP ;   (* SORTED LIST OF THE MOST FREQUENT PAIRS *)
| 
|    IF STAT5 THEN
| 
|       BEGIN   (* INSTRUCTION PAIR TABLES *)
| 
|       FOR COLS := 0 TO 30 DO COLNDX[COLS] := 0 ;
| 
|       WRITE(SFL,'1INSTRUCTION_PAIR FREQUENCY TABLE') ;
|       WRITELN(SFL,'   (ROW  PERCENTAGES)') ;  WRITELN(SFL) ;
|         FOR I := PABI TO PNOP DO
|            BEGIN  PINX[I] := 0 ;
|            FOR J := PABI TO PNOP DO
|               BEGIN  PINX[I] := PINX[I]+CORTBL[I,J] ;
|               "CORTBL[I,J] := CORTBL[I,J]*100;"
|               END ;
|            END ;
| 
|         K := PABI ;
|         WRITELN(SFL) ;
|         WHILE K < PNOP DO (* LOOP FOR FRAMES *)
|            BEGIN  COLS := 0 ;
|            (* PRINT FRAME HEADER *)
|            WRITE(SFL,' ':14) ;
|            WHILE (COLS <= 15) AND (K < PNOP) DO
|               BEGIN
|               IF PINX[K] > 0 THEN
|                  BEGIN
|                  COLNDX[COLS] := K ;  WRITE(SFL,INSTR[K]:7) ;
|                  COLS := COLS+1 ;
|                  END ;
|               K := K+1 ;
|               END ;
|            WRITELN(SFL (*TERMINATE HEADER LINE*) ) ;
|            (* PRINT BODY OF THE FRAME *)
|            IF COLS > 0 THEN
|               BEGIN  WRITELN(SFL (*SPACE*) ) ;
|               FOR I := PABI TO PNOP DO (* REPEAT FOR EACH LINE *)
|                  IF PINX[I] > 0 THEN
|                     BEGIN  J := 0 ;
|                     WHILE (J < COLS) AND (CORTBL[I,COLNDX[J]] = 0) DO  J:= J+1 ;
|                     IF J < COLS THEN
|                        BEGIN  L := PINX[I] ;
|                        WRITE(SFL, WRF(SFL, PINX[I]*SL, 8, 2):0,')',INSTR[I]:4) ;
|                        FOR J := 0 TO COLS-1 DO
|                           WRITE(SFL, WRF(SFL, CORTBL[I,COLNDX[J]]*SL, 7, 2):0);
|                        WRITELN(SFL (* TERMINATE THIS LINE *) ) ;
|                        END ;
|                     END ;
|               WRITELN(SFL,'1' (* SPACE *) ) ;
|               END (* IF COLS...*) ;
|            END (* WHILE K < PNOP *) ;
| 
|       IF STAT9 THEN
|          BEGIN  (*MATRIX OF ABSOLUTE COUNTS *)
|          WRITELN(SFL,'1INSTRUCTION_PAIR FREQUENCY TABLE   (ABSOLUTE COUNTS)') ;
|          WRITELN(SFL) ;
| 
|          FOR I := PABI TO PNOP DO
|             BEGIN  PINX[I] := 0 ;
|             FOR J := PABI TO PNOP DO
|                PINX[I] := PINX[I]+CORTBL[I,J] ;
|             END ;
|          K := PABI ;
|          WRITELN(SFL) ;
|          WHILE K < PNOP DO (* LOOP FOR FRAMES *)
|             BEGIN  COLS := 0 ;
|             (* PRINT FRAME HEADER *)
|             WRITE(SFL,' ':16) ;
|             WHILE (COLS <= 15) AND (K < PNOP) DO
|                BEGIN
|                IF PINX[K] > 0 THEN
|                   BEGIN
|                   COLNDX[COLS] := K ;  WRITE(SFL,INSTR[K]:7) ;
|                   COLS := COLS+1 ;
|                   END ;
|                K := K+1 ;
|                END ;
|             WRITELN(SFL (*TERMINATE HEADER LINE*) ) ;
|             (* PRINT BODY OF THE FRAME *)
|             IF COLS > 0 THEN
|                BEGIN  WRITELN(SFL (*SPACE*) ) ;
|                FOR I := PABI TO PNOP DO (* REPEAT FOR EACH LINE *)
|                   IF PINX[I] > 0 THEN
|                      BEGIN  J := 0 ;
|                      WHILE (J < COLS) AND (CORTBL[I,COLNDX[J]] = 0) DO  J:= J+1;
|                      IF J < COLS THEN
|                         BEGIN
|                         WRITE(SFL,PINX[I]:9,')',INSTR[I]:5) ;
|                         FOR J := 0 TO COLS-1 DO
|                            WRITE(SFL,CORTBL[I,COLNDX[J]]:7) ;
|                         WRITELN(SFL (* TERMINATE THIS LINE *) ) ;
|                         END ;
|                      END ;
|                WRITELN(SFL,'1' (* SPACE *) ) ;
|                END (* IF COLS...*) ;
|             END (* WHILE K <= PLCI *) ;
| 
|          END (*STAT9*) ;
| 
|       END (* STAT5 *) ;
| 
| END  (* PRINTCOUNTS *) ;
| (*----------------------------------------------------------------------------*)
| 
| PROCEDURE LOAD;
|    VAR
|       " ICP,RCP,SCP,BCP,MCP  : ADDRESS; "(*POINTERS TO NEXT FREE POSITION*)
|         I  :  INTEGER ;     CH  :  CHAR ;
|         NXTPROC, CURPROC  : MINPROC..MAXPROC ;
|         LABELVALUE: ADDRESS;
|         NAME: SHRTALFA ;  PROCNAME : ALFA ;
|         LABELTAB      : ARRAY [LBLRNG] OF LABELREC ;
|         PROCSZE :       ARRAY [MINPROC..MAXPROC] OF 0..MAXADR  ;
| 
|    PROCEDURE INIT;
|       VAR I, J : INTEGER;
|    BEGIN INSTR[PABI]:='ABI'; INSTR[PABR]:='ABR';
|          INSTR[PADI]:='ADI'; INSTR[PADR]:='ADR';
|          INSTR[PAND]:='AND'; INSTR[PCHK]:='CHK';
|          INSTR[PCHR]:='CHR'; INSTR[PCSP]:='CSP';
|          INSTR[PCUP]:='CUP'; INSTR[PDEC]:='DEC';
|          INSTR[PDEF]:='DEF'; INSTR[PDIF]:='DIF';
|          INSTR[PDVI]:='DVI'; INSTR[PDVR]:='DVR';
|          INSTR[PENT]:='ENT'; INSTR[PEOF]:='EOF';
|          INSTR[PEQU]:='EQU'; INSTR[PFJP]:='FJP';
|          INSTR[PFLO]:='FLO'; INSTR[PFLT]:='FLT';
|          INSTR[PGEQ]:='GEQ'; INSTR[PGRT]:='GRT';
|          INSTR[PINC]:='INC'; INSTR[PIND]:='IND';
|          INSTR[PINN]:='INN'; INSTR[PINT]:='INT';
|          INSTR[PIOR]:='IOR'; INSTR[PIXA]:='IXA';
|          INSTR[PLAO]:='LAO'; INSTR[PLCA]:='LCA';
|          INSTR[PLDA]:='LDA'; INSTR[PLDC]:='LDC';
|          INSTR[PLDO]:='LDO'; INSTR[PLEQ]:='LEQ';
|          INSTR[PLES]:='LES'; INSTR[PLOC]:='LOC';
|          INSTR[PLOD]:='LOD'; INSTR[PMOD]:='MOD';
|          INSTR[PMOV]:='MOV'; INSTR[PMPI]:='MPI';
|          INSTR[PMPR]:='MPR'; INSTR[PMST]:='MST';
|          INSTR[PNEQ]:='NEQ'; INSTR[PNEW]:='NEW';
|          INSTR[PNGI]:='NGI'; INSTR[PNGR]:='NGR';
|          INSTR[PNOT]:='NOT'; INSTR[PODD]:='ODD';
|          INSTR[PORD]:='ORD'; INSTR[PPRE]:='PRE';
|          INSTR[PRET]:='RET'; INSTR[PRST]:='RST';
|          INSTR[PSAV]:='SAV'; INSTR[PSBI]:='SBI';
|          INSTR[PSBR]:='SBR'; INSTR[PSGS]:='SGS';
|          INSTR[PSQI]:='SQI'; INSTR[PSQR]:='SQR';
|          INSTR[PSRO]:='SRO'; INSTR[PSTO]:='STO';
|          INSTR[PSTP]:='STP'; INSTR[PSTR]:='STR';
|          INSTR[PSUC]:='SUC'; INSTR[PTOF]:='TOF';
|          INSTR[PTON]:='TON'; INSTR[PTRC]:='TRC';
|          INSTR[PUJP]:='UJP'; INSTR[PUNI]:='UNI';
|          INSTR[PXJP]:='XJP'; INSTR[PLCI]:='LCI';
|          INSTR[PBGN]:='BGN'; INSTR[PCMP]:='CMP';
| 
|          SPTABLE[ 0]:='GET'; SPTABLE[ 1]:='PUT';
|          SPTABLE[ 2]:='RST'; SPTABLE[ 3]:='RLN';
|          SPTABLE[ 4]:='NEW'; SPTABLE[ 5]:='WLN';
|          SPTABLE[ 6]:='WRS'; SPTABLE[ 7]:='ELN';
|          SPTABLE[ 8]:='WRI'; SPTABLE[ 9]:='WRR';
|          SPTABLE[10]:='WRC'; SPTABLE[11]:='RDI';
|          SPTABLE[12]:='RDR'; SPTABLE[13]:='RDC';
|          SPTABLE[14]:='SIN'; SPTABLE[15]:='COS';
|          SPTABLE[16]:='EXP'; SPTABLE[17]:='LOG';
|          SPTABLE[18]:='SQT'; SPTABLE[19]:='ATN';
|          SPTABLE[20]:='SAV'; SPTABLE[21]:='XIT';
|          SPTABLE[22]:='RES'; SPTABLE[23]:='REW';
|          SPTABLE[24]:='EOF'; SPTABLE[25]:='CLK';
|          SPTABLE[26]:='WRB'; SPTABLE[27]:='RDS';
|          SPTABLE[28]:='SIO'; SPTABLE[29]:='EIO';
|          SPTABLE[30]:='FDF'; SPTABLE[31]:='RDB';
| 
|          FOR CH := 'A' TO 'Z' DO IVECTOR[CH] := 0 ;
| 
|          IVECTOR['A'] := PABI ;  IVECTOR['C'] := PCHK ;
|          IVECTOR['D'] := PDEC ;  IVECTOR['E'] := PENT ;
|          IVECTOR['F'] := PFJP ;  IVECTOR['G'] := PGEQ ;
|          IVECTOR['I'] := PINC ;  IVECTOR['L'] := PLAO ;
|          IVECTOR['M'] := PMOD ;  IVECTOR['N'] := PNEQ ;
|          IVECTOR['O'] := PODD ;  IVECTOR['P'] := PPRE ;
|          IVECTOR['R'] := PRET ;  IVECTOR['S'] := PSAV ;
|          IVECTOR['T'] := PTON ;  IVECTOR['U'] := PUJP ;
|          IVECTOR['X'] := PXJP ;
| 
|          NEEDOPNDS := [PCHK,PCSP,PCUP,PDEC,PENT,PEQU,PFJP,PGEQ,PGRT,PINC,PIND,
|                        PIXA,PLAO,PLCA,PLDA,PLDC,PLDO,PLEQ,PLES,PLOC,PLOD]
|                         + [PMOV,PMST,PNEQ,PNEW,PRET,PSRO,PSTO,PSTR,PUJP,PXJP] ;
|          PC:= 0;   EP := 0;  CPL := MAXSTK-1;
| """      ICP:= MAXSTK+1; FOR I:= ICP TO OVERI DO STORE[I].STYPEò:= INT;
|          RCP:= OVERI+1; FOR I:= RCP TO OVERR DO STORE[I].STYPEò:= REEL;
|          SCP:= OVERR+1; FOR I:= SCP TO OVERS DO STORE[I].STYPEò:= SETT;
|          BCP:= OVERS+2; FOR I:= OVERS+1 TO OVERB DO STORE[I].STYPEò:= INT;
|          MCP:= OVERB+1; FOR I:= MCP TO OVERM DO STORE[I].STYPEò:= INT; """
| 
|          STYPE[MAXSTK] := UNDEF;  STYPE[0] := UNDEF;
|          NAME := BLNK3 ;
| 
|          FOR I := PABI TO PNOP DO
|             BEGIN
|             NEW(ACNT[I]) ;
|             ACNT[I]@.VAL := MAXINT ;  ACNT[I]@.NXT := NIL ;  ACNT[I]@.CNT := 0 ;
|             END ;
| 
|          FOR I:= MINPROC TO MAXPROC DO
|              WITH LABELTAB[I] DO BEGIN VAL:=-1; ST:= ENTERED END;
| 
|          CURLVL := 0;
|       """NUMERICS := ['0','1','2','3','4','5','6','7','8','9'] ; """
|          NXTPROC := MINPROC ;   LOADING := TRUE ;  INTERPRETING := FALSE;
|          NXTFJP := MAXLBLCNT ;  NXTUJP := 0 ;
|          TRCE := FALSE  ;  DMP := FALSE  ;
|          GETSTAT := FALSE;  STAT9 := FALSE;  STAT1 := FALSE;  STAT4 := FALSE;
|          STAT2 := FALSE;   STAT3 := FALSE;  STAT5 := FALSE;  STAT6 := FALSE;
| 
|          FOR I := 0 TO 9 DO  (*INITIALIZE TIME/DATE*)
|              BEGIN
|              STORE[TIMEDATELOC+I].VI := ORD(DATE[I+1]) ;
|              STYPE[TIMEDATELOC+I] := INT;
|              STORE[TIMEDATELOC+10+I].VI := ORD(TIME[I+1]);
|              STYPE[TIMEDATELOC+10+I] := INT;
|              END;
| 
|          IF OSPARM = NIL THEN
|             STORE[OSPARMLOC].VI := NILVAL
|          ELSE
|             WITH OSPARM@ DO
|                BEGIN
|                FOR I := LENGTH TO 1 DO
|                   BEGIN  NP := NP-1;
|                   STORE[NP].VI := ORD(STRING[I]);  STYPE[NP] := INT;
|                   END;
|                NP := NP-1;
|                STORE[NP].VI := LENGTH;  STYPE[NP] := INT;
|                STORE[OSPARMLOC].VI := NP;
|                END (* WITH OSPARM... *);
| 
|          STYPE[OSPARMLOC] := ADR;
| 
| 
|          IF STAT6 THEN  BEGIN  REWRITE(TRFILE); WRITELN(TRFILE)  END;  (*+++++*)
| 
|    END;(*INIT*)
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE ERRORL(STRING: BETA); (*ERROR IN LOADING*)
|    BEGIN WRITELN() ;
|          WRITELN(OUTPUT,'>>>>  ':10, STRING); EXIT(1001) (*EXIT INTERPRETER*)
|    END; (*ERRORL*)
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE BRDIST(DIST: INTEGER) ;   (*TO RECORD BRANCH DISTANCES*)
|       VAR I : INTEGER ;
|       BEGIN   (* TO RECORD 'BRANCH DISTANCE' OF A BRANCH INSTRUCTION *)
|       IF OP = PFJP THEN
| 
|          IF NXTFJP = NXTUJP THEN ERRORL(' BRANCH TABLE OVRFL.')
|          ELSE
|             BEGIN   BDCNT[NXTFJP].VAL := DIST ;   I := MAXLBLCNT+1 ;
|             REPEAT  I := I-1  UNTIL BDCNT[I].VAL = DIST ;
|             IF I = NXTFJP THEN  NXTFJP := NXTFJP-1 ;
|             BDCNT[I].CNT := BDCNT[I].CNT+1  ;  P := I ;
|             END
| 
|       ELSE IF OP = PUJP THEN
| 
|          IF NXTFJP = NXTUJP THEN ERRORL(' BRANCH TABLE OVRFL.')
|          ELSE
|             BEGIN   BDCNT[NXTUJP].VAL := DIST ;   I := -1 ;
|             REPEAT  I := I+1  UNTIL BDCNT[I].VAL = DIST ;
|             IF I = NXTUJP THEN  NXTUJP := NXTUJP+1 ;
|             BDCNT[I].CNT := BDCNT[I].CNT+1  ;  P := I ;
|             END ;
| 
|       END (*BRDIST*) ;
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE UPDATE(X: LBLRNG); (*WHEN A LABEL DEFINITION LX IS FOUND*)
|       VAR CURR,SUCC: -1..MAXPC; (*RESP. CURRENT ELEMENT AND SUCCESSOR ELEMENT
|                                       OF A LIST OF FUTURE REFERENCE*)
|           ENDLIST: BOOLEAN;
|    BEGIN
|       IF LABELTAB[X].ST=DEFINED THEN
|          BEGIN  WRITELN(OUTPUT,X) ; ERRORL(' DUPLICATED LABEL   ')  END
|       ELSE BEGIN
|              IF LABELTAB[X].VAL<>-1 THEN (*FORWARD REFERENCE(S)*)
|              BEGIN CURR:= LABELTAB[X].VAL; ENDLIST:= FALSE;
|                 REPEAT
|                       WITH CODE[CURR] DO
|                         BEGIN
|                         IF STAT3 THEN
|                            BEGIN
|                            OP := OP1 MOD 256 ;  BRDIST(LABELVALUE-CURR) ;
|                            IF OP IN [PUJP,PFJP] THEN
|                               OP1 := OP + 65536*P ;   (*'P' IS SET BY 'BRDIST'*)
|                            END ;
|                         SUCC := Q1 ;  Q1:= LABELVALUE ;
|                         IF SUCC=-1 THEN ENDLIST:= TRUE
|                                    ELSE CURR:= SUCC
|                         END;
|                 UNTIL ENDLIST ;
|              END;
|              LABELTAB[X].ST:= DEFINED;
|              LABELTAB[X].VAL:= LABELVALUE;
|           END  ;
|    END;(*UPDATE*)
| (*----------------------------------------------------------------------------*)
| 
|    FUNCTION GET_PROCID: LBLRNG ;       (* TO GET PROCEDURE NAME *)
|       VAR  ALFALAB : ALFA ;  INTLAB : LBLRNG ;
|       BEGIN  ALFALAB[1] := CH ;
|       FOR INTLAB := 2 TO 8 DO READ(PFILE,ALFALAB[INTLAB]) ;
|       INTLAB := MINPROC ;  PROCTAB[NXTPROC] := ALFALAB;
|       WHILE ALFALAB <> PROCTAB[INTLAB] DO INTLAB := INTLAB+1 ;
|       IF INTLAB = NXTPROC THEN NXTPROC := NXTPROC+1 ;
|       IF ALFALAB = '$MAINBLK' THEN EP := PC ; (*RECORD ENTRY POINT *)
|       IF NXTPROC > MAXPROC THEN
|           BEGIN WRITELN(OUTPUT, ALFALAB:10, INTLAB) ;
|           ERRORL(' TOO MANY PROCEDURES')
|           END ;
|       GET_PROCID := INTLAB ;
|       END (* GET_PROCID*) ;
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE SORTE ;      (* TO SORT/PRINT PROCEDURE SIZE DISTRIBUTION *)
|       VAR  I, J, K : 0..MAXPROC ;  L, N: ADDRESS ;
|            INX :     ARRAY [0..MAXPROC] OF 0..MAXPROC ;
|            LGTH :    ARRAY [0..MAXPROC] OF ADDRESS ;
|       BEGIN
| 
|       PROCSZE[NXTPROC] := MAXADR ;   INX[0] := NXTPROC ;
| 
|       FOR J := MINPROC TO NXTPROC-1 DO
|          BEGIN   L := PROCSZE[J]  ;   N := -1  ;
| 
|          REPEAT   N := N+1   UNTIL L < PROCSZE[ INX[N] ] ;
| 
|          FOR L := J DOWNTO N DO   INX[L+1] := INX[L] ;
| 
|          INX[N] := J ;
|          END ;
| 
|       WRITELN(SFL) ;  WRITELN(SFL) ;
|       WRITELN(SFL,'    PROCEDURE SIZE DISTRIBUTION, TOTAL COUNT =',NXTPROC:5);
|       WRITELN(SFL);  WRITELN(SFL, '    LENGTH,     NAME,     DATA SIZE ') ;
|       WRITELN(SFL) ;   WRITELN(SFL) ;
| 
|       FOR J := MINPROC TO NXTPROC-1 DO
|          WRITELN(SFL, PROCSZE[ INX[J] ]:10, PROCTAB[ INX[J] ]:12,
|                        CODE[ LABELTAB[ INX[J] ].VAL ].Q1:10) ;
| 
|       END (*SORTE*) ;
| 
| 
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE ASSEMBLE; FORWARD;
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE GENERATE;(*GENERATE SEGMENT OF CODE*)
|       VAR X: INTEGER; (* LABEL NUMBER *)
|    BEGIN  RESET(PFILE) ;
|       REPEAT    (* READ UNTIL LAST INSTRUCTION, 'STP' *)
|          READ(PFILE,CH) ;  (* FIRST CHARACTER OF LINE *)
|          IF CH = ' ' THEN
|          BEGIN   (* NO LABEL FIELD *)
|             ASSEMBLE
|          END   (* CH = ' ' *)
|          ELSE
|          BEGIN   (* LABEL *)
|             IF (CH = 'L') AND (PFILE@ >= '0') AND (PFILE@ <= '9') THEN
|             BEGIN   (* STANDARD LABEL *)
|                READ(PFILE,X,CH,CH) ;   (*READ NEXT NON BLANK CHAR*)
|                IF CH = 'L' THEN   (* LAB *)
|                   LABELVALUE := PC
|                ELSE
|                BEGIN   (* DEF *)
|                   READ(PFILE,CH,CH,LABELVALUE)
|                END   (* DEF *) ;
|                UPDATE(X+MINLABEL) ;
|                READLN(PFILE)
|             END   (* STANDARD LABEL *)
|             ELSE
|             BEGIN   (* PROCEDURE OR FUNCTION *)
| (*            PC := PC+1;     (* SAVE SPACE FOR PROC ID PTR *)            (*+*)
|                LABELVALUE := PC ;   CURPROC := GET_PROCID ;
|                UPDATE(CURPROC) ;
|                READ(PFILE,CH) ; (*ADVANCE TO OPCODE FIELD*)
|                ASSEMBLE
|             END   (* PROCEDURE OR FUNCTION *)
|          END   (* LABEL *)  ;
|       UNTIL OP = PSTP ;
|    END   (* GENERATE *) ;
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE ASSEMBLE; (*TRANSLATE SYMBOLIC CODE INTO MACHINE CODE AND STORE*)
|       VAR B :BOOLEAN;  R :REAL;  S :SET OF 0..63;
|           C1 :CHAR;  I,J,S1,LB,UB :INTEGER;
| (*----------------------------------------------------------------------------*)
| 
|       PROCEDURE LOOKUP(X: LBLRNG); (* SEARCH IN LABEL TABLE*)
|       BEGIN
|           CASE LABELTAB[X].ST OF
|           ENTERED: BEGIN Q:=LABELTAB[X].VAL;
|                    LABELTAB[X].VAL:=PC
|                    END;
|           DEFINED: BEGIN  Q:= LABELTAB[X].VAL  ;
|                    IF STAT3 THEN BRDIST(Q-PC) ;
|                    END
|           END(*CASE LABEL..*) ;
|       END;(*LOOKUP*)
| (*----------------------------------------------------------------------------*)
| 
| 
|       PROCEDURE GET_OPCDE;
|       BEGIN     READ(PFILE,NAME) ;
|          OP := IVECTOR[NAME[1]]-1 ;
|          INSTR[PNOP] := NAME ;
|          REPEAT  OP := OP+1  UNTIL (INSTR[OP] = NAME) ;
|          IF OP > PLCI THEN
|          BEGIN
|             WRITELN(OUTPUT,' ILLEGAL OPCODE     ',NAME) ;
|             OP := PTOF  (* NOP *)
|          END ;
|          IF OP <= 63 THEN
|             IF (OP IN NEEDOPNDS) THEN
|                REPEAT
|                   READ(PFILE,CH) ;
|                UNTIL (CH <> ' ') ;
|       END; (*GET_OPCDE*)
| (*----------------------------------------------------------------------------*)
| 
|    BEGIN   (* ASSEMBLE *)
|       P := 0;  Q := 0;  OP := 0; T := UNDEF ;
|       GET_OPCDE;
| 
|       CASE OP OF  (* GET PARAMETERS T,P,Q *)
| 
|           PBGN:
|              BEGIN  READ(PFILE, B, CH, B, CH, B, CH, HEADLN);  END;
| 
|           (*EQU,NEQ,GEQ,GRT,LEQ,LES*)
|           PEQU,PGEQ,PGRT,PLEQ,PLES,PNEQ :
|                         BEGIN CASE CH OF
|                               'A': P := 0;
|                          'C', 'I': P := 1;
|                               'R': P := 2;
|                               'B': P := 3;
|                               'S': P := 4;
|                               'M' :BEGIN P := 5;
|                                      READ(PFILE, CH, Q)
|                                    END
|                               END
|                           END;
| 
|           PLOD,PSTR:
|              BEGIN
|                 CASE CH OF
|                    'I','C': T := INT ;
|                    'R': T := REEL ;
|                    'B': T := BOOL ;
|                    'S': T := SETT ;
|                    'A': T := ADR
|                 END   (* CASE *) ;
|                 REPEAT
|                    READ(PFILE,CH) ;
|                 UNTIL CH = ',' ;
|                 READ(PFILE,CH) ;
|                 P := 0 ;
|                 WHILE CH <> ',' DO
|                 BEGIN
|                    P := P * 10 + ORD(CH) - ORD('0') ;
|                    READ(PFILE,CH)
|                 END   (* WHILE *) ;
|                 READ(PFILE,Q)
|              END   (* LOD,STR *) ;
| 
|           PSTO:
|              CASE CH OF
|                 'I','C': T := INT ;
|                 'R': T := REEL ;
|                 'B': T := BOOL ;
|                 'S': T := SETT ;
|                 'A': T := ADR
|              END   (* STO *) ;
| 
|           (* LDA *)
|           PLDA:
|              BEGIN
|                 P := ORD(CH) - ORD('0') ;
|                 READ(PFILE,CH) ;
|                 WHILE CH <> ',' DO
|                 BEGIN
|                    P := P * 10 + ORD(CH) - ORD('0') ;
|                    READ(PFILE,CH)
|                 END   (* WHILE *) ;
|                 READ(PFILE,Q)
|              END   (* LDA *) ;
| 
|           PCUP:
|              BEGIN
|                 CASE CH OF
|                    'P': T := UNDEF ;
|                    'I','C': T := INT ;
|                    'R': T := REEL ;
|                    'B': T := BOOL ;
|                    'S': T := SETT ;
|                    'A': T := ADR
|                 END   (* CASE *) ;
|                 READ(PFILE,CH,P,CH,CH) ;  (*THE FIRST CHAR OF PROCID*)
|             """ IF ODD(P) THEN  ERRORL(' FP SAVE AREA REQ   '); """
|                 P := P DIV 2 ;
|                 LOOKUP(GET_PROCID) ;
|              END   (* CUP *) ;
| 
|           PMST :
|                   BEGIN
|                   REPEAT
|                      P := P * 10 + ORD(CH) - ORD('0') ;
|                      READ(PFILE,CH) ;
|                   UNTIL CH = ' ' ;
|                   P := CURLVL-P;
|                   END;
| 
|           PRET :
|              BEGIN   PROCSZE[CURPROC] := PC+1- LABELTAB[CURPROC].VAL ;
|                 CASE CH OF
|                    'P': T := UNDEF ;
|                    'I','C': T := INT ;
|                    'R': T := REEL ;
|                    'B': T := BOOL ;
|                    'S': T := SETT ;
|                    'A': T := ADR
|                 END ;
| 
|              IF GETSTAT THEN
|                 IF IAC <> 0 THEN P := 1
|                 ELSE IF (GAC = 0) AND (LAC > 0) THEN P := 0
|                 ELSE IF (GAC > 0) AND (LAC = 0) THEN P := 2
|                 ELSE P := 3
|              END ;
| 
|           PDEC,PINC,PIND,PLDO,PSRO :
|              BEGIN
|                 CASE CH OF
|                    'I','C': T := INT ;
|                    'R': T := REEL ;
|                    'A': T := ADR ;
|                    'B': T := BOOL ;
|                    'S': T := SETT
|                 END   (* CASE *) ;
|                 REPEAT
|                    READ(PFILE,CH) ;
|                 UNTIL CH = ',' ;
|                 READ(PFILE,Q)
|              END   (* LDO,SRO,IND,MOV,INC,DEC *) ;
| 
|           PIXA,PLAO,PLOC,PMOV :
|              BEGIN
|                 Q := ORD(CH) - ORD('0') ;
|                 READ(PFILE,CH) ;
|                 WHILE CH <> ' ' DO
|                 BEGIN
|                    Q := Q * 10 + ORD(CH) - ORD('0') ;
|                    READ(PFILE,CH)
|                 END   (* WHILE *)
|              END   (* LAO,IXA *) ;
| 
|           PFJP,PUJP:
|              BEGIN  READ(PFILE,I) ;  LOOKUP(I+MINLABEL) ;  END ;
| 
|           PXJP:
|             BEGIN  READ(PFILE,I);  LOOKUP(I+2+MINLABEL) ;
|             CODE[PC].OP1 := OP ;   CODE[PC].Q1 := Q ;  PC := PC+1 ;
|             LOOKUP(I+3+MINLABEL) ;
|             CODE[PC].OP1 := 0 ;  CODE[PC].Q1 := Q ; PC := PC+1 ;
|             LOOKUP(I+MINLABEL) ;
|             CODE[PC].OP1 := 0 ;  CODE[PC].Q1 := Q ; PC := PC+1 ;
|             LOOKUP(I+1+MINLABEL) ;
|             END (*PXJP*) ;
| 
|           PENT:
|              BEGIN
|                 GAC := 0;  IAC := 0;  LAC := 0;
| 
|                 FOR I := MINLABEL TO MAXLABEL DO
|                    BEGIN  LABELTAB[I].VAL := -1;  LABELTAB[I].ST := ENTERED END;
|                 CASE CH OF
|                    'P': T := UNDEF ;
|                    'I','C': T := INT ;
|                    'R': T := REEL ;
|                    'B': T := BOOL ;
|                    'S': T := SETT ;
|                    'A': T := ADR
|                 END ;
| 
|              (* WHILE CH <> ',' DO READ(PFILE,CH) ;*)  (* GET LEVEL *)
|                 READ(PFILE, CH(*,*), P, CH, CH(*,L*), I) ;
|                 CURLVL := P ;         (*LEVEL OF THIS PROC*)
|                 LOOKUP(I+MINLABEL) ;  (*LABEL FOR DATA AREA*)
| (*             WRITELN(OUTPUT, ' PROCID,  PC: ', PROCTAB[CURPROC],  PC:6);(*+*)
| (*             CODE[PC-1].Q1 := CURPROC;                                  (*+*)
|              END  (* PENT *) ;
| 
|           PCSP :
|              BEGIN
|                 NAME[1] := CH ;
|                 READ(PFILE,NAME[2],NAME[3]) ;
|                 WHILE (NAME<>SPTABLE[Q]) AND (Q < SPCNT) DO  Q := Q+1 ;
|                 IF NAME <> SPTABLE[Q] THEN
|                    BEGIN WRITE(NAME:5) ;ERRORL(' UNDEFINED CSP NAME ') END;
|              END   (* CSP *) ;
| 
|           PLDC :          BEGIN CASE CH OF  (*GET Q*)
|                            'I' :BEGIN  P := 1;
|                                    REPEAT
|                                       READ(PFILE,CH) ;
|                                    UNTIL CH = ',' ;
|                                    READ(PFILE,I) ;
|                                    Q := I
|                                 END;
| 
|                            'C' :BEGIN
|                                    P := 1 ;
|                                    READ(PFILE,CH) ;  READ(PFILE,CH) ;
|                                    READ(PFILE,CH) ;
|                                    Q := ORD(CH)
|                                 END   (* C *) ;
| 
|                            'R' :BEGIN  OP := PLCI ; P := 2;
|                                    REPEAT
|                                       READ(PFILE,CH) ;
|                                    UNTIL CH = ',' ;
|                                    READ(PFILE,R);
|                                    STORE[CPL].VR := R;  Q := MAXSTK;
|                                    STYPE[CPL]".STYPE" := REEL ;
|                                    REPEAT  Q := Q-1
|                                    UNTIL (STYPE[Q]".STYPE" = REEL) AND
|                                          (STORE[Q].VR=R);
|                                    IF Q=CPL THEN  CPL := CPL-1;
|                                """ BEGIN  RCP := RCP+1;
|                                       IF RCP=OVERR THEN
|                                          ERRORL(' REAL TABLE OVERFLOW')
|                                    END  """
|                                 END;
| 
|                            'N' :; (*P,Q = 0*)
| 
|                            'B' :BEGIN
|                                    P := 3 ;
|                                    REPEAT
|                                       READ(PFILE,CH) ;
|                                    UNTIL CH = ',' ;
|                                    READ(PFILE,Q)
|                                 END   (* B *) ;
| 
|                            'S' :BEGIN  OP := PLCI ;   P := 4;
|                                    S := [ ];
|                                    REPEAT
|                                       READ(PFILE,CH) ;
|                                    UNTIL CH = '(' ;
| 
|                                    FOR I := 3 DOWNTO 0 DO
|                                       BEGIN  J := I*16 ;
|                                       READ(PFILE,S1,CH) ;
|                                       WHILE S1 > 0 DO
|                                          BEGIN
|                                          IF ODD(S1) THEN S := S+[J] ;
|                                          S1 := S1 DIV 2 ;  J := J+1 ;
|                                          END ;
|                                       END (* FOR I :=..*) ;
| 
|                                    STYPE[CPL]".STYPE" := SETT;
|                                    STORE[CPL].VS := S;
|                                    Q := MAXSTK;
|                                    REPEAT  Q := Q-1
|                                    UNTIL (STYPE[Q]".STYPE" = SETT) AND
|                                          (STORE[Q].VS=S);
|                                    IF Q=CPL THEN   CPL := CPL-1;
|                               """  BEGIN  SCP := SCP+1;
|                                       IF SCP=OVERS THEN
|                                          ERRORL(' SET TABLE OVERFLOW ')
|                                    END   """
|                                 END
|                            END (*CASE*)
|                         END;
| 
|           PCHK :        BEGIN  READ(PFILE,LB,UB);
| 
|                            CASE CH OF
|                            'I','C': T := INT ;
|                            'S':     T := SETT ;
|                            'A':     T := ADR ;
|                            'J':     T := INDEX
|                            END ;
| 
|                         STORE[CPL-1].VI := LB;  STYPE[CPL-1] := INT;
|                         STORE[CPL].VI := UB;  STYPE[CPL] := INT;
|                         Q := MAXSTK;
|                         REPEAT  Q := Q-2
|                         UNTIL (STORE[Q].VI = LB) AND (STORE[Q+1].VI = UB);
|                         IF Q <= CPL THEN CPL := CPL-2;
|                         END;
| 
|           PLCA :        BEGIN  READ(PFILE,CH);  (*CH = FIRST CHAR IN STRING*)
|                            I := 0;
| 
|                               REPEAT
|                                  REPEAT
|                                  STRBUF[I] := CH ;
|                                  IF I = STRNGLEN THEN
|                                     ERRORL(' STRING TABLE OVRFL.') ;
|                                  I := I+1;  READ(PFILE,CH)
|                                  UNTIL CH = '''' ;
|                               READ(PFILE, CH);
|                               UNTIL CH <> '''';
| 
|                            FOR I := I-1 DOWNTO 0 DO
|                               BEGIN
|                               STYPE[CPL]".STYPE" := INT;
|                               STORE[CPL].VI := ORD(STRBUF[I]);
|                               CPL := CPL-1;
|                               END;
| 
|                            Q := CPL+1;
|                         END;
| 
|           PNEW,PRST,PSAV :
|              BEGIN  (* CHANGE TO CSP CALL *)    P := 0 ;
|                 IF OP = PNEW THEN
|                    REPEAT  (* GET LENGTH *)
|                       Q := Q * 10 + ORD(CH) - ORD('0') ;
|                       READ(PFILE,CH) ;
|                    UNTIL CH = ' ' ;
|               " OP := PCSP ;
|                 WHILE (NAME <> SPTABLE[Q]) AND (Q < 24) DO Q := Q + 1 ;
|                 IF NAME <> SPTABLE[Q] THEN
|                    BEGIN WRITELN(OUTPUT, NAME:8) ;
|                    ERRORL(' UNDEFINED CSP NAME ')
|                    END; "
|              END   (* SAV,NEW,RST *) ;
|           PTON: DMP := TRUE
| 
| 
|       END; (*CASE*)
| 
|       READLN(PFILE);
|       (* STORE INSTRUCTION *)
| 
|       IF (OP <> PLOC) THEN
|             BEGIN
|             WITH CODE[PC] DO
|                BEGIN  OP1 := OP+ (65536)*P + 256*ORD(T);  Q1 := Q;
|                IF DMP THEN
|                  WRITELN(OUTPUT, ',  PC: ',PC:5,' OP =',INSTR[OP]:4,
|                                  '  (', OP:3, '  T: ', T:1, '  P: ', P:4,
|                                  '  Q: ',Q:6, ')' );
|                END;
| 
|             IF GETSTAT THEN  COUNT ;
|             PC := PC+1;  INSTRCNT := INSTRCNT+1 ;
|             IF PC > CPL THEN  ERRORL(' CODE AREA OVERFLOW ');
|             END ;
| 
|    END; (*ASSEMBLE*)
| (*----------------------------------------------------------------------------*)
| 
| BEGIN (*LOAD*)
|    INIT ;      (* INITIALIZE FOR LOADING THE P_PROGRAM *)
|    INSTRCNT := 0 ;
|    IF GETSTAT THEN  CLEARCOUNTS
|    ELSE
|       BEGIN
|       STAT5 := FALSE ;  STAT3 := FALSE ;  STAT2 := FALSE ;  STAT4 := FALSE
|       END ;
| 
|    GENERATE;   (* GENERATE THE P_PROGRAM SEGMENT *)
| 
|    FOR I := MINPROC TO NXTPROC-1 DO
|       WITH LABELTAB[I] DO
|       IF ST <> DEFINED THEN
|          BEGIN  WRITELN(OUTPUT, ' ':4, PROCTAB[I]:14,I:5) ;
|          ERRORL(' UNDEFINED PROC.    ');
|          END;
| 
|    IF DMP THEN
|       FOR I := 0 TO PC-1  DO
|          WITH CODE [I] DO
|          BEGIN
|             OP :=OP1 MOD 256;
|             P := OP1 DIV 65536;   T := CHR((OP1 DIV 256) MOD 256);   Q := Q1;
|             WRITELN(OUTPUT, ',  PC: ',  I:5, ' OP =', INSTR[OP]:4, '  (', OP:3,
|                             '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:6, ')' );
|          END;
| 
|    TIMER := CLOCK(1);
|    PRINT_HEADLN(OUTPUT);
| 
|    IF GETSTAT THEN
|       BEGIN   REWRITE(SFL);  PRINT_HEADLN(SFL);  SORTE;  PRINTCOUNTS;  END;
| 
|    IF PC >= CPL  THEN  ERRORL(' PROGRAM TOO LARGE. ');
|    IF EP = 0  THEN  ERRORL(' NO ENTRY POINT.    ');
| 
| END; (*LOAD*)
| 
| (*------------------------------------------------------------------------*)
| 
| 
| PROCEDURE PMD;
|    VAR S :INTEGER; I: INTEGER;
| 
|    PROCEDURE PT;
|    BEGIN
|    IF I >= 5 THEN
|       BEGIN  WRITELN(OUTPUT);   WRITE(OUTPUT, ' ':5);  I := 0 END;
|    WRITE(S:6);
|    IF (STYPE[S] < UNDEF) OR (STYPE[S] > MARK) THEN
|        BEGIN
|        REPEAT S:=S-1
|        UNTIL  (S <= 0) OR ((STYPE[S] >= UNDEF) AND (STYPE[S] <= MARK));
|        S := S+1;
|        WRITE(OUTPUT, '  <G>', S:5);
|        END
|    ELSE
|       CASE STYPE[S]".STYPE" OF
|           UNDEF: BEGIN
|                     REPEAT S := S-1 UNTIL (S <= 0) OR (STYPE[S] <> UNDEF);
|                     S := S+1;
|                     WRITE(OUTPUT,'  <U>',S:5)
|                  END;
|           INT  : WRITE(STORE[S].VI:10);
|           REEL : WRITE(STORE[S].VR:10);
|           BOOL : IF STORE[S].VB THEN
|                     WRITE(OUTPUT,' TRUE ':10)
|                  ELSE  WRITE(OUTPUT,' FALSE ':10);
|           SETT : WRITE(OUTPUT,' SET ':10) (* WRITE(STORE[S].VS:21 OCT) *) ;
|           ADR  : WRITE(OUTPUT,' @  ',STORE[S].VA:6);
|           MARK : WRITE(OUTPUT,' .M.',STORE[S].VM:6)
|       END; (*CASE*)
|       S := S - 1;
|       I := I + 1;
|    END; (*PT*)
| 
|    BEGIN
|    WRITELN(OUTPUT);
|    WRITELN(OUTPUT, '    ***>  PSW: ');  WRITELN(OUTPUT);
|    WRITELN(OUTPUT);
|    WRITE(OUTPUT, '    PC: ',PC-1:5,' OP =',INSTR[OP]:4,'  (', OP:3,
|                  '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:6, '),  SP =',SP:5,
|                  '  MP =',MP:5,'  NP =', NP:5,'  INSTRCNT = ',INSTRCNT:6);
|    WRITELN(OUTPUT); WRITELN(OUTPUT);
|    WRITELN(OUTPUT, '    ***>  STACK CONTENTS: ');  WRITELN(OUTPUT);
| 
|    S := SP;  I := 6;
|    WHILE S > 0 DO PT;
|    WRITELN(OUTPUT) ;
|    S := CPL;   I := 6;
|    IF S >= NP THEN
|       BEGIN  WRITELN(OUTPUT);  WRITELN(OUTPUT, '    ***>  HEAP CONTENTS: ') ;
|       WRITELN(OUTPUT) ;
|       END ;
|    WHILE S>=NP DO PT;
|    WRITELN(OUTPUT);  WRITELN(OUTPUT, '    ***>  END OF DUMP  ***>');
|    WRITELN(OUTPUT);
| END; (*PMD*)
| (*----------------------------------------------------------------------------*)
| 
|    PROCEDURE ERRORI0(AD: ADDRESS);
| 
|       BEGIN   WRITELN(OUTPUT);  WRITELN(OUTPUT);
| 
|       WRITELN(OUTPUT, '    ***>   ADDRESS, TYPE, VALUE: ',
|                       AD:6, STYPE[AD]:4, STORE[AD].VI:10) ;
|       WRITE(OUTPUT,'    ***>   LOC: ', AD:6, '  VALUE: ') ;
|       IF (STYPE[AD] < UNDEF) OR (STYPE[AD] > MARK) THEN
|          WRITE(OUTPUT,'.GARBAGE.':10)
|       ELSE
|         CASE STYPE[AD]".STYPE" OF
|           UNDEF: WRITE(OUTPUT,'UNDEF':10);
|           INT  : WRITE(STORE[AD].VI:10);
|           REEL : WRITE(STORE[AD].VR:10);
|           BOOL : IF STORE[AD].VB THEN
|                     WRITE(OUTPUT,' TRUE ':10)
|                  ELSE  WRITE(OUTPUT,' FALSE ':10);
|           SETT : WRITE(OUTPUT,' SET ':10) (* WRITE(STORE[AD].VS:21 OCT) *) ;
|           ADR  : WRITE(OUTPUT,' @  ',STORE[AD].VA:6);
|           MARK : WRITE(OUTPUT,' .M.',STORE[AD].VM:6)
|         END; (*CASE*)
| 
|       WRITELN(OUTPUT);  WRITELN(OUTPUT);
|       END (*ERRORI0*);
| (*----------------------------------------------------------------------------*)
| 
| PROCEDURE ERRORI(STRING: BETA);
| BEGIN  WRITELN(OUTPUT);  WRITELN(OUTPUT,'    ***>  ', STRING);
|       PMD; "EXIT(1002)"
|       RETCDE := 1002;  INTERPRETING := FALSE;
| END;(*ERRORI*)
| (*----------------------------------------------------------------------------*)
| 
| FUNCTION BASE(LD :BIT4):INTEGER ;
|    VAR AD :ADDRESS;
| BEGIN  AD := MP;
|    WHILE LD>0 DO
|    BEGIN  AD := STORE[AD+1].VM;  LD := LD-1
|    END;
|    BASE := AD
| END; (*BASE*)
| (*----------------------------------------------------------------------------*)
| 
| PROCEDURE PUSH ;
| BEGIN
|    SP := SP + 1 ;
|    IF SP >= NP THEN
|       ERRORI(' STORE OVERFLOW     ')
| END   (* PUSH *) ;
| (*----------------------------------------------------------------------------*)
| 
| 
|    PROCEDURE CALLSP;
|       VAR LINE: BOOLEAN; ADPTR,ADELNT,AD: ADDRESS;
|           I: INTEGER;
| (*----------------------------------------------------------------------------*)
| 
|       PROCEDURE READI(VAR F: TEXT);
|          VAR AD: ADDRESS;
|       BEGIN AD:= STORE[SP].VA;
|          READ(F,STORE[AD].VI) ;
|          STORE[STORE[SP-1].VA].VI := ORD(F@)  ;    (* UPDATE FILE BUF *)
|          STYPE[AD]".STYPE" := INT ;
|          SP := SP - 1
|       END;(*READI*)
| (*----------------------------------------------------------------------------*)
| 
|       PROCEDURE READB(VAR F: TEXT);
|          VAR AD: ADDRESS;
|       BEGIN AD:= STORE[SP].VA;
|          READ(F,STORE[AD].VB) ;
|          STORE[STORE[SP-1].VA].VI := ORD(F@)  ;    (* UPDATE FILE BUF *)
|          STYPE[AD]".STYPE" := BOOL;
|          SP := SP - 1
|       END;(*READB*)
| (*----------------------------------------------------------------------------*)
| 
|       PROCEDURE READR(VAR F: TEXT);
|          VAR AD: ADDRESS;
|       BEGIN AD:= STORE[SP].VA;
|          READ(F,STORE[AD].VR) ;
|          STORE[STORE[SP-1].VA].VI := ORD(F@)  ;     (* UPDATE FILE BUFFER *)
|          STYPE[AD]".STYPE" := REEL ;
|          SP := SP - 1
|       END;(*READR*)
| (*----------------------------------------------------------------------------*)
| 
|       PROCEDURE READC(VAR F: TEXT);
|          VAR C: CHAR; AD: ADDRESS;
|       BEGIN
|          READ(F,C) ;
|          STORE[STORE[SP-1].VA].VI := ORD(F@)  ;    (* UPDATE FILE BUFFER *)
|          AD := STORE[SP].VA ;
|          STORE[AD].VI := ORD(C) ;
|          STYPE[AD]".STYPE" := INT ;
|          SP := SP - 1
|       END;(*READC*)
| (*----------------------------------------------------------------------------*)
| 
|       PROCEDURE READSTR(VAR F: TEXT) ;
|          VAR  C : CHAR ;  I :INTEGER ;  AD : ADDRESS ;
|          BEGIN   AD := STORE[SP-1].VA ;
|          FOR I := 0 TO STORE[SP].VI-1 DO
|             BEGIN  READ(F,C) ;
|             STORE[AD+I].VI := ORD(C) ;
|             STYPE[AD+I]".STYPE" := INT ;
|             END ;
|          SP := SP-2 ;
|          STORE[ STORE[SP].VA ].VI := ORD(F@) ;   (* UPDATE FILE BUFFER *)
|          END (* READSTR *) ;
| (*----------------------------------------------------------------------------*)
| 
|       PROCEDURE WRITESTR(VAR F: TEXT);
|          VAR I,J,K: INTEGER;
|              AD: ADDRESS;
|       BEGIN AD:= STORE[SP-2].VA;
|             K:= STORE[SP].VI; J:= STORE[SP-1].VI;
|            (* J AND K ARE NUMBERS OF CHARACTERS *)
|       (*  K <-- STRING LEN,   J <-- FIELD WIDTH  *)
|       IF J > K THEN FOR I := 1 TO J-K DO WRITE(F,' ')
|       ELSE  K := J ;
|       FOR I := 0 TO K-1 DO WRITE(F,CHR(STORE[AD+I].VI)) ;
|       (* IN THE INDEX OF STORE I HAS TO BE MULTIPLIED BY CHARSIZE *)
|       SP := SP - 3
|       END;(*WRITESTR*)
| (*----------------------------------------------------------------------------*)
| 
| 
|       PROCEDURE GETFILE(VAR F: TEXT);
|          VAR AD: ADDRESS;
|       BEGIN AD:=STORE[SP].VA;
|          GET(F) ;
|          STORE[AD].VI := ORD(F@) ;
|       "  SP := SP - 1  "
|       END;(*GETFILE*)
| (*----------------------------------------------------------------------------*)
| 
|       PROCEDURE PUTFILE(VAR F: TEXT);
|          VAR AD: ADDRESS;
|       BEGIN AD:= STORE[SP].VA;
|          F@ := CHR(STORE[AD].VI) ;
|          PUT(F)  ;
|       "  SP := SP - 1  "
|       END;(*PUTFILE*)
| (*----------------------------------------------------------------------------*)
| 
|    BEGIN (*CALLSP*)
|          CASE Q OF
|               0 (*GET*) : CASE STORE[SP].VA OF
|                                INPUTADR: GETFILE(INPUT);
|                                OUTPUTADR: ERRORI(' GET ON OUTPUT FILE ');
|                                PRDADR: GETFILE(PRD);
|                                PRRADR: ERRORI(' GET ON PRR FILE    ')
|                           END;
|               1 (*PUT*) : CASE STORE[SP].VA OF
|                                INPUTADR: ERRORI(' PUT ON INPUT FILE  ');
|                                OUTPUTADR: PUTFILE(OUTPUT);
|                                PRDADR: ERRORI(' PUT ON PRD FILE    ');
|                                PRRADR: PUTFILE(PRR)
|                           END;
|               2 (*RST*) : BEGIN NP:= STORE[SP].VI; SP:=SP-1  END ;
|               3 (*RLN*) : BEGIN
|                              CASE STORE[SP].VA OF
|                                 INPUTADR: BEGIN READLN(INPUT);
|                                           STORE[INPUTADR].VI := ORD(INPUT@) END;
|                                  OUTPUTADR: ERRORI(' READLN ON OUTPUT   ');
|                                  PRDADR: BEGIN READLN(PRD);
|                                          STORE[PRDADR].VI := ORD(PRD@) END;
|                                  PRRADR: ERRORI(' READLN ON PRR FILE ');
|                                  QRDADR: BEGIN READLN(QRD);
|                                          STORE[QRDADR].VI := ORD(QRD@) END;
|                              END;
|                           "  SP := SP-1  "
|                           END;
|                4 (*NEW*): BEGIN AD := NP - P ;
|                           (*TOP OF STACK GIVES THE ADDRESS TO BE STORED INTO*)
|                                 IF AD<= SP THEN
|                                    ERRORI(' STORE OVERFLOW     ') ;
|                                 FOR I:=NP-1 DOWNTO AD DO
|                                    STYPE[I]".STYPE":= UNDEF;
|                                 NP:= AD; AD:= STORE[SP].VA;
|                                 STORE[AD].VA:= NP;
|                                 STYPE[AD]".STYPE":=ADR;
|                                 SP := SP - 1
|                           END;
| 
|                5 (*WLN*): BEGIN
|                               CASE STORE[SP].VA OF
|                                  INPUTADR: ERRORI(' WRITELN ON INPUT   ');
|                                  OUTPUTADR: WRITELN(OUTPUT);
|                                  PRDADR: ERRORI(' WRITELN ON PRD FILE');
|                                  PRRADR: WRITELN(PRR) ;
|                                  QRRADR: WRITELN(QRR) ;
|                               END;
|                            "  SP:= SP-1  "
|                            END;
|                6 (*WRS*): CASE STORE[SP-3].VA OF
|                                INPUTADR: ERRORI(' WRITE ON INPUT FILE');
|                                OUTPUTADR: WRITESTR(OUTPUT);
|                                PRDADR: ERRORI(' WRITE ON PRD FILE  ');
|                                PRRADR: WRITESTR(PRR) ;
|                                QRRADR: WRITESTR(QRR)
|                           END;
|                7 (*ELN*) : BEGIN
|                                CASE STORE[SP].VA OF
|                                   INPUTADR: LINE:= EOLN(INPUT);
|                                   OUTPUTADR: ERRORI(' EOLN ON OUTPUT FILE');
|                                   PRDADR: LINE:=EOLN(PRD);
|                                   PRRADR: ERRORI(' EOLN ON PRR FILE   ')
|                                END;
|                                STORE[SP].VB:= LINE;
|                                STYPE[SP]".STYPE":= BOOL ;
|                                SP := SP+1 ;
|                            END;
|                8 (*WRI*) : BEGIN
|                                CASE STORE[SP-2].VA OF
|                                   INPUTADR: ERRORI(' WRITE ON INPUT FILE');
|                                   OUTPUTADR: WRITE(OUTPUT,STORE[SP-1].VI:
|                                              STORE[SP].VI);
|                                   PRDADR: ERRORI(' WRITE ON PRD FILE  ');
|                                   PRRADR: WRITE(PRR,STORE[SP-1].VI:
|                                                 STORE[SP].VI);
|                                   QRDADR: ERRORI(' WRITE ON QRD FILE  ');
|                                   QRRADR: WRITE(QRR,STORE[SP-1].VI:
|                                                 STORE[SP].VI);
|                                END;
|                               SP:=SP-2
|                            END;
|                9 (*WRR*) : BEGIN
|                                CASE STORE[SP-3].VA OF
|                                   INPUTADR: ERRORI(' WRITE ON INPUT FILE');
|                                   OUTPUTADR: WRITE(OUTPUT,STORE[SP-2].VR:
|                                                    STORE[SP-1].VI:STORE[SP].VI);
|                                   PRDADR: ERRORI(' WRITE ON PRD FILE  ');
|                                   PRRADR: WRITE(PRR,STORE[SP-2].VR:
|                                                 STORE[SP-1].VI:STORE[SP].VI);
|                                   QRDADR: ERRORI(' WRITE ON QRD FILE  ');
|                                   QRRADR: WRITE(QRR,STORE[SP-2].VR:
|                                                 STORE[SP-1].VI:STORE[SP].VI);
|                                END;
|                                SP:=SP-3
|                           END;
|                10 (*WRC*):BEGIN
|                               CASE STORE[SP-2].VA OF
|                                  INPUTADR: ERRORI(' WRITE ON INPUT FILE');
|                                  OUTPUTADR: WRITE(OUTPUT,CHR(STORE[SP-1].VI):
|                                                   STORE[SP].VI);
|                                  PRDADR: ERRORI(' WRITE ON PRD FILE  ');
|                                  PRRADR: WRITE(PRR,CHR(STORE[SP-1].VI):
|                                                STORE[SP].VI) ;
|                                  QRRADR: WRITE(QRR,CHR(STORE[SP-1].VI):
|                                                STORE[SP].VI)
|                               END;
|                               SP:=SP-2
|                           END;
|                26(*WRB*) : BEGIN
|                               "IF STORE[SP-1].VB THEN  STORE[SP-1].VI := 1
|                                ELSE  STORE[SP-1].VI := 0 ;"
| 
|                                CASE STORE[SP-2].VA OF
|                                   INPUTADR: ERRORI(' WRITE ON INPUT FILE');
|                                   OUTPUTADR: WRITE(OUTPUT,STORE[SP-1].VB:
|                                              STORE[SP].VI);
|                                   PRDADR: ERRORI(' WRITE ON PRD FILE  ');
|                                   PRRADR: WRITE(PRR,STORE[SP-1].VB:
|                                                 STORE[SP].VI) ;
|                                   QRDADR: ERRORI(' WRITE ON QRD FILE  ');
|                                   QRRADR: WRITE(QRR,STORE[SP-1].VB:
|                                                 STORE[SP].VI) ;
|                                END;
|                               SP:=SP-2
|                            END;
|                11(*RDI*) : CASE STORE[SP-1].VA OF
|                                INPUTADR: READI(INPUT);
|                                OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
|                                PRDADR: READI(PRD);
|                                QRDADR: READI(QRD);
|                                PRRADR, QRRADR: ERRORI(' READ ON WRONG FILE ')
|                            END;
|                12(*RDR*) : CASE STORE[SP-1].VA OF
|                                INPUTADR: READR(INPUT);
|                                OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
|                                PRDADR: READR(PRD);
|                                QRDADR: READR(QRD);
|                                PRRADR, QRRADR: ERRORI(' READ ON WRONG FILE ')
|                            END;
|                31(*RDB*) : CASE STORE[SP-1].VA OF
|                                INPUTADR: READB(INPUT);
|                                OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
|                                PRDADR: READB(PRD);
|                                QRDADR: READB(QRD);
|                                PRRADR, QRRADR: ERRORI(' READ ON WRONG FILE ')
|                            END;
|                13(*RDC*):  CASE STORE[SP-1].VA OF
|                                INPUTADR: READC(INPUT);
|                                OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
|                                PRDADR: READC(PRD);
|                                QRRADR,
|                                PRRADR: ERRORI(' READ ON PRR FILE   ') ;
|                                QRDADR: READC(QRD);
|                            END;
|                27(*RDS*):  CASE STORE[SP-2].VA OF
|                                INPUTADR: READSTR(INPUT);
|                                OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
|                                PRDADR: READSTR(PRD);
|                                QRRADR,
|                                PRRADR: ERRORI(' READ ON PRR FILE   ') ;
|                                QRDADR: READSTR(QRD);
|                            END;
| 
|                29(*EIO*): SP := SP-1;    (*POP THE FILE ADRE*)
| 
|                30(*FDF*): BEGIN ERRORI(' EXTERNAL FILE DEF. ')  END;
| 
|                14(*SIN*): BEGIN
|                           (* AD := STORE[SP].VA ;
|                              STYPE[SP]".STYPE" := REEL ; *)
|                              STORE[SP].VR := SIN(STORE[SP].VR)
|                           END   (* SIN *) ;
|                15(*COS*): BEGIN
|                           (* AD := STORE[SP].VA ;
|                              STYPE[SP]".STYPE" := REEL ;  *)
|                              STORE[SP].VR := COS(STORE[SP].VR)
|                           END   (* COS *) ;
|                16(*EXP*): BEGIN
|                           (* AD := STORE[SP].VA ;
|                              STYPE[SP]".STYPE" := REEL ; *)
|                              STORE[SP].VR := EXP(STORE[SP].VR)
|                           END   (* EXP *) ;
|                17(*LOG*): BEGIN
|                           (* AD := STORE[SP].VA ;
|                              STYPE[SP]".STYPE" := REEL ; *)
|                              STORE[SP].VR := LN(STORE[SP].VR)
|                           END   (* LOG *) ;
|                18(*SQT*): BEGIN
|                           (* AD := STORE[SP].VA ;
|                              STYPE[SP]".STYPE" := REEL ; *)
|                              STORE[SP].VR := SQRT(STORE[SP].VR)
|                           END   (* SQT *) ;
|                19(*ATN*): BEGIN
|                           (* AD := STORE[SP].VA ;
|                              STYPE[SP]".STYPE" := REEL ;*)
|                              STORE[SP].VR := ARCTAN(STORE[SP].VR)
|                           END   (* ATN *) ;
|                20(*SAV*): BEGIN AD:=STORE[SP].VA;
|                              STYPE[AD]".STYPE":=ADR;
|                              STORE[AD].VA:= NP;
|                              SP:= SP-1
|                           END;
|                21(*XIT*): BEGIN  INTERPRETING := FALSE;
|                           RETCDE := STORE[SP].VI;
|                           END ;
|                22 (* RES *):
|                   BEGIN
|                      CASE STORE[SP].VA OF
|                         INPUTADR: RESET(INPUT) ;
|                         OUTPUTADR: ERRORI(' RESET ON OUTPUT    ') ;
|                         PRDADR: RESET(PRD) ;
|                         QRRADR,PRRADR: ERRORI(' RESET ON PRR FILE  ') ;
|                         QRDADR: RESET(QRD) ;
|                      END   (* CASE STORE[SP].VA *) ;
|                   "  SP := SP - 1  "
|                   END   (* RES *) ;
|                23 (* REW *):
|                   BEGIN
|                      CASE STORE[SP].VA OF
|                         INPUTADR: ERRORI(' REWRITE ON INPUT   ') ;
|                         OUTPUTADR: REWRITE(OUTPUT) ;
|                         QRDADR,PRDADR: ERRORI(' REWRITE ON PRD FILE') ;
|                         PRRADR: REWRITE(PRR) ;
|                         QRRADR: REWRITE(QRR)
|                      END   (* CASE STORE[SP].VA *) ;
|                   "  SP := SP - 1   "
|                   END   (* REW *) ;
|                24 (* EOF *):
|                   BEGIN
|                      CASE STORE[SP].VA OF
|                         INPUTADR: STORE[SP].VB := EOF(INPUT) ;
|                         OUTPUTADR: ERRORI(' EOF ON OUTPUT      ') ;
|                         PRDADR: STORE[SP].VB := EOF(PRD) ;
|                         QRRADR,PRRADR: ERRORI(' EOF ON PRR FILE    ') ;
|                         QRDADR: STORE[SP].VB := EOF(QRD) ;
|                      END   (* CASE STORE[SP].VA *) ;
|                      STYPE[SP]".STYPE" := BOOL ;  SP := SP+1 ;
|                   END   (* EOF *) ;
| 
|                25 (* CLK *) :  STORE[SP].VI := CLOCK(STORE[SP].VI) ;
| 
|          END;(*CASE Q*)
|    END;(*CALLSP*)
| (*----------------------------------------------------------------------------*)
| 
| PROCEDURE EX0;
|    VAR AD,AD1 :ADDRESS;
|        I,I1,I2,J  :INTEGER;  B :BOOLEAN;
| 
|    PROCEDURE COMPARE;
|    BEGIN  I1 := STORE[SP].VA;  I2 := STORE[SP+1].VA;
|       I := 0;  B := TRUE;
|       WHILE B AND (I<>Q) DO
|          IF STORE[I1+I].VI=STORE[I2+I].VI THEN I := I+1
|          ELSE B := FALSE
|    END; (*COMPARE*)
| 
| BEGIN   (* EXO *)
|    (* IN THIS PROCEDURE Q MUST NOT BE CORRECTED *)
|    CASE OP OF
| 
|                 PABI:STORE[SP].VI := ABS(STORE[SP].VI);
| 
|                 PABR:STORE[SP].VR := ABS(STORE[SP].VR);
| 
|                 PADI:BEGIN  SP := SP-1;
|                       STORE[SP].VI := STORE[SP].VI + STORE[SP+1].VI
|                    END;
| 
|                 PADR:BEGIN  SP := SP-1;
|                       STORE[SP].VR := STORE[SP].VR + STORE[SP+1].VR
|                    END;
| 
|                 PAND:BEGIN  SP := SP-1;
|                       STORE[SP].VB := STORE[SP].VB AND STORE[SP+1].VB
|                    END;
| 
|                 PCHK:IF(STORE[SP].VI < STORE[Q].VI)
|                         OR (STORE[SP].VI > STORE[Q+1].VI) THEN
|                            ERRORI(' VALUE OUT OF RANGE ');
| 
|                 PCHR: (* NOTHING TO DO *) ;
| 
|                 PCSP: CALLSP ;
| 
|                 PCUP:BEGIN  (*P=NO. OF PARAMETERS, Q=ENTRY POINT*)
| (*                   IF CTRACE  THEN                                      (*+*)
| (*                      BEGIN                                             (*+*)
| (*                      WRITELN(OUTPUT,'     I_CNT: ',INSTRCNT:6,         (*+*)
| (*                                     ', SP: ',SP:5,',  NP: ', NP:5,     (*+*)
| (*                                     ',  MP: ', MP:5 , ',  PC: ',  PC:5,(*+*)
| (*                                     ' OP =', INSTR[OP]:4, '  (', OP:3, (*+*)
| (*                                     '  T: ', T:1, '  P: ', P:4,        (*+*)
| (*                                     '  Q: ',Q:6, ') --> ',             (*+*)
| (*                                     PROCTAB[CODE[Q-1].Q1] );           (*+*)
| (*                      END  (* IF CTRCE *) ;                             (*+*)
|                       MP := SP-(P + (SAVEAREA-1));
|                       STYPE[MP+3]".STYPE" := MARK;
|                       STORE[MP+3].VM := PC;
|                       PC := Q
|                    END;
| 
|                 PDEC:STORE[SP].VI := STORE[SP].VI - Q;
| 
|                 PDIF:BEGIN  SP := SP-1;
|                       STORE[SP].VS := STORE[SP].VS - STORE[SP+1].VS
|                    END;
| 
|                 PDVI:BEGIN  SP := SP-1;
|                       STORE[SP].VI := STORE[SP].VI DIV STORE[SP+1].VI
|                    END;
| 
|                 PDVR:BEGIN  SP := SP-1;
|                       STORE[SP].VR := STORE[SP].VR/STORE[SP+1].VR
|                    END;
| 
|                 PENT:BEGIN  J := MP+Q;  (*Q=LENGTH OF DATA SEG*)
|                       IF J>NP THEN ERRORI(' STORE OVERFLOW     ');
|                       STORE[MP+1].VM := DISPLAY[P] ;  DISPLAY[P] := MP ;
|                   """ (*RESET TO UNDEFINED--MAY DECIDE TO REMOVE THIS TEST*)
|                       IF SP<INPUTADR THEN SP := PRDADR;
|                       FOR I := SP+1 TO J DO STORE[I].STYPEò := UNDEF; """
|                       STORE[MP+4].VM := CURLVL ;  SP := J;  CURLVL := P ;
|                       IF STK_LMT < SP THEN STK_LMT := SP;
|                    END;
| 
|                 PEQU:BEGIN  SP := SP-1;
|                       CASE P OF
|                       0,1: STORE[SP].VB := STORE[SP].VI=STORE[SP+1].VI;
|                         2: STORE[SP].VB := STORE[SP].VR=STORE[SP+1].VR;
|                         3: STORE[SP].VB := STORE[SP].VB=STORE[SP+1].VB;
|                         4: STORE[SP].VB := STORE[SP].VS=STORE[SP+1].VS;
|                         5: BEGIN  COMPARE;
|                               STORE[SP].VB := B;
|                            END
|                       END; (*CASE P*)
|                       STYPE[SP]".STYPE" := BOOL
|                    END;
| 
|                 PFJP:BEGIN
|                    IF NOT STORE[SP].VB THEN
|                       BEGIN   PC := Q;
|                       IF STAT3 THEN BDCNT[P].CNT := BDCNT[P].CNT+1
|                       END ;
|                    SP := SP-1
|                    END;
| 
|                 PFLO:BEGIN  STORE[SP-1].VR := STORE[SP-1].VI;
|                       STYPE[SP-1]".STYPE" := REEL
|                    END;
| 
|                 PFLT:BEGIN  STORE[SP].VR := STORE[SP].VI;
|                       STYPE[SP]".STYPE" := REEL
|                    END;
| 
|                 PGEQ:BEGIN  SP := SP-1;
|                       CASE P OF
|                       0,1: STORE[SP].VB := STORE[SP].VI>=STORE[SP+1].VI;
|                         2: STORE[SP].VB := STORE[SP].VR>=STORE[SP+1].VR;
|                         3: STORE[SP].VB := STORE[SP].VB>=STORE[SP+1].VB;
|                         4: STORE[SP].VB := STORE[SP].VS>=STORE[SP+1].VS;
|                         5: BEGIN COMPARE;
|                               STORE[SP].VB := (STORE[I1+I].VI>=STORE[I2+I].VI)
|                                  OR B
|                            END
|                       END; (*CASE P*)
|                       STYPE[SP]".STYPE" := BOOL
|                    END;
| 
|                 PGRT:BEGIN  SP := SP-1;
|                       CASE P OF
|                       0,1: STORE[SP].VB := STORE[SP].VI>STORE[SP+1].VI;
|                         2: STORE[SP].VB := STORE[SP].VR>STORE[SP+1].VR;
|                         3: STORE[SP].VB := STORE[SP].VB>STORE[SP+1].VB;
|                         4: ERRORI(' SET INCLUSION      ');
|                         5: BEGIN  COMPARE;
|                               STORE[SP].VB := (STORE[I1+I].VI>STORE[I2+I].VI)AND
|                                   NOT B
|                            END
|                       END; (*CASE P*)
|                       STYPE[SP]".STYPE" := BOOL
|                    END;
| 
|                 PINC:BEGIN STORE[SP].VI := STORE[SP].VI + Q;
|                      END ;
| 
|                 PIND:BEGIN  AD := STORE[SP].VI + Q; (* Q IS # OF STORAGE LOCS *)
|                       IF STYPE[AD]".STYPE"=UNDEF THEN
|                          ERRORI(' VALUE UNDEFINED    ') ;
|                       STORE[SP] := STORE[AD] ;    STYPE[SP] := STYPE[AD];
|                    END;
| 
|                 PINN:BEGIN  SP := SP-1;
|                       STORE[SP].VB := STORE[SP].VI IN STORE[SP+1].VS;
|                       STYPE[SP]".STYPE" := BOOL
|                    END;
| 
|                 PINT:BEGIN  SP := SP-1;
|                       STORE[SP].VS := STORE[SP].VS *  STORE[SP+1].VS
|                    END;
| 
|                 PIOR:BEGIN  SP := SP-1;
|                       STORE[SP].VB := STORE[SP].VB OR STORE[SP+1].VB
|                    END;
| 
|                 PIXA:BEGIN
|                      IF STYPE[SP]".STYPE" = BOOL THEN
|                         BEGIN
|                         IF STORE[SP].VB THEN STORE[SP].VI := 1
|                         ELSE  STORE[SP].VI := 0 ;
|                         STYPE[SP]".STYPE" := INT ;
|                         END ;
|                      IF STYPE[SP]".STYPE" <> INT THEN
|                         ERRORI(' NON INTEGER IXA ARG') ;
|                      SP := SP-1; (* Q IS A NUMBER OF STORAGE UNITS *)
|                       STORE[SP].VA := Q*STORE[SP+1].VI + STORE[SP].VA
|                    END;
| 
|                 PLAO:BEGIN  PUSH;
|                       STORE[SP].VA := Q;
|                       STYPE[SP]".STYPE" := ADR
|                    END;
| 
|                 PLCA:BEGIN  PUSH;
|                       STORE[SP].VA := Q;
|                       STYPE[SP]".STYPE" := ADR
|                    END;
| 
|                 PLDA:BEGIN  PUSH;
|                       STORE[SP].VA := DISPLAY[P] + Q;
|                       STYPE[SP]".STYPE" := ADR
|                    END;
| 
|                 PLDC:BEGIN  PUSH;
|                       IF P=1 THEN
|                          BEGIN  STORE[SP].VI := Q;
|                          STYPE[SP]".STYPE" := INT
|                          END ELSE
|                       IF P=3 THEN
|                          BEGIN  STORE[SP].VB := Q=1;
|                          STYPE[SP]".STYPE" := BOOL
|                          END
|                       ELSE (*LOAD NIL*)
|                          BEGIN  STORE[SP].VA := NILVAL;
|                          STYPE[SP]".STYPE" := ADR
|                          END
|                    END;
| 
|                 PLDO:BEGIN
|                       IF STYPE[Q]".STYPE"=UNDEF THEN
|                         ERRORI(' VALUE UNDEFINED    ') ;
|                       IF STYPE[Q]".STYPE" <> T THEN
|                          BEGIN  ERRORI0(AD);
|                          ERRORI(' INCOMPATIBLE TYPE  ') ;
|                          END;
|                       PUSH;
|                       STORE[SP] := STORE[Q];  STYPE[SP] := STYPE[Q];
|                    END;
| 
|                 PLEQ:BEGIN  SP := SP-1;
|                       CASE P OF
|                       0,1: STORE[SP].VB := STORE[SP].VI<=STORE[SP+1].VI;
|                         2: STORE[SP].VB := STORE[SP].VR<=STORE[SP+1].VR;
|                         3: STORE[SP].VB := STORE[SP].VB<=STORE[SP+1].VB;
|                         4: STORE[SP].VB := STORE[SP].VS<=STORE[SP+1].VS;
|                         5: BEGIN  COMPARE;
|                               STORE[SP].VB := (STORE[I1+I].VI<=STORE[I2+I].VI)
|                                  OR B
|                            END
|                       END; (*CASE P*)
|                       STYPE[SP]".STYPE" := BOOL
|                    END;
| 
|                 PLES:BEGIN  SP := SP-1;
|                       CASE P OF
|                       0,1: STORE[SP].VB := STORE[SP].VI<STORE[SP+1].VI;
|                         2: STORE[SP].VB := STORE[SP].VR<STORE[SP+1].VR;
|                         3: STORE[SP].VB := STORE[SP].VB<STORE[SP+1].VB;
|                         5: BEGIN  COMPARE;
|                               STORE[SP].VB := (STORE[I1+I].VI<STORE[I2+I].VI)AND
|                                  NOT B
|                            END
|                       END; (*CASE P*)
|                       STYPE[SP]".STYPE" := BOOL
|                    END;
| 
| 
|                PLOD:BEGIN  AD := DISPLAY[P] + Q;
|                       IF STYPE[AD]".STYPE"=UNDEF THEN
|                          ERRORI(' VALUE UNDEFINED    ') ;
|                       IF STYPE[AD]".STYPE" <> T THEN
|                          BEGIN  ERRORI0(AD);
|                          ERRORI(' INCOMPATIBLE TYPE  ') ;
|                          END;
|                       PUSH;
|                       STORE[SP] := STORE[AD];  STYPE[SP] := STYPE[AD];
|                    END
| 
|    END  (* CASE *)
| END   (* EX0 *) ;
| (*----------------------------------------------------------------------------*)
| 
| PROCEDURE EX1;
|    VAR AD,AD1 :ADDRESS;
|        I,I1,I2,J  :INTEGER;  B :BOOLEAN;
| 
|    PROCEDURE COMPARE;
|    BEGIN  I1 := STORE[SP].VA;  I2 := STORE[SP+1].VA;
|       I := 0;  B := TRUE;
|       WHILE B AND (I<>Q) DO
|          IF STORE[I1+I].VI=STORE[I2+I].VI THEN I := I+1
|          ELSE B := FALSE
|    END; (*COMPARE*)
| 
| BEGIN   (* EX1 *)
|    (* IN THIS PROCEDURE Q MUST NOT BE CORRECTED *)
|    CASE OP OF
| 
|                 PMOD:BEGIN  SP := SP-1;
|                       STORE[SP].VI := STORE[SP].VI MOD STORE[SP+1].VI
|                    END;
| 
|                 PMOV: BEGIN I1 := STORE[SP-1].VA; I2 := STORE[SP].VA;
|                          SP := SP - 2 ;
|                        FOR I := 0 TO Q-1 DO
|                           BEGIN
|                           STORE[I1+I] := STORE[I2+I]; STYPE[I1+I] := STYPE[I2+I]
|                           END;
|                       (* Q IS A NUMBER OF STORAGE UNITS *)
|                     END;
| 
|                 PMPI:BEGIN  SP := SP-1;
|                       STORE[SP].VI := STORE[SP].VI * STORE[SP+1].VI
|                    END;
| 
|                 PMPR:BEGIN  SP := SP-1;
|                       STORE[SP].VR := STORE[SP].VR * STORE[SP+1].VR
|                    END;
| 
|                 PMST:BEGIN (*P=LEVEL OF CALLED PROCEDURE , SET DL
|                              SL WILL BE SET AT 'ENT', INCREMENT SP*)
|                       STYPE[SP+1]".STYPE" := UNDEF;
|                       (* THEN LENTH OF THIS ELEMENT IS
|                         MAX(INTSIZE,REALSIZE,BOOLSIZE,CHARSIZE,PTRSIZE *)
|                       STYPE[SP+2]".STYPE" := MARK;
|                       (* THE LENGTH OF THIS ELEMENT IS PTRSIZE *)
|                       STYPE[SP+3]".STYPE" := MARK;
|                       STORE[SP+3].VM := MP;
|                       (* IDEM *)
|                       "STYPE[SP+4]¯.STYPEò := UNDEF;"
|                       (* IDEM *)
|                       SP := SP+SAVEAREA ;
|                    END;
| 
|                 PNEQ:BEGIN  SP := SP-1;
|                       CASE P OF
|                       0,1: STORE[SP].VB := STORE[SP].VI<>STORE[SP+1].VI;
|                         2: STORE[SP].VB := STORE[SP].VR<>STORE[SP+1].VR;
|                         3: STORE[SP].VB := STORE[SP].VB<>STORE[SP+1].VB;
|                         4: STORE[SP].VB := STORE[SP].VS<>STORE[SP+1].VS;
|                         5: BEGIN  COMPARE;
|                               STORE[SP].VB := NOT B;
|                            END
|                       END; (*CASE P*)
|                       STYPE[SP]".STYPE" := BOOL
|                    END;
| 
|                 PNGI:STORE[SP].VI := -STORE[SP].VI;
| 
|                 PNGR:STORE[SP].VR := -STORE[SP].VR;
| 
|                 PNOT:STORE[SP].VB := NOT STORE[SP].VB;
| 
|                 PODD:BEGIN  STORE[SP].VB := ODD(STORE[SP].VI);
|                       STYPE[SP]".STYPE" := BOOL
|                    END;
| 
|                 PORD:
|                      BEGIN
|                         IF STYPE[SP]".STYPE" = BOOL THEN
|                            BEGIN
|                               IF STORE[SP].VB THEN  STORE[SP].VI := 1
|                               ELSE STORE[SP].VI := 0 ;
|                               STYPE[SP]".STYPE" := INT ;
|                            END ;
|                            IF STYPE[SP]".STYPE" <> INT THEN
|                               ERRORI(' NON INT ARG FOR ORD') ;
|                      END ;
| 
|                 PNEW:      BEGIN AD := NP - Q ;
|                            (*TOP OF STACK GIVES THE ADDRESS TO BE STORED INTO*)
|                                  IF AD<= SP THEN
|                                     ERRORI(' STORE OVERFLOW     ') ;
|                                  FOR I:=NP-1 DOWNTO AD DO
|                                     STYPE[I]".STYPE":= UNDEF;
|                                  NP:= AD; AD:= STORE[SP].VA;
|                                  STORE[AD].VA:= NP;
|                                  STYPE[AD]".STYPE":=ADR;
|                                  SP := SP - 1;
|                                  IF HEAP_LMT > NP THEN  HEAP_LMT := NP;
|                            END(*PNEW*);
| 
|                 PPRE: BEGIN  STORE[SP].VI := STORE[SP].VI-1; END;
| 
|                 PRST:      BEGIN NP:= STORE[SP].VI; SP:=SP-1  END ;
| 
|                 PSAV :     BEGIN AD:=STORE[SP].VA;
|                               STYPE[AD]".STYPE":=ADR;
|                               STORE[AD].VA:= NP;
|                               SP:= SP-1
|                            END(*PSAV*);
| 
|                 PRET :
|                      BEGIN
|                         IF T = UNDEF THEN  SP := MP-1
|                         ELSE
|                           BEGIN SP := MP; "STORE[SP] := STORE[MP+FUNCRSLT]" END;
|                         PC:= STORE[MP+3].VM;
|                         DISPLAY[CURLVL] := STORE[MP+1].VM ;  (*RESTORE DISPLAY*)
|                         CURLVL := STORE[MP+4].VM ;
|                         MP:= STORE[MP+2].VM ;   (*=DISPLAY[CURLVL]*)
|                      END  (*PRET*) ;
| 
|                 PSBI:BEGIN SP := SP-1;
|                       STORE[SP].VI := STORE[SP].VI - STORE[SP+1].VI
|                    END;
| 
|                 PSBR:BEGIN  SP := SP-1;
|                       STORE[SP].VR := STORE[SP].VR - STORE[SP+1].VR
|                    END ;
| 
|                 PSGS:BEGIN  STORE[SP].VS := [STORE[SP].VI];
|                       STYPE[SP]".STYPE" := SETT
|                    END;
| 
|                 PSQI:STORE[SP].VI := SQR(STORE[SP].VI);
| 
|                 PSQR:STORE[SP].VR := SQR(STORE[SP].VR);
| 
|                 PSRO: BEGIN
|                       STORE[Q] := STORE[SP];  STYPE[Q] := STYPE[SP];
|                       SP := SP-1
|                       END;
| 
|                 PSTO: BEGIN  AD := STORE[SP-1].VA;
|                       STORE[AD] := STORE[SP];  STYPE[AD] := STYPE[SP];
|                       SP := SP-2
|                       END;
| 
|                 PSTP: BEGIN  INTERPRETING := FALSE;  RETCDE := 0;  END;
| 
|                 PSUC: BEGIN  STORE[SP].VI := STORE[SP].VI+1;   END;
| 
|                 PSTR: BEGIN  AD := DISPLAY[P]+Q;
|                       STORE[AD] := STORE[SP]; STYPE[AD] := STYPE[SP];
|                       SP := SP-1
|                       END;
| 
|                 PTOF: TRCE := FALSE ;
| 
|                 PTON: TRCE := TRUE ;
| 
|                 PTRC: BEGIN STORE[SP].VI := TRUNC(STORE[SP].VR);
|                       STYPE[SP]".STYPE" := INT ;
|                       END;
| 
|                 PUJP: BEGIN  PC := Q;
|                       IF STAT3 THEN   BDCNT[P].CNT := BDCNT[P].CNT+1
|                       END ;
| 
|                 PUNI: BEGIN  SP := SP-1;
|                       STORE[SP].VS := STORE[SP].VS +  STORE[SP+1].VS
|                       END ;
| 
|                 PXJP: BEGIN
|                       IF STYPE[SP]".STYPE" <> INT THEN
|                          ERRORI(' NON INT ARG FOR XJP') ;
|                       I1 := CODE[PC].Q1 ; (*ASSUME OFF CASE TABLE RANGE*)
|                       I := STORE[SP].VI ;
|                       IF I <= CODE[PC+2].Q1  THEN   (*CHECK AGAINS UPPER BOUND*)
|                          BEGIN  I := I-CODE[PC+1].Q1 ; (*SUBTRACT LOWER BOUND*)
|                          IF I >= 0 THEN  I1 := I+Q ; (*ADJUST PC IF IN RANGE*)
|                          END ;
|                       PC := I1 ;   SP := SP-1 ;
|                       END ;
| 
|                 PLCI: BEGIN  PUSH; STORE[SP] := STORE[Q]; STYPE[SP] := STYPE[Q];
|                       END
| 
|        END (*CASE OP*)
| END   (* EX1 *) ;
| 
| (*------------------------------------------------------------------------*)
| 
| BEGIN   (*PCODE_INTERPRETER*)   (*  M A I N  *)
|    TIMER := 0;
|    LOAD;  (* ASSEMBLES AND STORES CODE *)
|    WRITELN(OUTPUT); (*FOR TESTING*)
|    SP := LSTBUF;  MP := 0;  NP := CPL+1;
|    STORE[1].VM := 0 ;  STORE[2].VM := 0 ;   (* SL AND DL FOR THE MAIN BLK *)
|    STORE[3].VM := PC-1 ;                    (* RETURN ADDRESS FOR MAINBLK *)
|    FOR P := 2 TO 10 DO DISPLAY[P] := -1 ;
|    DISPLAY[1] := 0 ;  CURLVL := 1 ;
|    PC := EP;   RETCDE := 0;  INSTRCNT := 0;  STK_LMT := 0;  HEAP_LMT := CPL;
|    STYPE[INPUTADR]".STYPE" := INT;
|    STORE[INPUTADR].VI := ORD(INPUT@);
|    STYPE[PRDADR]".STYPE":= INT;
|    STORE[PRDADR].VI:= ORD(PRD@);
|    STYPE[OUTPUTADR]".STYPE":= UNDEF;  STYPE[QRRADR]".STYPE" := UNDEF ;
|    GETSTAT :=TRUE;
|    IF GETSTAT THEN
|      BEGIN
|      STAT1:= TRUE ; STAT4:= TRUE ;  STAT2:= TRUE ; STAT3:= TRUE ; STAT5:= TRUE ;
|      END;
| 
|    INTERPRETING := TRUE;  LOADING := FALSE ;
|    IF GETSTAT THEN  CLEARCOUNTS ;
| 
| 
|    (* BEGIN INTERPRETING THE PROGRAM *)
| 
|    REPEAT   (* INTERPRET ALL INSTRUCTIONS *)
|       WITH CODE[PC ] DO
|          BEGIN   Q := Q1 ; OP := OP1 MOD 256;
|          P := OP1 DIV (65536);  T := CHR((OP1 DIV 256) MOD 256);
|          END;
|       IF TRCE (*OR ((INSTRCNT MOD 1000) = 0)*) THEN
|       BEGIN
|          WRITE(OUTPUT,'     I_CNT: ',INSTRCNT:6,', SP: ',SP:5,',  NP: ', NP:5,
|                       ',  MP: ', MP:5);
|          WRITELN(OUTPUT, ',  PC: ',  PC:5, ' OP =', INSTR[OP]:4, '  (', OP:3,
|                          '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:6, ')' );
|       END  (* TRCE *) ;
| 
|       (* EXECUTION COUNTERS *)
| 
|       PC := PC+1;  INSTRCNT := INSTRCNT+1 ;
|       IF GETSTAT THEN  COUNT ;
| 
|       (*EXECUTE*)
| 
|       IF OP <= PLOD THEN EX0 ELSE EX1 ;
| 
|    UNTIL NOT INTERPRETING ;
| 
| 
|    TIMER := CLOCK(1)-TIMER;
|    WRITELN(OUTPUT) ;    WRITELN(OUTPUT) ;
|    WRITELN(OUTPUT,'    >>>>  EXITING USER PROGRAM,  RETURN CODE = ',RETCDE:2);
| 
|    PRINT_HEADLN(OUTPUT);
| 
|    IF GETSTAT THEN  BEGIN  PRINT_HEADLN(SFL);  PRINTCOUNTS;  END;
| 
|    EXIT(RETCDE);
| 
| END.
> Member PRETTY
| (*====================================================================*)
| (*                                                                    *)
| (*  PROGRAM TITLE: PASCAL PRETTYPRINTING PROGRAM                      *)
| (*                                                                    *)
| (*  AUTHORS: JON F. HUERAS AND HENRY F. LEDGARD                       *)
| (*           COMPUTER AND INFORMATION SCIENCE DEPARTMENT              *)
| (*           UNIVERSITY OF MASSACHUSETTS, AMHERST                     *)
| (*           (EARLIER VERSIONS AND CONTRIBUTIONS BY RANDY CHOW        *)
| (*            AND JOHN GORMAN.)                                       *)
| (*                                                                    *)
| (*  PROGRAM SUMMARY:                                                  *)
| (*                                                                    *)
| (*     THIS PROGRAM TAKES AS INPUT A PASCAL PROGRAM AND               *)
| (*     REFORMATS THE PROGRAM ACCORDING TO A STANDARD SET OF           *)
| (*     PRETTYPRINTING RULES. THE PRETTYPRINTED PROGRAM IS GIVEN       *)
| (*     AS OUTPUT.  THE PRETTYPRINTING RULES ARE GIVEN BELOW.          *)
| (*                                                                    *)
| (*     AN IMPORTANT FEATURE IS THE PROVISION FOR THE USE OF EXTRA     *)
| (*     SPACES AND EXTRA BLANK LINES.  THEY MAY BE FREELY INSERTED BY  *)
| (*     THE USER IN ADDITION TO THE SPACES AND BLANK LINES INSERTED    *)
| (*     BY THE PRETTYPRINTER.                                          *)
| (*                                                                    *)
| (*     NO ATTEMPT IS MADE TO DETECT OR CORRECT SYNTACTIC ERRORS IN    *)
| (*     THE USER'S PROGRAM.  HOWEVER, SYNTACTIC ERRORS MAY RESULT IN   *)
| (*     ERRONEOUS PRETTYPRINTING.                                      *)
| (*                                                                    *)
| (*                                                                    *)
| (*  INPUT FILE: INPUTFL      - A FILE OF CHARACTERS, PRESUMABLY A     *)
| (*                             PASCAL PROGRAM OR PROGRAM FRAGMENT.    *)
| (*                                                                    *)
| (*  OUTPUT FILES: OUTPUTFL   - THE PRETTYPRINTED PROGRAM.             *)
| (*                                                                    *)
| (*                OUTPUT     - STANDARD PASCAL FILE FOR RUNTIME       *)
| (*                             MESSAGES.                              *)
| (*                                                                    *)
| (*                                                                    *)
| (*====================================================================*)
| 
| 
| (*====================================================================*)
| (*                                                                    *)
| (*                   PASCAL PRETTYPRINTING RULES                      *)
| (*                                                                    *)
| (*                                                                    *)
| (*  [ GENERAL PRETTYPRINTING RULES ]                                  *)
| (*                                                                    *)
| (*   1.   ANY SPACES OR BLANK LINES BEYOND THOSE GENERATED BY THE     *)
| (*     PRETTYPRINTER ARE LEFT ALONE.  THE USER IS ENCOURAGED, FOR THE *)
| (*     SAKE OF READABILITY, TO MAKE USE OF THIS FACILITY.             *)
| (*        IN ADDITION, COMMENTS ARE LEFT WHERE THEY ARE FOUND, UNLESS *)
| (*     THEY ARE SHIFTED RIGHT BY PRECEEDING TEXT ON A LINE.           *)
| (*                                                                    *)
| (*   2.   ALL STATEMENTS AND DECLARATIONS BEGIN ON SEPARATE LINES.    *)
| (*                                                                    *)
| (*   3.   NO LINE MAY BE GREATER THAN 72 CHARACTERS LONG.  ANY LINE   *)
| (*     LONGER THAN THIS IS CONTINUED ON A SEPARATE LINE.              *)
| (*                                                                    *)
| (*   4.   THE KEYWORDS "BEGIN", "END", "REPEAT", AND "RECORD" ARE     *)
| (*     FORCED TO STAND ON LINES BY THEMSELVES (OR POSSIBLY FOLLWED BY *)
| (*     SUPPORTING COMMENTS).                                          *)
| (*        IN  ADDITION, THE "UNTIL" CLAUSE OF A "REPEAT-UNTIL" STATE- *)
| (*     MENT IS FORCED TO START ON A NEW LINE.                         *)
| (*                                                                    *)
| (*   5.   A BLANK LINE IS FORCED BEFORE THE KEYWORDS "PROGRAM",       *)
| (*     "PROCEDURE", "FUNCTION", "LABEL", "CONST", "TYPE", AND "VAR".  *)
| (*                                                                    *)
| (*   6.   A SPACE IS FORCED BEFORE AND AFTER THE SYMBOLS ":=" AND     *)
| (*     "=".  ADDITIONALLY, A SPACE IS FORCED AFTER THE SYMBOL ":".    *)
| (*                                                                    *)
| (*                                                                    *)
| (*  [ INDENTATION RULES ]                                             *)
| (*                                                                    *)
| (*   1.   THE BODIES OF "LABEL", "CONST", "TYPE", AND "VAR" DECLARA-  *)
| (*     TIONS ARE INDENTED FROM THEIR CORRESPONDING DECLARATION HEADER *)
| (*     KEYWORDS.                                                      *)
| (*                                                                    *)
| (*   2.   THE BODIES OF "BEGIN-END", "REPEAT-UNTIL", "FOR", "WHILE",  *)
| (*     "WITH", AND "CASE" STATEMENTS, AS WELL AS "RECORD-END" STRUC-  *)
| (*     TURES AND "CASE" VARIANTS (TO ONE LEVEL) ARE INDENTED FROM     *)
| (*     THEIR HEADER KEYWORDS.                                         *)
| (*                                                                    *)
| (*   3.   AN "IF-THEN-ELSE" STATEMENT IS INDENTED AS FOLLOWS:         *)
| (*                                                                    *)
| (*             IF <EXPRESSION>                                        *)
| (*                THEN                                                *)
| (*                   <STATEMENT>                                      *)
| (*                ELSE                                                *)
| (*                   <STATEMENT>                                      *)
| (*                                                                    *)
| (*                                                                    *)
| (*====================================================================*)
| 
| 
| (*====================================================================*)
| (*                                                                    *)
| (*                      GENERAL ALGORITHM                             *)
| (*                                                                    *)
| (*                                                                    *)
| (*      THE STRATEGY OF THE PRETTYPRINTER IS TO SCAN SYMBOLS FROM     *)
| (*   THE INPUT PROGRAM AND MAP EACH SYMBOL INTO A PRETTYPRINTING      *)
| (*   ACTION, INDEPENDENTLY OF THE CONTEXT IN WHICH THE SYMBOL         *)
| (*   APPEARS.  THIS IS ACCOMPLISHED BY A TABLE OF PRETTYPRINTING      *)
| (*   OPTIONS.                                                         *)
| (*                                                                    *)
| (*      FOR EACH DISTINGUISHED SYMBOL IN THE TABLE, THERE IS AN       *)
| (*   ASSOCIATED SET OF OPTIONS.  IF THE OPTION HAS BEEN SELECTED FOR  *)
| (*   THE SYMBOL BEING SCANNED, THEN THE ACTION CORRESPONDING WITH     *)
| (*   EACH OPTION IS PERFORMED.                                        *)
| (*                                                                    *)
| (*      THE BASIC ACTIONS INVOLVED IN PRETTYPRINTING ARE THE INDENT-  *)
| (*   ATION AND DE-INDENTATION OF THE MARGIN.  EACH TIME THE MARGIN IS *)
| (*   INDENTED, THE PREVIOUS VALUE OF THE MARGIN IS PUSHED ONTO A      *)
| (*   STACK, ALONG WITH THE NAME OF THE SYMBOL THAT CAUSED IT TO BE    *)
| (*   INDENTED.  EACH TIME THE MARGIN IS DE-INDENTED, THE STACK IS     *)
| (*   POPPED OFF TO OBTAIN THE PREVIOUS VALUE OF THE MARGIN.           *)
| (*                                                                    *)
| (*      THE PRETTYPRINTING OPTIONS ARE PROCESSED IN THE FOLLOWING     *)
| (*   ORDER, AND INVOKE THE FOLLOWING ACTIONS:                         *)
| (*                                                                    *)
| (*                                                                    *)
| (*     CRSUPPRESS      - IF A CARRIAGE RETURN HAS BEEN INSERTED       *)
| (*                       FOLLOWING THE PREVIOUS SYMBOL, THEN IT IS    *)
| (*                       INHIBITED UNTIL THE NEXT SYMBOL IS PRINTED.  *)
| (*                                                                    *)
| (*     CRBEFORE        - A CARRIAGE RETURN IS INSERTED BEFORE THE     *)
| (*                       CURRENT SYMBOL (UNLESS ONE IS ALREADY THERE) *)
| (*                                                                    *)
| (*     BLANKLINEBEFORE - A BLANK LINE IS INSERTED BEFORE THE CURRENT  *)
| (*                       SYMBOL (UNLESS ALREADY THERE).               *)
| (*                                                                    *)
| (*     DINDENTONKEYS   - IF ANY OF THE SPECIFIED KEYS ARE ON TOP OF   *)
| (*                       OF THE STACK, THE STACK IS POPPED, DE-INDEN- *)
| (*                       TING THE MARGIN.  THE PROCESS IS REPEATED    *)
| (*                       UNTIL THE TOP OF THE STACK IS NOT ONE OF THE *)
| (*                       SPECIFIED KEYS.                              *)
| (*                                                                    *)
| (*     DINDENT         - THE STACK IS UNCONDITIONALLY POPPED AND THE  *)
| (*                       MARGIN IS DE-INDENTED.                       *)
| (*                                                                    *)
| (*     SPACEBEFORE     - A SPACE IS INSERTED BEFORE THE SYMBOL BEING  *)
| (*                       SCANNED (UNLESS ALREADY THERE).              *)
| (*                                                                    *)
| (*     [ THE SYMBOL IS PRINTED AT THIS POINT ]                        *)
| (*                                                                    *)
| (*     SPACEAFTER      - A SPACE IS INSERTED AFTER THE SYMBOL BEING   *)
| (*                       SCANNED (UNLESS ALREADY THERE).              *)
| (*                                                                    *)
| (*     GOBBLESYMBOLS   - SYMBOLS ARE CONTINUOUSLY SCANNED AND PRINTED *)
| (*                       WITHOUT ANY PROCESSING UNTIL ONE OF THE      *)
| (*                       SPECIFIED SYMBOLS IS SEEN (BUT NOT GOBBLED). *)
| (*                                                                    *)
| (*     INDENTBYTAB     - THE MARGIN IS INDENTED BY A STANDARD AMOUNT  *)
| (*                       FROM THE PREVIOUS MARGIN.                    *)
| (*                                                                    *)
| (*     INDENTTOCLP     - THE MARGIN IS INDENTED TO THE CURRENT LINE   *)
| (*                       POSITION.                                    *)
| (*                                                                    *)
| (*     CRAFTER         - A CARRIAGE RETURN IS INSERTED FOLLOWING THE  *)
| (*                       SYMBOL SCANNED.                              *)
| (*                                                                    *)
| (*                                                                    *)
| (*                                                                    *)
| (*====================================================================*)
| 
| 
| PROGRAM PRETTYPRINT """ ( (* FROM *)  INPUTFL  ,
|                      (* TO *)    OUTPUTFL  ,
|                      (* USING *) OUTPUT ) """ ;
| 
| 
| CONST
| 
|       MAXSYMBOLSIZE = 200; (* THE MAXIMUM SIZE (IN CHARACTERS) OF A   *)
|                            (* SYMBOL SCANNED BY THE LEXICAL SCANNER.  *)
| 
|       MAXSTACKSIZE  = 100; (* THE MAXIMUM NUMBER OF SYMBOLS CAUSING   *)
|                            (* INDENTATION THAT MAY BE STACKED.        *)
| 
|       MAXKEYLENGTH  =  10; (* THE MAXIMUM LENGTH (IN CHARACTERS) OF A *)
|                            (* PASCAL RESERVED KEYWORD.                *)
|       MAXLINESIZE   =  72; (* THE MAXIMUM SIZE (IN CHARACTERS) OF A   *)
|                            (* LINE OUTPUT BY THE PRETTYPRINTER.       *)
| 
|       SLOWFAIL1     =  30; (* UP TO THIS COLUMN POSITION, EACH TIME   *)
|                            (* "INDENTBYTAB" IS INVOKED, THE MARGIN    *)
|                            (* WILL BE INDENTED BY "INDENT1".          *)
| 
|       SLOWFAIL2     =  48; (* UP TO THIS COLUMN POSITION, EACH TIME   *)
|                            (* "INDENTBYTAB" IS INVOKED, THE MARGIN    *)
|                            (* WILL BE INDENTED BY "INDENT2".  BEYOND  *)
|                            (* THIS, NO INDENTATION OCCURS.            *)
| 
|       INDENT1       =   3;
| 
|       INDENT2       =   1;
| 
| 
|       SPACE = ' ';
| 
| 
| TYPE
| 
|      KEYSYMBOL = ( PROGSYM,    FUNCSYM,     PROCSYM,
|                    LABELSYM,   CONSTSYM,    TYPESYM,   VARSYM,
|                    BEGINSYM,   REPEATSYM,   RECORDSYM,
|                    CASESYM,    CASEVARSYM,  OFSYM,
|                    FORSYM,     WHILESYM,    WITHSYM,   DOSYM,
|                    IFSYM,      THENSYM,     ELSESYM,
|                    ENDSYM,     UNTILSYM,
|                    BECOMES,    OPENCOMMENT, CLOSECOMMENT,
|                    SEMICOLON,  COLON,       EQUALS,
|                    OPENPAREN,  CLOSEPAREN,  PERIOD,
|                    ENDOFFILE,
|                    OTHERSYM );
| 
|      OPTION = ( CRSUPPRESS,
|                 CRBEFORE,
|                 BLANKLINEBEFORE,
|                 DINDENTONKEYS,
|                 DINDENT,
|                 SPACEBEFORE,
|                 SPACEAFTER,
|                 GOBBLESYMBOLS,
|                 INDENTBYTAB,
|                 INDENTTOCLP,
|                 CRAFTER );
| 
|      OPTIONSET = SET OF OPTION;
| 
|      KEYSYMSET = SET OF KEYSYMBOL;
| 
|      TABLEENTRY = RECORD
|                      OPTIONSSELECTED  : OPTIONSET;
|                      DINDENTSYMBOLS   : KEYSYMSET;
|                      GOBBLETERMINATORS: KEYSYMSET
|                   END;
| 
|      OPTIONTABLE = ARRAY [ KEYSYMBOL ] OF TABLEENTRY;
| 
| 
|      KEY = PACKED ARRAY [ 1..MAXKEYLENGTH ] OF CHAR;
| 
| 
|      KEYWORDTABLE = ARRAY [ PROGSYM..UNTILSYM ] OF KEY;
| 
| 
|      SPECIALCHAR = PACKED ARRAY [ 1..2 ] OF CHAR;
| 
|      DBLCHRSET = SET OF BECOMES..OPENCOMMENT;
| 
|      DBLCHARTABLE = ARRAY [ BECOMES..OPENCOMMENT ] OF SPECIALCHAR;
| 
|      SGLCHARTABLE = ARRAY [ SEMICOLON..PERIOD ] OF CHAR;
| 
| 
|      STRING = ARRAY [ 1..MAXSYMBOLSIZE ] OF CHAR;
| 
|      SYMBOL = RECORD
|                  NAME        : KEYSYMBOL;
|                  VALUE       : STRING;
|                  LENGTH      : INTEGER;
|                  SPACESBEFORE: INTEGER;
|                  CRSBEFORE   : INTEGER
|               END;
| 
|      SYMBOLINFO = @SYMBOL;
| 
| 
|      CHARNAME = ( LETTER,    DIGIT,    BLANK,    QUOTE,
|                   ENDOFLINE, FILEMARK, OTHERCHAR       );
| 
|      CHARINFO = RECORD
|                    NAME : CHARNAME;
|                    VALUE: CHAR
|                 END;
| 
| 
|      STACKENTRY = RECORD
|                      INDENTSYMBOL: KEYSYMBOL;
|                      PREVMARGIN  : INTEGER
|                   END;
| 
|      SYMBOLSTACK = ARRAY [ 1..MAXSTACKSIZE ] OF STACKENTRY;
| 
| 
| VAR
| 
|     INPUTFL  ,
|     OUTPUTFL  : TEXT;
| 
|     RECORDSEEN: BOOLEAN;
| 
|     CURRCHAR,
|     NEXTCHAR: CHARINFO;
| 
|     CURRSYM,
|     NEXTSYM: SYMBOLINFO;
| 
|     CRPENDING: BOOLEAN;
| 
|     PPOPTION: OPTIONTABLE;
| 
|     KEYWORD: KEYWORDTABLE;
| 
|     DBLCHARS: DBLCHRSET;
| 
|     DBLCHAR: DBLCHARTABLE;
|     SGLCHAR: SGLCHARTABLE;
| 
|     STACK: SYMBOLSTACK;
|     TOP  : INTEGER;
| 
|     CURRLINEPOS,
|     CURRMARGIN :  INTEGER;
| 
| 
| PROCEDURE GETCHAR( (* FROM *)      VAR INPUTFL   : TEXT;
|                    (* UPDATING *)  VAR NEXTCHAR  : CHARINFO;
|                    (* RETURNING *) VAR CURRCHAR  : CHARINFO );
| 
|    FUNCTION ATOZ(C: CHAR): BOOLEAN;
| 
|      BEGIN
|      ATOZ := (('A' <= C) AND (C <= 'Z')) OR
|              (('a' <= C) AND (C <= 'i')) OR
|              (('j' <= C) AND (C <= 'r')) OR
|              (('s' <= C) AND (C <= 'z')) ;
|      END ;
| 
| 
| BEGIN (* GETCHAR *)
| 
|    CURRCHAR := NEXTCHAR;
| 
|    WITH NEXTCHAR DO
|       BEGIN
| 
|          IF EOF(INPUTFL)
|             THEN
|                NAME  := FILEMARK
| 
|     ELSE IF EOLN(INPUTFL)
|             THEN
|                NAME  := ENDOFLINE
| 
|     ELSE IF ATOZ(INPUTFL@) """INPUTFL@ IN ['A'..'Z']"""
|             THEN
|                NAME  := LETTER
| 
|     """ELSE  IF NPUTFL@ IN ['0'..'9']"""
|     ELSE IF (INPUTFL@ >= '0')AND(INPUTFL@ <= '9')
|             THEN
|                NAME  := DIGIT
| 
|     ELSE IF INPUTFL  @ = ''''
|             THEN
|                NAME  := QUOTE
| 
|     ELSE IF INPUTFL  @ = SPACE
|             THEN
|                NAME  := BLANK
| 
|     ELSE NAME := OTHERCHAR;
| 
| 
|          IF NAME IN [ FILEMARK, ENDOFLINE ]
|             THEN
|                VALUE := SPACE
|             ELSE
|                VALUE := INPUTFL  @;
| 
|          IF NAME <> FILEMARK
|             THEN
|                GET(INPUTFL  )
| 
|       END (* WITH *)
| 
| END; (* GETCHAR *)
| 
| 
| PROCEDURE STORENEXTCHAR( (* FROM *)        VAR INPUTFL   : TEXT;
|                          (* UPDATING *)    VAR LENGTH    : INTEGER;
|                                            VAR CURRCHAR,
|                                                NEXTCHAR  : CHARINFO;
|                          (* PLACING IN *)  VAR VALUE     : STRING   );
| 
| BEGIN (* STORENEXTCHAR *)
| 
|    GETCHAR( (* FROM *)      INPUTFL  ,
|             (* UPDATING *)  NEXTCHAR,
|             (* RETURNING *) CURRCHAR  );
| 
|    IF LENGTH < MAXSYMBOLSIZE
|       THEN
|          BEGIN
| 
|             LENGTH := LENGTH + 1;
| 
|             VALUE [LENGTH] := CURRCHAR.VALUE
| 
|          END
| 
| END; (* STORENEXTCHAR *)
| 
| 
| PROCEDURE SKIPSPACES( (* IN *)        VAR INPUTFL      : TEXT;
|                       (* UPDATING *)  VAR CURRCHAR,
|                                           NEXTCHAR     : CHARINFO;
|                       (* RETURNING *) VAR SPACESBEFORE,
|                                           CRSBEFORE    : INTEGER  );
| 
| BEGIN (* SKIPSPACES *)
| 
|    SPACESBEFORE := 0;
|    CRSBEFORE    := 0;
| 
|    WHILE NEXTCHAR.NAME IN [ BLANK, ENDOFLINE ] DO
|       BEGIN
| 
|          GETCHAR( (* FROM *)      INPUTFL  ,
|                   (* UPDATING *)  NEXTCHAR,
|                   (* RETURNING *) CURRCHAR  );
| 
|          CASE CURRCHAR.NAME OF
| 
|             BLANK     : SPACESBEFORE := SPACESBEFORE + 1;
| 
|             ENDOFLINE : BEGIN
|                            CRSBEFORE    := CRSBEFORE + 1;
|                            SPACESBEFORE := 0
|                         END
| 
|          END (* CASE *)
| 
|       END (* WHILE *)
| 
| END; (* SKIPSPACES *)
| 
| 
| PROCEDURE GETCOMMENT( (* FROM *)     VAR INPUTFL   : TEXT;
|                       (* UPDATING *) VAR CURRCHAR,
|                                          NEXTCHAR  : CHARINFO;
|                                      VAR NAME      : KEYSYMBOL;
|                                      VAR VALUE     : STRING;
|                                      VAR LENGTH    : INTEGER   );
| 
| BEGIN (* GETCOMMENT *)
| 
|    NAME := OPENCOMMENT;
| 
|    WHILE NOT(    ((CURRCHAR.VALUE = '*') AND (NEXTCHAR.VALUE = ')'))
|               OR (NEXTCHAR.NAME = ENDOFLINE)
|               OR (NEXTCHAR.NAME = FILEMARK)) DO
| 
|       STORENEXTCHAR( (* FROM *)     INPUTFL  ,
|                      (* UPDATING *) LENGTH,
|                                     CURRCHAR,
|                                     NEXTCHAR,
|                      (* IN *)       VALUE     );
| 
| 
|    IF (CURRCHAR.VALUE = '*') AND (NEXTCHAR.VALUE = ')')
|       THEN
|          BEGIN
| 
|             STORENEXTCHAR( (* FROM *)     INPUTFL  ,
|                            (* UPDATING *) LENGTH,
|                                           CURRCHAR,
|                                           NEXTCHAR,
|                            (* IN *)       VALUE     );
| 
|             NAME := CLOSECOMMENT
| 
|          END
| 
| END; (* GETCOMMENT *)
| 
| 
| FUNCTION IDTYPE( (* OF *)        VALUE  : STRING;
|                  (* USING *)     LENGTH : INTEGER )
|                  (* RETURNING *)                   : KEYSYMBOL;
| 
| VAR
|     I: INTEGER;
| 
|     KEYVALUE: KEY;
| 
|     HIT: BOOLEAN;
| 
|     THISKEY: KEYSYMBOL;
| 
| 
| BEGIN (* IDTYPE *)
| 
|    IDTYPE := OTHERSYM;
| 
|    IF LENGTH <= MAXKEYLENGTH
|       THEN
|          BEGIN
| 
|             FOR I := 1 TO LENGTH DO
|                KEYVALUE [I] := VALUE [I];
| 
|             FOR I := LENGTH+1 TO MAXKEYLENGTH DO
|                KEYVALUE [I] := SPACE;
| 
|             THISKEY := PROGSYM;
|             HIT     := FALSE;
| 
|             WHILE NOT(HIT OR (PRED(THISKEY) = UNTILSYM)) DO
|                IF KEYVALUE = KEYWORD [THISKEY]
|                   THEN
|                      HIT := TRUE
|                   ELSE
|                      THISKEY := SUCC(THISKEY);
| 
|             IF HIT
|                THEN
|                   IDTYPE := THISKEY
| 
|          END;
| 
| END; (* IDTYPE *)
| 
| 
| PROCEDURE GETIDENTIFIER( (* FROM *)      VAR INPUTFL   : TEXT;
|                          (* UPDATING *)  VAR CURRCHAR,
|                                              NEXTCHAR  : CHARINFO;
|                          (* RETURNING *) VAR NAME      : KEYSYMBOL;
|                                          VAR VALUE     : STRING;
|                                          VAR LENGTH    : INTEGER   );
| 
| BEGIN (* GETIDENTIFIER *)
| 
|    WHILE NEXTCHAR.NAME IN [ LETTER, DIGIT ] DO
| 
|       STORENEXTCHAR( (* FROM *)     INPUTFL  ,
|                      (* UPDATING *) LENGTH,
|                                     CURRCHAR,
|                                     NEXTCHAR,
|                      (* IN *)       VALUE     );
| 
| 
|    NAME := IDTYPE( (* OF *)    VALUE,
|                    (* USING *) LENGTH );
| 
|    IF NAME IN [ RECORDSYM, CASESYM, ENDSYM ]
|       THEN
|          CASE NAME OF
| 
|             RECORDSYM : RECORDSEEN := TRUE;
| 
|             CASESYM   : IF RECORDSEEN
|                            THEN
|                               NAME := CASEVARSYM;
| 
|             ENDSYM    : RECORDSEEN := FALSE
| 
|          END (* CASE *)
| 
| END; (* GETIDENTIFIER *)
| 
| 
| PROCEDURE GETNUMBER( (* FROM *)      VAR INPUTFL   : TEXT;
|                      (* UPDATING *)  VAR CURRCHAR,
|                                          NEXTCHAR  : CHARINFO;
|                      (* RETURNING *) VAR NAME      : KEYSYMBOL;
|                                      VAR VALUE     : STRING;
|                                      VAR LENGTH    : INTEGER   );
| 
| BEGIN (* GETNUMBER *)
| 
|    WHILE NEXTCHAR.NAME = DIGIT DO
| 
|       STORENEXTCHAR( (* FROM *)     INPUTFL  ,
|                      (* UPDATING *) LENGTH,
|                                     CURRCHAR,
|                                     NEXTCHAR,
|                      (* IN *)       VALUE     );
| 
| 
|    NAME := OTHERSYM
| 
| END; (* GETNUMBER *)
| 
| 
| PROCEDURE GETCHARLITERAL( (* FROM *)      VAR INPUTFL   : TEXT;
|                           (* UPDATING *)  VAR CURRCHAR,
|                                               NEXTCHAR  : CHARINFO;
|                           (* RETURNING *) VAR NAME      : KEYSYMBOL;
|                                           VAR VALUE     : STRING;
|                                           VAR LENGTH    : INTEGER   );
| 
| BEGIN (* GETCHARLITERAL *)
| 
|    WHILE NEXTCHAR.NAME = QUOTE DO
|       BEGIN
| 
|          STORENEXTCHAR( (* FROM *)     INPUTFL  ,
|                         (* UPDATING *) LENGTH,
|                                        CURRCHAR,
|                                        NEXTCHAR,
|                         (* IN *)       VALUE     );
| 
|          WHILE NOT(NEXTCHAR.NAME IN [ QUOTE, ENDOFLINE, FILEMARK ]) DO
| 
|             STORENEXTCHAR( (* FROM *)     INPUTFL  ,
|                            (* UPDATING *) LENGTH,
|                                           CURRCHAR,
|                                           NEXTCHAR,
|                            (* IN *)       VALUE     );
| 
| 
|          IF NEXTCHAR.NAME = QUOTE
|             THEN
|                STORENEXTCHAR( (* FROM *)     INPUTFL  ,
|                               (* UPDATING *) LENGTH,
|                                              CURRCHAR,
|                                              NEXTCHAR,
|                               (* IN *)       VALUE     )
| 
|       END;
| 
| 
|    NAME := OTHERSYM
| 
| END; (* GETCHARLITERAL *)
| 
| 
| FUNCTION CHARTYPE( (* OF *)        CURRCHAR,
|                                    NEXTCHAR : CHARINFO )
|                    (* RETURNING *)                      : KEYSYMBOL;
| 
| VAR
|     NEXTTWOCHARS: SPECIALCHAR;
| 
|     HIT: BOOLEAN;
| 
|     THISCHAR: KEYSYMBOL;
| 
| 
| BEGIN (* CHARTYPE *)
| 
|    NEXTTWOCHARS[1] := CURRCHAR.VALUE;
|    NEXTTWOCHARS[2] := NEXTCHAR.VALUE;
| 
|    THISCHAR := BECOMES;
|    HIT      := FALSE;
| 
|    WHILE NOT(HIT OR (THISCHAR = CLOSECOMMENT)) DO
|       IF NEXTTWOCHARS = DBLCHAR [THISCHAR]
|          THEN
|             HIT := TRUE
|          ELSE
|             THISCHAR := SUCC(THISCHAR);
| 
|    IF NOT HIT
|       THEN
|          BEGIN
| 
|             THISCHAR := SEMICOLON;
| 
|             WHILE NOT(HIT OR (PRED(THISCHAR) = PERIOD)) DO
|                IF CURRCHAR.VALUE = SGLCHAR [THISCHAR]
|                   THEN
|                      HIT := TRUE
|                   ELSE
|                      THISCHAR := SUCC(THISCHAR)
| 
|          END;
| 
|    IF HIT
|       THEN
|          CHARTYPE := THISCHAR
|       ELSE
|          CHARTYPE := OTHERSYM
| 
| END; (* CHARTYPE *)
| 
| 
| PROCEDURE GETSPECIALCHAR( (* FROM *)      VAR INPUTFL   : TEXT;
|                           (* UPDATING *)  VAR CURRCHAR,
|                                               NEXTCHAR  : CHARINFO;
|                           (* RETURNING *) VAR NAME      : KEYSYMBOL;
|                                           VAR VALUE     : STRING;
|                                           VAR LENGTH    : INTEGER   );
| 
| BEGIN (* GETSPECIALCHAR *)
| 
|    STORENEXTCHAR( (* FROM *)     INPUTFL  ,
|                   (* UPDATING *) LENGTH,
|                                  CURRCHAR,
|                                  NEXTCHAR,
|                   (* IN *)       VALUE     );
| 
|    NAME := CHARTYPE( (* OF *) CURRCHAR,
|                               NEXTCHAR );
| 
|    IF NAME IN DBLCHARS
|       THEN
| 
|          STORENEXTCHAR( (* FROM *)     INPUTFL  ,
|                         (* UPDATING *) LENGTH,
|                                        CURRCHAR,
|                                        NEXTCHAR,
|                         (* IN *)       VALUE     )
| 
| END; (* GETSPECIALCHAR *)
| 
| 
| PROCEDURE GETNEXTSYMBOL( (* FROM *)      VAR INPUTFL   : TEXT;
|                          (* UPDATING *)  VAR CURRCHAR,
|                                              NEXTCHAR  : CHARINFO;
|                          (* RETURNING *) VAR NAME      : KEYSYMBOL;
|                                          VAR VALUE     : STRING;
|                                          VAR LENGTH    : INTEGER   );
| 
| BEGIN (* GETNEXTSYMBOL *)
| 
|    CASE NEXTCHAR.NAME OF
| 
|       LETTER      : GETIDENTIFIER( (* FROM *)      INPUTFL  ,
|                                    (* UPDATING *)  CURRCHAR,
|                                                    NEXTCHAR,
|                                    (* RETURNING *) NAME,
|                                                    VALUE,
|                                                    LENGTH    );
| 
|       DIGIT       : GETNUMBER( (* FROM *)      INPUTFL  ,
|                                (* UPDATING *)  CURRCHAR,
|                                                NEXTCHAR,
|                                (* RETURNING *) NAME,
|                                                VALUE,
|                                                LENGTH    );
| 
|       QUOTE       : GETCHARLITERAL( (* FROM *)      INPUTFL  ,
|                                     (* UPDATING *)  CURRCHAR,
|                                                     NEXTCHAR,
|                                     (* RETURNING *) NAME,
|                                                     VALUE,
|                                                     LENGTH    );
| 
|       OTHERCHAR   : BEGIN
| 
|                        GETSPECIALCHAR( (* FROM *)      INPUTFL  ,
|                                        (* UPDATING *)  CURRCHAR,
|                                                        NEXTCHAR,
|                                        (* RETURNING *) NAME,
|                                                        VALUE,
|                                                        LENGTH    );
| 
|                        IF NAME = OPENCOMMENT
|                           THEN
|                              GETCOMMENT( (* FROM *)     INPUTFL  ,
|                                          (* UPDATING *) CURRCHAR,
|                                                         NEXTCHAR,
|                                                         NAME,
|                                                         VALUE,
|                                                         LENGTH    )
| 
|                     END;
| 
|       FILEMARK    : NAME := ENDOFFILE
| 
|    END (* CASE *)
| 
| END; (* GETNEXTSYMBOL *)
| 
| 
| PROCEDURE GETSYMBOL( (* FROM *)      VAR INPUTFL   : TEXT;
|                      (* UPDATING *)  VAR NEXTSYM   : SYMBOLINFO;
|                      (* RETURNING *) VAR CURRSYM   : SYMBOLINFO );
| 
| VAR
|     DUMMY: SYMBOLINFO;
| 
| 
| BEGIN (* GETSYMBOL *)
| 
|    DUMMY   := CURRSYM;
|    CURRSYM := NEXTSYM;
|    NEXTSYM := DUMMY  ;
| 
|    WITH NEXTSYM@ DO
|       BEGIN
| 
|          SKIPSPACES( (* IN *)        INPUTFL  ,
|                      (* UPDATING *)  CURRCHAR,
|                                      NEXTCHAR,
|                      (* RETURNING *) SPACESBEFORE,
|                                      CRSBEFORE     );
|          LENGTH := 0;
| 
|          IF CURRSYM@.NAME = OPENCOMMENT
|             THEN
|                GETCOMMENT( (* FROM *)      INPUTFL  ,
|                            (* UPDATING *)  CURRCHAR,
|                                            NEXTCHAR,
|                            (* RETURNING *) NAME,
|                                            VALUE,
|                                            LENGTH    )
|             ELSE
|                GETNEXTSYMBOL( (* FROM *)      INPUTFL  ,
|                               (* UPDATING *)  CURRCHAR,
|                                               NEXTCHAR,
|                               (* RETURNING *) NAME,
|                                               VALUE,
|                                               LENGTH    )
| 
|       END (* WITH *)
| 
| END; (* GETSYMBOL *)
| 
| 
| PROCEDURE INITIALIZE( (* RETURNING *)
| 
|                           VAR INPUTFL  ,
|                               OUTPUTFL    : TEXT;
| 
|                           VAR TOPOFSTACK  : INTEGER;
| 
|                           VAR CURRLINEPOS,
|                               CURRMARGIN  : INTEGER;
| 
|                           VAR KEYWORD     : KEYWORDTABLE;
| 
|                           VAR DBLCHARS    : DBLCHRSET;
| 
|                           VAR DBLCHAR     : DBLCHARTABLE;
| 
|                           VAR SGLCHAR     : SGLCHARTABLE;
| 
|                           VAR RECORDSEEN  : BOOLEAN;
| 
|                           VAR CURRCHAR,
|                               NEXTCHAR    : CHARINFO;
| 
|                           VAR CURRSYM,
|                               NEXTSYM     : SYMBOLINFO;
| 
|                           VAR PPOPTION    : OPTIONTABLE   );
| 
| 
| BEGIN (* INITIALIZE *)
| 
|    RESET(INPUTFL  );
|    REWRITE(OUTPUTFL  );
|    WRITELN(OUTPUTFL  , ' <<<< PRETTY_PRINT OUTPUT OF THE PROGRAM >>>>');
|    WRITELN(OUTPUTFL  , ' --------------------------------------------');
|    WRITELN(OUTPUTFL  );
|    WRITE(OUTPUTFL  , ' ');
| 
|    TOPOFSTACK  := 0;
|    CURRLINEPOS := 0;
|    CURRMARGIN  := 0;
| 
| 
|    KEYWORD [ PROGSYM    ] := 'PROGRAM   ' ;
|    KEYWORD [ FUNCSYM    ] := 'FUNCTION  ' ;
|    KEYWORD [ PROCSYM    ] := 'PROCEDURE ' ;
|    KEYWORD [ LABELSYM   ] := 'LABEL     ' ;
|    KEYWORD [ CONSTSYM   ] := 'CONST     ' ;
|    KEYWORD [ TYPESYM    ] := 'TYPE      ' ;
|    KEYWORD [ VARSYM     ] := 'VAR       ' ;
|    KEYWORD [ BEGINSYM   ] := 'BEGIN     ' ;
|    KEYWORD [ REPEATSYM  ] := 'REPEAT    ' ;
|    KEYWORD [ RECORDSYM  ] := 'RECORD    ' ;
|    KEYWORD [ CASESYM    ] := 'CASE      ' ;
|    KEYWORD [ CASEVARSYM ] := 'CASE      ' ;
|    KEYWORD [ OFSYM      ] := 'OF        ' ;
|    KEYWORD [ FORSYM     ] := 'FOR       ' ;
|    KEYWORD [ WHILESYM   ] := 'WHILE     ' ;
|    KEYWORD [ WITHSYM    ] := 'WITH      ' ;
|    KEYWORD [ DOSYM      ] := 'DO        ' ;
|    KEYWORD [ IFSYM      ] := 'IF        ' ;
|    KEYWORD [ THENSYM    ] := 'THEN      ' ;
|    KEYWORD [ ELSESYM    ] := 'ELSE      ' ;
|    KEYWORD [ ENDSYM     ] := 'END       ' ;
|    KEYWORD [ UNTILSYM   ] := 'UNTIL     ' ;
| 
| 
|    DBLCHARS := [ BECOMES, OPENCOMMENT ];
| 
|    DBLCHAR [ BECOMES     ]  := ':=' ;
|    DBLCHAR [ OPENCOMMENT ]  := '(*' ;
| 
|    SGLCHAR [ SEMICOLON  ]   := ';' ;
|    SGLCHAR [ COLON      ]   := ':' ;
|    SGLCHAR [ EQUALS     ]   := '=' ;
|    SGLCHAR [ OPENPAREN  ]   := '(' ;
|    SGLCHAR [ CLOSEPAREN ]   := ')' ;
|    SGLCHAR [ PERIOD     ]   := '.' ;
| 
|    RECORDSEEN := FALSE;
| 
| 
|    GETCHAR( (* FROM *)      INPUTFL  ,
|             (* UPDATING *)  NEXTCHAR,
|             (* RETURNING *) CURRCHAR  );
| 
|    NEW(CURRSYM);
|    NEW(NEXTSYM);
| 
|    GETSYMBOL( (* FROM *)      INPUTFL  ,
|               (* UPDATING *)  NEXTSYM,
|               (* RETURNING *) CURRSYM  );
| 
| 
|    WITH PPOPTION [ PROGSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
|                                 SPACEAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ FUNCSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
|                                 DINDENTONKEYS,
|                                 SPACEAFTER ];
|          DINDENTSYMBOLS    := [ LABELSYM,
|                                 CONSTSYM,
|                                 TYPESYM,
|                                 VARSYM ];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ PROCSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
|                                 DINDENTONKEYS,
|                                 SPACEAFTER ];
|          DINDENTSYMBOLS    := [ LABELSYM,
|                                 CONSTSYM,
|                                 TYPESYM,
|                                 VARSYM ];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ LABELSYM ] DO
|       BEGIN
|           OPTIONSSELECTED   := [ BLANKLINEBEFORE,
|                                 SPACEAFTER,
|                                 INDENTTOCLP ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ CONSTSYM ] DO
|       BEGIN
|           OPTIONSSELECTED   := [ BLANKLINEBEFORE,
|                                 DINDENTONKEYS,
|                                 SPACEAFTER,
|                                 INDENTTOCLP ];
|          DINDENTSYMBOLS    := [ LABELSYM ];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ TYPESYM ] DO
|       BEGIN
|           OPTIONSSELECTED   := [ BLANKLINEBEFORE,
|                                 DINDENTONKEYS,
|                                 SPACEAFTER,
|                                 INDENTTOCLP ];
|          DINDENTSYMBOLS    := [ LABELSYM,
|                                 CONSTSYM ];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ VARSYM ] DO
|       BEGIN
|           OPTIONSSELECTED   := [ BLANKLINEBEFORE,
|                                 DINDENTONKEYS,
|                                 SPACEAFTER,
|                                 INDENTTOCLP ];
|          DINDENTSYMBOLS    := [ LABELSYM,
|                                 CONSTSYM,
|                                 TYPESYM ];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ BEGINSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ DINDENTONKEYS,
|                                 INDENTBYTAB,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [ LABELSYM,
|                                 CONSTSYM,
|                                 TYPESYM,
|                                 VARSYM ];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ REPEATSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ INDENTBYTAB,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ RECORDSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ INDENTBYTAB,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ CASESYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ SPACEAFTER,
|                                 INDENTBYTAB,
|                                 GOBBLESYMBOLS,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := [ OFSYM ]
|       END;
| 
|    WITH PPOPTION [ CASEVARSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ SPACEAFTER,
|                                 INDENTBYTAB,
|                                 GOBBLESYMBOLS,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := [ OFSYM ]
|       END;
| 
|    WITH PPOPTION [ OFSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ CRSUPPRESS,
|                                 SPACEBEFORE ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ FORSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ SPACEAFTER,
|                                 INDENTBYTAB,
|                                 GOBBLESYMBOLS,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := [ DOSYM ]
|       END;
| 
|    WITH PPOPTION [ WHILESYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ SPACEAFTER,
|                                 INDENTBYTAB,
|                                 GOBBLESYMBOLS,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := [ DOSYM ]
|       END;
| 
|    WITH PPOPTION [ WITHSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ SPACEAFTER,
|                                 INDENTBYTAB,
|                                 GOBBLESYMBOLS,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := [ DOSYM ]
|       END;
| 
|    WITH PPOPTION [ DOSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ CRSUPPRESS,
|                                 SPACEBEFORE ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ IFSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ SPACEAFTER,
|                                 INDENTBYTAB,
|                                 GOBBLESYMBOLS,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := [ THENSYM ]
|       END;
| 
|    WITH PPOPTION [ THENSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ INDENTBYTAB,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ ELSESYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ CRBEFORE,
|                                 DINDENTONKEYS,
|                                 DINDENT,
|                                 INDENTBYTAB,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [ IFSYM,
|                                 ELSESYM ];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ ENDSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ CRBEFORE,
|                                 DINDENTONKEYS,
|                                 DINDENT,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [ IFSYM,
|                                 THENSYM,
|                                 ELSESYM,
|                                 FORSYM,
|                                 WHILESYM,
|                                 WITHSYM,
|                                 CASEVARSYM,
|                                 COLON,
|                                 EQUALS ];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ UNTILSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ CRBEFORE,
|                                 DINDENTONKEYS,
|                                 DINDENT,
|                                 SPACEAFTER,
|                                 GOBBLESYMBOLS,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [ IFSYM,
|                                 THENSYM,
|                                 ELSESYM,
|                                 FORSYM,
|                                 WHILESYM,
|                                 WITHSYM,
|                                 COLON,
|                                 EQUALS ];
|          GOBBLETERMINATORS := [ ENDSYM,
|                                 UNTILSYM,
|                                 ELSESYM,
|                                 SEMICOLON ];
|       END;
| 
|    WITH PPOPTION [ BECOMES ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ SPACEBEFORE,
|                                 SPACEAFTER,
|                                 GOBBLESYMBOLS ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := [ ENDSYM,
|                                 UNTILSYM,
|                                 ELSESYM,
|                                 SEMICOLON ]
|       END;
| 
|    WITH PPOPTION [ OPENCOMMENT ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ CRSUPPRESS ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ CLOSECOMMENT ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ CRSUPPRESS ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ SEMICOLON ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ CRSUPPRESS,
|                                 DINDENTONKEYS,
|                                 CRAFTER ];
|          DINDENTSYMBOLS    := [ IFSYM,
|                                 THENSYM,
|                                 ELSESYM,
|                                 FORSYM,
|                                 WHILESYM,
|                                 WITHSYM,
|                                 COLON,
|                                 EQUALS ];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ COLON ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ SPACEAFTER,
|                                 INDENTTOCLP ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ EQUALS ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ SPACEBEFORE,
|                                 SPACEAFTER,
|                                 INDENTTOCLP ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ OPENPAREN ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ GOBBLESYMBOLS ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := [ CLOSEPAREN ]
|       END;
| 
|    WITH PPOPTION [ CLOSEPAREN ] DO
|       BEGIN
|          OPTIONSSELECTED   := [];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ PERIOD ] DO
|       BEGIN
|          OPTIONSSELECTED   := [ CRSUPPRESS ];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ ENDOFFILE ] DO
|       BEGIN
|          OPTIONSSELECTED   := [];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END;
| 
|    WITH PPOPTION [ OTHERSYM ] DO
|       BEGIN
|          OPTIONSSELECTED   := [];
|          DINDENTSYMBOLS    := [];
|          GOBBLETERMINATORS := []
|       END
| 
| 
| END; (* INITIALIZE *)
| 
| 
| FUNCTION STACKEMPTY (* RETURNING *) : BOOLEAN;
| 
| BEGIN (* STACKEMPTY *)
| 
|    IF TOP = 0
|       THEN
|          STACKEMPTY := TRUE
|       ELSE
|          STACKEMPTY := FALSE
| 
| END; (* STACKEMPTY *)
| 
| 
| FUNCTION STACKFULL (* RETURNING *) : BOOLEAN;
| 
| BEGIN (* STACKFULL *)
| 
|    IF TOP = MAXSTACKSIZE
|       THEN
|          STACKFULL := TRUE
|       ELSE
|          STACKFULL := FALSE
| 
| END; (* STACKFULL *)
| 
| 
| PROCEDURE POPSTACK( (* RETURNING *) VAR INDENTSYMBOL : KEYSYMBOL;
|                                     VAR PREVMARGIN   : INTEGER   );
| 
| BEGIN (* POPSTACK *)
| 
|    IF NOT STACKEMPTY
|       THEN
|          BEGIN
| 
|             INDENTSYMBOL := STACK[TOP].INDENTSYMBOL;
|             PREVMARGIN   := STACK[TOP].PREVMARGIN;
| 
|             TOP := TOP - 1
| 
|          END
| 
|       ELSE
|          BEGIN
|             INDENTSYMBOL := OTHERSYM;
|             PREVMARGIN   := 0
|          END
| 
| END; (* POPSTACK *)
| 
| 
| PROCEDURE PUSHSTACK( (* USING *) INDENTSYMBOL : KEYSYMBOL;
|                                  PREVMARGIN   : INTEGER   );
| 
| BEGIN (* PUSHSTACK *)
| 
|    TOP := TOP + 1;
| 
|    STACK[TOP].INDENTSYMBOL := INDENTSYMBOL;
|    STACK[TOP].PREVMARGIN   := PREVMARGIN
| 
| END; (* PUSHSTACK *)
| 
| 
| PROCEDURE WRITECRS( (* USING *)          NUMBEROFCRS : INTEGER;
|                     (* UPDATING *)   VAR CURRLINEPOS : INTEGER;
|                     (* WRITING TO *) VAR OUTPUTFL    : TEXT    );
| 
| VAR
|     I: INTEGER;
| 
| 
| BEGIN (* WRITECRS *)
| 
|    IF NUMBEROFCRS > 0
|       THEN
|          BEGIN
| 
|             FOR I := 1 TO NUMBEROFCRS DO
|                WRITELN(OUTPUTFL  );
| 
|             WRITE(OUTPUTFL, ' ');
|             CURRLINEPOS := 0
| 
|          END
| 
| END; (* WRITECRS *)
| 
| 
| PROCEDURE INSERTCR( (* UPDATING *)   VAR CURRSYM    : SYMBOLINFO;
|                     (* WRITING TO *) VAR OUTPUTFL   : TEXT       );
| 
| CONST
|       ONCE = 1;
| 
| 
| BEGIN (* INSERTCR *)
| 
|    IF CURRSYM@.CRSBEFORE = 0
|       THEN
|          BEGIN
| 
|             WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
|                             (* WRITING TO *) OUTPUTFL    );
| 
|             CURRSYM@.SPACESBEFORE := 0
| 
|          END
| 
| END; (* INSERTCR *)
| 
| 
| PROCEDURE INSERTBLANKLINE( (* UPDATING *)   VAR CURRSYM : SYMBOLINFO;
|                            (* WRITING TO *) VAR OUTPUTFL   : TEXT  );
| 
| CONST
|       ONCE  = 1;
|       TWICE = 2;
| 
| 
| BEGIN (* INSERTBLANKLINE *)
| 
|    IF CURRSYM@.CRSBEFORE = 0
|       THEN
|          BEGIN
| 
|             IF CURRLINEPOS = 0
|                THEN
|                   WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
|                                   (* WRITING TO *) OUTPUTFL    )
|                ELSE
|                   WRITECRS( TWICE, (* UPDATING *)   CURRLINEPOS,
|                                    (* WRITING TO *) OUTPUTFL    );
| 
|             CURRSYM@.SPACESBEFORE := 0
| 
|          END
| 
|       ELSE
|          IF CURRSYM@.CRSBEFORE = 1
|             THEN
|                IF CURRLINEPOS > 0
|                   THEN
|                      WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
|                                      (* WRITING TO *) OUTPUTFL    )
| 
| END; (* INSERTBLANKLINE *)
| 
| 
| PROCEDURE LSHIFTON( (* USING *) DINDENTSYMBOLS : KEYSYMSET );
| 
| VAR
|     INDENTSYMBOL: KEYSYMBOL;
|     PREVMARGIN  : INTEGER;
| 
| 
| BEGIN (* LSHIFTON *)
| 
|    IF NOT STACKEMPTY
|       THEN
|          BEGIN
| 
|             REPEAT
| 
|                POPSTACK( (* RETURNING *) INDENTSYMBOL,
|                                          PREVMARGIN   );
| 
|                IF INDENTSYMBOL IN DINDENTSYMBOLS
|                   THEN
|                      CURRMARGIN := PREVMARGIN
| 
|             UNTIL NOT(INDENTSYMBOL IN DINDENTSYMBOLS)
|                    OR (STACKEMPTY);
| 
|             IF NOT(INDENTSYMBOL IN DINDENTSYMBOLS)
|                THEN
|                   PUSHSTACK( (* USING *) INDENTSYMBOL,
|                                          PREVMARGIN   )
| 
|          END
| 
| END; (* LSHIFTON *)
| 
| 
| PROCEDURE LSHIFT;
| 
| VAR
|     INDENTSYMBOL: KEYSYMBOL;
|     PREVMARGIN  : INTEGER;
| 
| 
| BEGIN (* LSHIFT *)
| 
|    IF NOT STACKEMPTY
|       THEN
|          BEGIN
|             POPSTACK( (* RETURNING *) INDENTSYMBOL,
|                                       PREVMARGIN   );
|             CURRMARGIN := PREVMARGIN
|          END
| 
| END; (* LSHIFT *)
| 
| 
| PROCEDURE INSERTSPACE( (* USING *)      VAR SYMBOL     : SYMBOLINFO;
|                        (* WRITING TO *) VAR OUTPUTFL   : TEXT       );
| 
| BEGIN (* INSERTSPACE *)
| 
|    IF CURRLINEPOS < MAXLINESIZE
|       THEN
|          BEGIN
| 
|             WRITE(OUTPUTFL  , SPACE);
| 
|             CURRLINEPOS := CURRLINEPOS + 1;
| 
|             WITH SYMBOL@ DO
|                IF (CRSBEFORE = 0) AND (SPACESBEFORE > 0)
|                   THEN
|                      SPACESBEFORE := SPACESBEFORE - 1
| 
|          END
| 
| END; (* INSERTSPACE *)
| 
| 
| PROCEDURE MOVELINEPOS( (* TO *)       NEWLINEPOS  : INTEGER;
|                        (* FROM *) VAR CURRLINEPOS : INTEGER;
|                        (* IN *)   VAR OUTPUTFL    : TEXT    );
| 
| VAR
|    I: INTEGER;
| 
| 
| BEGIN (* MOVELINEPOS *)
| 
|    FOR I := CURRLINEPOS+1 TO NEWLINEPOS DO
|       WRITE(OUTPUTFL  , SPACE);
| 
|    CURRLINEPOS := NEWLINEPOS
| 
| END; (* MOVELINEPOS *)
| 
| 
| PROCEDURE PRINTSYMBOL( (* IN *)             CURRSYM     : SYMBOLINFO;
|                        (* UPDATING *)   VAR CURRLINEPOS : INTEGER;
|                        (* WRITING TO *) VAR OUTPUTFL    : TEXT       );
| 
| VAR
|    I: INTEGER;
| 
| 
| BEGIN (* PRINTSYMBOL *)
| 
|    WITH CURRSYM@ DO
|       BEGIN
| 
|          FOR I := 1 TO LENGTH DO
|             WRITE(OUTPUTFL  , VALUE[I]);
| 
|          CURRLINEPOS := CURRLINEPOS + LENGTH
| 
|       END (* WITH *)
| 
| END; (* PRINTSYMBOL *)
| 
| 
| PROCEDURE PPSYMBOL( (* IN *)             CURRSYM    : SYMBOLINFO;
|                     (* WRITING TO *) VAR OUTPUTFL   : TEXT       );
| 
| CONST
|       ONCE  = 1;
| 
| VAR
|     NEWLINEPOS: INTEGER;
| 
| 
| BEGIN (* PPSYMBOL *)
| 
|    WITH CURRSYM@ DO
|       BEGIN
| 
|          WRITECRS( (* USING *)      CRSBEFORE,
|                    (* UPDATING *)   CURRLINEPOS,
|                    (* WRITING TO *) OUTPUTFL    );
| 
|          IF (CURRLINEPOS + SPACESBEFORE > CURRMARGIN)
|             OR (NAME IN [ OPENCOMMENT, CLOSECOMMENT ])
|             THEN
|                NEWLINEPOS := CURRLINEPOS + SPACESBEFORE
|             ELSE
|                NEWLINEPOS := CURRMARGIN;
| 
|          IF NEWLINEPOS + LENGTH > MAXLINESIZE
|             THEN
|                BEGIN
| 
|                   WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
|                                   (* WRITING TO *) OUTPUTFL    );
| 
|                   IF CURRMARGIN + LENGTH <= MAXLINESIZE
|                      THEN
|                         NEWLINEPOS := CURRMARGIN
|                      ELSE
|                         IF LENGTH < MAXLINESIZE
|                            THEN
|                               NEWLINEPOS := MAXLINESIZE - LENGTH
|                            ELSE
|                               NEWLINEPOS := 0
| 
|                END;
| 
|          MOVELINEPOS( (* TO *)    NEWLINEPOS,
|                       (* FROM *)  CURRLINEPOS,
|                       (* IN *)    OUTPUTFL    );
| 
|          PRINTSYMBOL( (* IN *)         CURRSYM,
|                       (* UPDATING *)   CURRLINEPOS,
|                       (* WRITING TO *) OUTPUTFL    )
| 
|       END (* WITH *)
| 
| END; (* PPSYMBOL *)
| 
| 
| PROCEDURE RSHIFTTOCLP( (* USING *) CURRSYM : KEYSYMBOL );
|    FORWARD;
| 
| PROCEDURE GOBBLE( (* SYMBOLS FROM *) VAR INPUTFL     : TEXT;
|                   (* UP TO *)            TERMINATORS : KEYSYMSET;
|                   (* UPDATING *)     VAR CURRSYM,
|                                          NEXTSYM     : SYMBOLINFO;
|                   (* WRITING TO *)   VAR OUTPUTFL    : TEXT       );
| 
| BEGIN (* GOBBLE *)
| 
|    RSHIFTTOCLP( (* USING *) CURRSYM@.NAME );
| 
|    WHILE NOT(NEXTSYM@.NAME IN (TERMINATORS + [ENDOFFILE])) DO
|       BEGIN
| 
|          GETSYMBOL( (* FROM *)      INPUTFL  ,
|                     (* UPDATING *)  NEXTSYM,
|                     (* RETURNING *) CURRSYM   );
| 
|          PPSYMBOL( (* IN *)         CURRSYM,
|                    (* WRITING TO *) OUTPUTFL   )
| 
|       END; (* WHILE *)
| 
|    LSHIFT
| 
| END; (* GOBBLE *)
| 
| 
| PROCEDURE RSHIFT( (* USING *) CURRSYM : KEYSYMBOL );
| 
| BEGIN (* RSHIFT *)
| 
|    IF NOT STACKFULL
|       THEN
|          PUSHSTACK( (* USING *) CURRSYM,
|                                 CURRMARGIN);
| 
|    IF CURRMARGIN < SLOWFAIL1
|       THEN
|          CURRMARGIN := CURRMARGIN + INDENT1
|       ELSE
|          IF CURRMARGIN < SLOWFAIL2
|             THEN
|                CURRMARGIN := CURRMARGIN + INDENT2
| 
| END; (* RSHIFT *)
| 
| 
| PROCEDURE RSHIFTTOCLP;
| 
| BEGIN (* RSHIFTTOCLP *)
| 
|    IF NOT STACKFULL
|       THEN
|          PUSHSTACK( (* USING *) CURRSYM,
|                                 CURRMARGIN);
| 
|    CURRMARGIN := CURRLINEPOS
| 
| END; (* RSHIFTTOCLP *)
| 
| 
| BEGIN (* PRETTYPRINT *)
| 
|    INITIALIZE( INPUTFL  ,  OUTPUTFL  , TOP,         CURRLINEPOS,
|                CURRMARGIN, KEYWORD,    DBLCHARS,    DBLCHAR,
|                SGLCHAR,    RECORDSEEN, CURRCHAR,    NEXTCHAR,
|                CURRSYM,    NEXTSYM,    PPOPTION );
| 
|    CRPENDING := FALSE;
| 
|    WHILE (NEXTSYM@.NAME <> ENDOFFILE) DO
|       BEGIN
| 
|          GETSYMBOL( (* FROM *)      INPUTFL  ,
|                     (* UPDATING *)  NEXTSYM,
|                     (* RETURNING *) CURRSYM   );
| 
|          WITH PPOPTION [CURRSYM@.NAME] DO
|             BEGIN
| 
|                IF (CRPENDING AND NOT(CRSUPPRESS IN OPTIONSSELECTED))
|                  OR (CRBEFORE IN OPTIONSSELECTED)
|                   THEN
|                      BEGIN
|                         INSERTCR( (* USING *)      CURRSYM,
|                                   (* WRITING TO *) OUTPUTFL   );
|                         CRPENDING := FALSE
|                      END;
| 
|                IF BLANKLINEBEFORE IN OPTIONSSELECTED
|                   THEN
|                      BEGIN
|                         INSERTBLANKLINE( (* USING *)      CURRSYM,
|                                          (* WRITING TO *) OUTPUTFL   );
|                         CRPENDING := FALSE
|                      END;
| 
|                IF DINDENTONKEYS IN OPTIONSSELECTED
|                   THEN
|                      LSHIFTON(DINDENTSYMBOLS);
| 
|                IF DINDENT IN OPTIONSSELECTED
|                   THEN
|                      LSHIFT;
| 
|                IF SPACEBEFORE IN OPTIONSSELECTED
|                   THEN
|                      INSERTSPACE( (* USING *)      CURRSYM,
|                                   (* WRITING TO *) OUTPUTFL   );
| 
|                PPSYMBOL( (* IN *)         CURRSYM,
|                          (* WRITING TO *) OUTPUTFL   );
| 
|                IF SPACEAFTER IN OPTIONSSELECTED
|                   THEN
|                      INSERTSPACE( (* USING *)      NEXTSYM,
|                                   (* WRITING TO *) OUTPUTFL   );
| 
|                IF INDENTBYTAB IN OPTIONSSELECTED
|                   THEN
|                      RSHIFT( (* USING *) CURRSYM@.NAME );
| 
|                IF INDENTTOCLP IN OPTIONSSELECTED
|                   THEN
|                      RSHIFTTOCLP( (* USING *) CURRSYM@.NAME );
| 
|                IF GOBBLESYMBOLS IN OPTIONSSELECTED
|                   THEN
|                      GOBBLE( (* SYMBOLS FROM *) INPUTFL  ,
|                              (* UP TO *)        GOBBLETERMINATORS,
|                              (* UPDATING *)     CURRSYM,
|                                                 NEXTSYM,
|                              (* WRITING TO *)   OUTPUTFL          );
| 
|                IF CRAFTER IN OPTIONSSELECTED
|                   THEN
|                      CRPENDING := TRUE
| 
|             END (* WITH *)
| 
|       END; (* WHILE *)
| 
|    IF CRPENDING
|       THEN
|          BEGIN  WRITELN(OUTPUTFL  );  WRITE(OUTPUTFL, ' ');  END;
| 
| END. (*PRETTYPRINT*)
| PROGRAM PASCREF(INPUT,OUTPUT);      (*$D- N.WIRTH  2.7.75*)
| (*CROSS REFERENCE GENERATOR FOR PASCAL PROGRAMS*)
| (*QUADRATIC QUOTIENT HASH METHOD*)
| (*MODIFIED SLIGHTLY BY A. MICKEL 75/12/08 AND D. LALIBERTE
|   78/03/15 TO PRODUCE PROCEDURE LIST AND SKIP COMPILER TITLE*)
| (*$T-,P-,R-,B4 TESTS OFF, PMD OFF, DYNAMIC STORAGE, BIG BUFFERS.*)
| LABEL 99;
| CONST P = 1499;     (*SIZE OF HASH TABLE*)
|   NK = 33;          (*NO. OF KEYWORDS*)
|   KLN = 10;         (*KEYLENGTH*)
|   LPPG = 62;        (*NO. OF LINES PER PAGE*)
|   LLMAX = 132;      (*LINE LENGTH DEFAULT MAX*)
|   LLMIN = 72;       (*LINE LENGTH MINIMUM*)
|   MAXN = 10000;     (*MAX NO. OF LINES*)
|   DGPN =  6;        (*NO. OF DIGITS PER NUMBER*)
|   LITL = 3;         (*NUMBER OF LINES IN COMPILER TITLE*)
|   ADDRWIDTH = 6;    (*NUMBER OF DIGITS IN CODE ADDRESS*)
|   EMPTY = '          ';
|   STARS = ' *****';
| TYPE INDEX = 0..P;
|   ALFA = PACKED ARRAY [1..KLN] OF CHAR;
|   REF = @ITEM;
|   WORD = RECORD KEY: ALFA;
|            FIRST: REF;
|          END ;
|   ITEM = PACKED RECORD
|            LNO: 0..MAXN;
|            NEXT: REF
|          END ;
|   PROCREF = @PROC;  (*PROCEDURE OR FUNCTION REFERENCE*)
|   PROC = PACKED RECORD
|            NAME: ALFA;
|            LNO: 0..MAXN;
|            NEXT: PROCREF
|          END ;
| VAR I: INDEX;
|   K: INTEGER;
|   M: INTEGER;       (*NO. OF LINES ON PAGE*)
|   N: INTEGER;       (*NO. OF LINES INPUT*)
|   LN: INTEGER;      (*CURRENT LINE NUMBER*)
|   LLNGOUT: INTEGER; (*LINE LENGTH FOR OUTPUT*)
|   LLNGIN: INTEGER;  (*LINE LENGTH FOR INPUT*)
|   CCOUNT: INTEGER;  (*CHARACTER COUNT IN LINE*)
|   NOPL: INTEGER;    (*NO. OF LINE-NUMBERS PER LINE*)
|   ID: RECORD CASE BOOLEAN OF
|              FALSE: (A: ALFA);
|              TRUE:  (ORD: INTEGER)
|       END ;
|   T: ARRAY [INDEX] OF WORD;    (*HASH TABLE*)
|   KEY: ARRAY [1..NK] OF ALFA;
|   PROCORFUNC,
|   COMPILERLISTING,
|   LINENUMBERS: BOOLEAN;
|   FIRSTPROC,
|   PROCPTR: PROCREF; (*POINTERS TO CHAIN OF PROCEDURES*)
| 
| 
|    FUNCTION LETTER(C: CHAR): BOOLEAN;
| 
|      BEGIN
|      LETTER := (('A' <= C) AND (C <= 'Z')) OR (('a' <= C) AND (C <= 'z')) ;
|      END ;
| 
|    FUNCTION DIGIT(C: CHAR): BOOLEAN ;
| 
|      BEGIN
|      DIGIT := ('0' <= C) AND (C <= '9') ;
|      END ;
| 
|    FUNCTION SPECIAL(C: CHAR): BOOLEAN;
|      BEGIN  SPECIAL := (C = '$') OR (C = '_')  END ;
| 
| FUNCTION NOKEY: BOOLEAN;
|    VAR I,J,K: INTEGER;
| BEGIN I := 1; J := NK;   (*BINARY SEARCH*)
|   REPEAT K := (I+J) DIV 2;
|     IF KEY[K] <= ID.A THEN I := K+1 ELSE J := K-1
|   UNTIL I > J;
|   IF J = 0 THEN NOKEY := TRUE ELSE
|     NOKEY := KEY[J] <> ID.A
| END (*NOKEY*) ;
| 
| PROCEDURE COUNTLINE;
| BEGIN
|   IF M = LPPG THEN
|     BEGIN PAGE(OUTPUT); WRITELN(OUTPUT); WRITELN(OUTPUT);
|       M := 0
|     END;
|   M := M + 1
| END (*COUNTLINE*) ;
| 
| PROCEDURE ADVANCE;
| BEGIN
|   WRITE(OUTPUT,INPUT@); GET(INPUT);
|   CCOUNT := CCOUNT + 1;
|   IF CCOUNT = LLNGIN THEN
|     WHILE NOT EOLN(INPUT) DO
|       BEGIN WRITE(OUTPUT,INPUT@); GET(INPUT);
|       END
| END (*ADVANCE*);
| 
| PROCEDURE SPACE(J: INTEGER);
| BEGIN
|   REPEAT J := J-1; WRITELN(OUTPUT); COUNTLINE
|   UNTIL J = 0
| END (*SPACE*) ;
| 
| PROCEDURE NEWLINE;
| BEGIN CCOUNT := 0;
|   IF N < MAXN THEN
|   BEGIN COUNTLINE;  N := N + 1;
|     IF COMPILERLISTING THEN
|       BEGIN IF NOT EOLN THEN
|         BEGIN ADVANCE;
| """     IF NOT (INPUT@ IN ['0'..'9']) THEN  (* ERRORS *)  """
|         IF NOT DIGIT(INPUT@) THEN  (* ERRORS *)
|           WHILE NOT EOLN DO
|             ADVANCE
|         ELSE BEGIN
|           FOR I := 1 TO ADDRWIDTH + 1  DO
|             ADVANCE;
|           WHILE (INPUT@ = ' ') AND NOT EOLN DO
|             ADVANCE
|           END
|         END
|       END
|     ELSE WRITE(OUTPUT,' ');
|     IF LINENUMBERS THEN
|       BEGIN LN := 0;
|       WHILE DIGIT(INPUT@) DO
| """   WHILE INPUT@ IN ['0'..'9'] DO   """
|         BEGIN LN := 10*LN + ORD(INPUT@) - ORD('0');
|           ADVANCE
|         END
|       END
|     ELSE BEGIN
|       LN := N;  WRITE(OUTPUT,LN:6, ' ')
|       END
|     END
|   ELSE BEGIN
|     WRITELN(STARS, ' TEXT TOO LONG', STARS);
|     "GOTO 99"  EXIT(99);
|     END
| END (*NEWLINE*) ;
| 
| PROCEDURE SEARCH;   (*MODULO P HASH SEARCH*)
|   VAR H,D: INDEX;
|       X: REF; F: BOOLEAN;
|       K: INTEGER;
| BEGIN  I := ABS(ID.ORD);  H := I MOD P;
|   F := FALSE; D := 1;
|   NEW(X); X@.LNO := LN;
|   REPEAT
|     IF T[H].KEY = ID.A THEN
|     BEGIN (*FOUND*) F := TRUE;
|       X@.NEXT := T[H].FIRST; T[H].FIRST := X;
|     END ELSE
|     IF T[H].KEY = EMPTY THEN
|     BEGIN (*NEW ENTRY*) F := TRUE;
|       T[H].KEY := ID.A;
|       T[H].FIRST := X; X@.NEXT := NIL
|     END ELSE
|     BEGIN (*COLLISION*) H := H+D; D := D+2;
|       IF H >= P THEN H := H-P;
|       IF D = P THEN
|         BEGIN WRITELN(OUTPUT); WRITELN(STARS,' TABLE FULL',STARS);""" GOTO 99"""
|         EXIT(99);
|         END
|     END
|   UNTIL F
| END (*SEARCH*) ;
| 
| PROCEDURE SORT(MIN, MAX: INTEGER);
| 
| (* QUICKSORT WITH BOUNDED RECURSION DEPTH *)
| (* REQUIRES MIN <= MAX *)
| 
|    VAR
|          LOW,
|         HIGH: INDEX;
|       MIDKEY: ALFA;
|         TEMP: WORD;
| 
|    BEGIN
|       REPEAT (*PICK SPLIT POINT*)
|          MIDKEY := T[(MIN + MAX) DIV 2].KEY;
|          LOW := MIN;
|          HIGH := MAX;
|          REPEAT (*PARTITION*)
|             WHILE T[LOW].KEY < MIDKEY DO
|                LOW := LOW + 1;
|             WHILE T[HIGH].KEY > MIDKEY DO
|                HIGH := HIGH - 1;
|             IF LOW <= HIGH THEN
|                BEGIN
|                   TEMP := T[LOW];
|                   T[LOW] := T[HIGH];
|                   T[HIGH] := TEMP;
|                   LOW := LOW + 1;
|                   HIGH := HIGH - 1
|                END;
|          UNTIL LOW > HIGH;
| 
|          (*RECURSIVELY SORT SHORTER SUB-SEGMENT*)
|          IF HIGH - MIN < MAX - LOW
|          THEN
|             BEGIN
|                IF MIN < HIGH THEN
|                   SORT(MIN, HIGH);
|                MIN := LOW
|             END
|          ELSE
|             BEGIN
|                IF LOW < MAX THEN
|                   SORT(LOW, MAX);
|                MAX := HIGH
|             END
|       UNTIL MAX <= MIN
|    END (*SORT*);
| 
| 
| PROCEDURE NOTEPROC;   (*NOTE INSTANCE OF PROCEDURE OR FUNCTION*)
|   VAR P: PROCREF;
| BEGIN PROCORFUNC := FALSE;
|   NEW(P); PROCPTR@.NEXT := P;
|   P@.NAME := ID.A; P@.LNO := LN; P@.NEXT := NIL;
|   PROCPTR := P
| END (*NOTEPROC*) ;
| 
| PROCEDURE PRINTWORD(W: WORD);
|   VAR L: INTEGER; X,Y,Z: REF;
| BEGIN COUNTLINE; WRITE(OUTPUT,' ', W.KEY);
|   X := W.FIRST; Y := X@.NEXT; X@.NEXT := NIL;
|   WHILE Y <> NIL DO
|     BEGIN Z := Y@.NEXT; Y@.NEXT := X; X := Y; Y := Z
|     END ;
|   L := 0;
|   REPEAT
|     IF L = NOPL THEN
|       BEGIN L := 0; WRITELN(OUTPUT); COUNTLINE; WRITE(OUTPUT,' ', EMPTY)
|       END;
|     L := L+1; WRITE(OUTPUT,X@.LNO: DGPN); X := X@.NEXT
|   UNTIL X = NIL;
|   WRITELN(OUTPUT);
| END (*PRINTWORD*) ;
| 
| PROCEDURE PRINTTABLE;
|   VAR I,M: INDEX;
| BEGIN M := 0;    (*COMPRESS TABLE*)
|   FOR I := 0 TO P-1 DO
|     IF T[I].KEY <> EMPTY THEN
|       BEGIN T[M] := T[I]; M := M+1
|       END ;
|   IF M > 0 THEN SORT(0,M-1);
|   NOPL := (LLNGOUT-KLN-1) DIV DGPN;
|   SPACE(2); WRITELN(' CROSS REFERENCE OF IDENTIFIERS,',
|             ' LABEL DECLARATIONS AND GOTO STATEMENTS:');
|   COUNTLINE; SPACE(1);
|   FOR I := 0 TO M-1 DO PRINTWORD(T[I])
| END (*PRINTTABLE*) ;
| 
| PROCEDURE PRINTPROCS;
| BEGIN SPACE(2); COUNTLINE;
|   WRITELN(' LIST OF PROCEDURES AND FUNCTIONS:');
|   COUNTLINE; SPACE(1);
|   PROCPTR := FIRSTPROC@.NEXT;
|   WHILE PROCPTR <> NIL DO
|     BEGIN WITH PROCPTR@ DO WRITELN(NAME:24,LNO:10);
|       COUNTLINE; PROCPTR := PROCPTR@.NEXT
|     END
| END (*PRINTPROCS*) ;
| 
| PROCEDURE INITIALIZE;
|   TYPE SETTING = PACKED RECORD
|                    CASE SWITCH: BOOLEAN OF
|                      TRUE: (ONOFF: CHAR);
|                      FALSE: (SIZE: 0..999999)
|                    END;
|   VAR S: SETTING;
|   FUNCTION OPTION(NAME: CHAR; VAR S: SETTING): BOOLEAN;
|     EXTERNAL;
| BEGIN N := 0; M := 0;
|   LLNGIN := LLMAX; LLNGOUT := LLMAX;
| """IF OPTION('U',S) THEN
|     IF S.SWITCH AND (S.ONOFF = '+')
|       THEN LLNGIN := LLMIN;
|   IF OPTION('W',S) THEN
|     IF S.SWITCH AND (S.ONOFF = '+')
|       THEN LLNGOUT := LLMIN;    """
|   FOR I := 0 TO P-1 DO T[I].KEY := EMPTY;
|   NEW(PROCPTR); FIRSTPROC := PROCPTR; PROCPTR@.NEXT := NIL;
|   PROCORFUNC := TRUE;   (*TO GET P R O G R A M NAME IN PROCEDURE INDEX*)
|   KEY[ 1] := 'AND       '; KEY[ 2] := 'ARRAY     ';
|   KEY[ 3] := 'BEGIN     '; KEY[ 4] := 'CASE      ';
|   KEY[ 5] := 'CONST     '; KEY[ 6] := 'DIV       ';
|   KEY[ 7] := 'DOWNTO    '; KEY[ 8] := 'DO        ';
|   KEY[ 9] := 'ELSE      '; KEY[10] := 'END       ';
|   KEY[11] := 'FILE      '; KEY[12] := 'FOR       ';
|   KEY[13] := 'FUNCTION  '; KEY[14] := 'IF        ';
|   KEY[15] := 'IN        '; KEY[16] := 'MOD       ';
|   KEY[17] := 'NIL       '; KEY[18] := 'NOT       ';
|   KEY[19] := 'OF        '; KEY[20] := 'OR        ';
|   KEY[21] := 'PACKED    '; KEY[22] := 'PROCEDURE ';
|   KEY[23] := 'PROGRAM   '; KEY[24] := 'RECORD    ';
|   KEY[25] := 'REPEAT    '; KEY[26] := 'SET       ';
|   KEY[27] := 'THEN      '; KEY[28] := 'TO        ';
|   KEY[29] := 'TYPE      '; KEY[30] := 'UNTIL     ';
|   KEY[31] := 'VAR       '; KEY[32] := 'WHILE     ';
|   KEY[33] := 'WITH      '
| END (*INITIALIZE*) ;
| 
| PROCEDURE SCANANDLISTINPUT;
| BEGIN
|   WHILE NOT EOF(INPUT) DO
|   BEGIN NEWLINE;
|     WHILE NOT EOLN(INPUT) DO
|     CASE INPUT@ OF
|      'a','b','c','d','e','f','g','h','i','j','k','l','m',
|      'n','o','p','q','r','s','t','u','v','w','x','y','z',
|      'A','B','C','D','E','F','G','H','I','J','K','L','M',
|      'N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
|       BEGIN K := 0; ID.A := EMPTY;
|         REPEAT
|           IF K < KLN THEN
|             BEGIN K := K+1; ID.A[K] := INPUT@
|             END;
|           ADVANCE
| """     UNTIL NOT(INPUT@ IN ['A'..'Z', '0'..'9']);   """
|         UNTIL NOT(LETTER(INPUT@) OR DIGIT(INPUT@) OR SPECIAL(INPUT@));
|         IF NOKEY THEN
|         BEGIN SEARCH;
|           IF PROCORFUNC THEN NOTEPROC
|         END ELSE
|         IF (ID.A = 'PROCEDURE ') OR (ID.A = 'FUNCTION  ') THEN
|           PROCORFUNC := TRUE
|       END;
|      '0','1','2','3','4','5','6','7','8','9':
|         REPEAT ADVANCE;
| """     UNTIL NOT (INPUT@ IN ['B','E','0'..'9']);  """
|         UNTIL NOT DIGIT(INPUT@) ;
|      '''':
|       BEGIN (*STRING*)
|         REPEAT ADVANCE;
|         UNTIL (INPUT@ = '''') OR EOLN(INPUT);
|         IF NOT EOLN(INPUT) THEN
|           ADVANCE
|       END;
| #    '"':
|       BEGIN (*COMMENT*)
|         REPEAT ADVANCE;
|           WHILE EOLN(INPUT) DO
|             BEGIN WRITELN(OUTPUT); GET(INPUT); NEWLINE
|             END
|         UNTIL INPUT@ = '"';
|         ADVANCE
|       END;
|      '(':
|       BEGIN ADVANCE;
|         IF INPUT@ = '*' THEN
|         BEGIN (*COMMENT*) ADVANCE;
|           REPEAT
|             WHILE INPUT@ <> '*' DO
|             BEGIN
|               IF EOLN(INPUT) THEN
|                 BEGIN GET(INPUT); WRITELN(OUTPUT); NEWLINE
|                 END ELSE
|                 ADVANCE
|             END ;
|             ADVANCE
|           UNTIL INPUT@ = ')';
|           ADVANCE
|         END
|       END;
|      '+','-','*','/',')','$','=',' ',',','.','[',']',
|      ':','!','×','&','@','?','<','>','Ö','\','^',';','#','_','%','ò':
|       ADVANCE
|     END (*CASE*) ;
|     WRITELN(OUTPUT); GET(INPUT)
|   END ;
| END (*SCANANDLISTINPUT*) ;
| 
| PROCEDURE SKIPCOMPILERTITLE;
|   VAR I: INTEGER;
| BEGIN
|   COMPILERLISTING := INPUT@ = '1';
|   IF COMPILERLISTING THEN
|   BEGIN I := 0; GET(INPUT);
|     WHILE I < LITL DO
|       BEGIN I := I + 1;
|         WHILE NOT EOLN(INPUT) DO
|           ADVANCE;
|         READLN; WRITELN(OUTPUT);
|       END;
|     COUNTLINE;
|     LINENUMBERS := TRUE
|   END ELSE
|   BEGIN WRITELN(OUTPUT); WRITELN(OUTPUT);
|     LINENUMBERS := """INPUT@ IN ['0'..'9']""" DIGIT(INPUT@)
|   END
| END (*SKIPCOMPILERTITLE*) ;
| 
| BEGIN (*CROSSREF*)
| """LINELIMIT(OUTPUT, MAXN);"""  PAGE(OUTPUT); INITIALIZE;
|   IF NOT EOF(INPUT) THEN
|   BEGIN SKIPCOMPILERTITLE;
|     SCANANDLISTINPUT; """LINELIMIT(OUTPUT, MAXN); """
|     PRINTTABLE; PRINTPROCS
|   END ELSE WRITELN(STARS,' NO PROGRAM FOUND TO CROSS REFERENCE',STARS);
| 99:END .
> Member PRINTME
| (* after a program published in Pascal News, DEW Jan. 79 *)
| 
| PROGRAM PRINTME(OUTPUT);
| 
|    TYPE ALPHA=ARRAY(/1..50/) OF CHAR;
| 
|    VAR  A: ARRAY(/1..31/) OF ALPHA;
|         B: ARRAY(/1..10/) OF CHAR;
|         I: INTEGER;
| 
| 
| BEGIN
| 
| B(/ 1/):='''';
| B(/ 2/):='A';
| B(/ 3/):='B';
| B(/ 4/):=' ';
| B(/ 5/):=';';
| B(/ 6/):='/';
| B(/ 7/):=')';
| B(/ 8/):='(';
| B(/ 9/):=':';
| B(/10/):='=';
| A(/ 1/):='PROGRAM PRINTME(OUTPUT);                          ';
| A(/ 2/):='                                                  ';
| A(/ 3/):='   TYPE ALPHA=ARRAY(/1..50/) OF CHAR;             ';
| A(/ 4/):='                                                  ';
| A(/ 5/):='   VAR  A: ARRAY(/1..31/) OF ALPHA;               ';
| A(/ 6/):='        B: ARRAY(/1..10/) OF CHAR;                ';
| A(/ 7/):='        I: INTEGER;                               ';
| A(/ 8/):='                                                  ';
| A(/ 9/):='                                                  ';
| A(/10/):='BEGIN                                             ';
| A(/11/):='                                                  ';
| A(/12/):='FOR I:=1 TO 11 DO WRITELN(OUTPUT,B(/4/),A(/I/));  ';
| A(/13/):='                                                  ';
| A(/14/):='I:=1;                                             ';
| A(/15/):='WRITELN(OUTPUT,B(/4/),B(/3/),B(/8/),B(/6/),I:2,   ';
| A(/16/):='       B(/6/),B(/7/),B(/9/),B(/10/),B(/1/),B(/1/),';
| A(/17/):='       B(/1/),B(/1/),B(/5/) );                    ';
| A(/18/):='                                                  ';
| A(/19/):='FOR I:=2 TO 10 DO WRITELN(OUTPUT,B(/4/),B(/3/),   ';
| A(/20/):='                  B(/8/),B(/6/),I:2,B(/6/),B(/7/),';
| A(/21/):='                  B(/9/),B(/10/),B(/1/),B(/I/),   ';
| A(/22/):='                  B(/1/),B(/5/) );                ';
| A(/23/):='                                                  ';
| A(/24/):='FOR I:=1 TO 31 DO WRITELN(OUTPUT,B(/4/),B(/2/),   ';
| A(/25/):='                  B(/8/),B(/6/),I:2,B(/6/),B(/7/),';
| A(/26/):='                  B(/9/),B(/10/),B(/1/),A(/I/),   ';
| A(/27/):='                  B(/1/),B(/5/) );                ';
| A(/28/):='                                                  ';
| A(/29/):='FOR I:=11 TO 31 DO WRITELN(OUTPUT,B(/4/),A(/I/)); ';
| A(/30/):='                                                  ';
| A(/31/):='END.                                              ';
| 
| FOR I:=1 TO 11 DO WRITELN(OUTPUT,B(/4/),A(/I/));
| 
| I:=1;
| WRITELN(OUTPUT,B(/4/),B(/3/),B(/8/),B(/6/),I:2,
|        B(/6/),B(/7/),B(/9/),B(/10/),B(/1/),B(/1/),
|        B(/1/),B(/1/),B(/5/) );
| 
| FOR I:=2 TO 10 DO WRITELN(OUTPUT,B(/4/),B(/3/),
|                   B(/8/),B(/6/),I:2,B(/6/),B(/7/),
|                   B(/9/),B(/10/),B(/1/),B(/I/),
|                   B(/1/),B(/5/) );
| 
| FOR I:=1 TO 31 DO WRITELN(OUTPUT,B(/4/),B(/2/),
|                   B(/8/),B(/6/),I:2,B(/6/),B(/7/),
|                   B(/9/),B(/10/),B(/1/),A(/I/),
|                   B(/1/),B(/5/) );
| 
| FOR I:=11 TO 31 DO WRITELN(OUTPUT,B(/4/),A(/I/));
| 
| END.
> Member PROFILER
| PROGRAM PROFILE(OUTPUT,QRD);
| 
| (*$D-
|         M U L T I P U R P O S E   P R O F I L E    G E N E R A T O R
|         -----------------------   -------------    -----------------
| 
|      AUTHOR:  R. NIGEL HORSPOOL,  MCGILL UNIVERSITY,  MONTREAL.
|      DATE:    AUGUST 22, 1979.
| 
| PURPOSE: TO PRODUCE AN EXECUTION PROFILE FOR PASCAL PROGRAMS COMPILED
|          AND EXECUTED VIA THE STANFORD PASCAL COMPILER.
|          THIS PROGRAM IS INTENDED TO BE WHOLLY COMPATIBLE WITH THE
|          "PASPROF" PROGRAM SUPPLIED WITH THE STANFORD PASCAL SYSTEM.
|          HOWEVER, THIS PROGRAM REQUIRES MUCH LESS MEMORY AND IS MORE
|          VERSATILE.  IT CAN GENERATE THREE DIFFERENT FORMATS FOR THE
|          PROFILE.  THE FORMAT IS SELECTED ACCORDING TO WHAT INPUT IS
|          PROVIDED IN THE "PRD" FILE - SEE BELOW.  FORMAT 1 IS A
|          VERY CONDENSED PROFILE, SUITABLE FOR LISTING ON AN INTERACTIVE
|          TERMINAL.  FORMAT 2 GIVES A SOURCE LISTING WITH EXECUTION
|          FREQUENCIES PRINTED ALONGSIDE EACH LINE.  FORMAT 3 IS SIMILAR
|          TO FORMAT 2 BUT IS IDENTICAL (OR NEARLY SO) TO THE FORMAT
|          GENERATED BY STANFORD'S PASPROF PROGRAM.
| 
| FILES:
|          QRR   - THE COUNTERS WRITTEN BY AN EXECUTING PASCAL PROGRAM
|                  (WITH THE K+ OPTION IN EFFECT WHEN COMPILED).  THIS
|                  CORRESPONDS TO THE DDNAME "GO.QRR" IN A PASCAL JOB.
|          QRD   - SYMBOL TABLE DATA WRITTEN DURING A PASCAL COMPILATION.
|                  THIS CORRESPONDS TO THE DDNAME "COMPILE.QRR".
|          PRD   - THREE POSSIBILITIES ARE ALLOWED  (AND CAUSE OUTPUT
|                  FORMATS 1, 2 OR 3 RESPECTIVELY).
|                  1.  "PRD" IS AN EMPTY FILE  (I.E., THE DD STATEMENT
|                      IN THE O.S. JCL IS CODED AS "DD DUMMY").
|                  2.  "PRD" IS A FILE CONTAINING THE IDENTICAL SOURCE
|                      CODE AS THE PROGRAM TO BE PROFILED.
|                  3.  "PRD" IS A FILE CONTAINING THE COMPILATION OUTPUT
|                      CREATED WHEN THE PROGRAM TO BE PROFILED WAS COMPILED.
|                      (THIS CORRESPONDS TO THE DDNAME "COMPILE.OUTPUT".)
| 
| ERROR CODES:
|          101, 102, 103:  INDICATE AN INTERNAL INCONSISTENCY IN THE DATA
|                  CONTAINED IN THE "QRD" FILE.  THE ERROR SHOULD BE
|                  REPORTED TO THE AUTHOR.
|          200:    INDICATES THAT THE "QRR" FILE IS EMPTY OR A PREMATURE
|                  END OF FILE HAS OCCURRED.
|                                                                               *)
| (*$EJECT *)
| CONST MAXLINES = 55;
|       BUFLEN   = 150;         (*SIZE OF THE INPUT LINE BUFFER*)
| TYPE  STMT_TYPE = ( PROC, LAB_STMT, GOTO_STMT, IF_STMT, WHILE_STMT,
|                     REPEAT_STMT, FOR_STMT, CASE_STMT, THEN_CLAUSE,
|                     ELSE_CLAUSE, CASE_CLAUSE );
|       NODE = RECORD
|                 KIND: STMT_TYPE;
|                 CTR_NO, FIRSTLN, LASTLN: INTEGER;
|                 NEST, NEXT: @NODE;
|              END;
|       NODE_PTR = @NODE;
| VAR   NODE_LIST, NEW_NODE, HEAP_MARK: NODE_PTR;
|       LAST_CNT, LAST_CTR_NO, LEN, LINECNT,
|            PAGENUM, LEVEL, MID_LINE, CURLINE: INTEGER;
|       MODE: ( UNKNOWN, BRIEF, SOURCE, LISTING );
|       FAKE: RECORD CASE BOOLEAN OF
|                FALSE: ( KIND: STMT_TYPE );
|                TRUE:  ( INT:  INTEGER   );  END;
|       OK: BOOLEAN;
|       LAB:  ARRAY(/1..4/) OF CHAR;
|       PROC_NAME: ARRAY(/1..12/) OF CHAR;
|       L: RECORD CASE BOOLEAN OF
|             FALSE: (LINE:     ARRAY(/1..BUFLEN/) OF CHAR);
|             TRUE:  (SEQUENCE: ARRAY(/1..9/)   OF CHAR;
|                     REMDR:    ARRAY(/1..141/) OF CHAR);  END;
| 
| FUNCTION INNER_STMTS( START_LINE, START_CTR: INTEGER ): NODE_PTR;
|    LABEL 10;
|    VAR   TEMP1, TEMP2: NODE_PTR;
|    BEGIN
|       TEMP1 := NIL;
|       IF NODE_LIST <> NIL THEN
|          WHILE ( NODE_LIST@.FIRSTLN >= START_LINE ) AND
|                ( NODE_LIST@.CTR_NO  >  START_CTR  ) DO
|             BEGIN
|                TEMP2 := NODE_LIST;  NODE_LIST := TEMP2@.NEXT;
|                TEMP2@.NEXT := TEMP1;  TEMP1 := TEMP2;
|                IF NODE_LIST = NIL THEN GOTO 10;
|             END;
|    10:INNER_STMTS := TEMP1;
|    END (* INNER_STMTS *) ;
| 
| PROCEDURE BUILD_TREE( NEW_NODE: NODE_PTR );
|    VAR TEMP1, TEMP2: NODE_PTR;
|    BEGIN
|       CASE NEW_NODE@.KIND OF
| 
|       WHILE_STMT, REPEAT_STMT, FOR_STMT, PROC:
|          NEW_NODE@.NEST := INNER_STMTS( NEW_NODE@.FIRSTLN, NEW_NODE@.CTR_NO );
| 
|       IF_STMT:
|          IF MID_LINE = 0 THEN  (* NO ELSE CLAUSE *)
|             BEGIN
|                NEW_NODE@.KIND := THEN_CLAUSE;
|                NEW_NODE@.NEST := INNER_STMTS( NEW_NODE@.FIRSTLN,
|                                               NEW_NODE@.CTR_NO );
|             END
|          ELSE BEGIN  (* NESTED THEN & ELSE CLAUSES *)
|                NEW(TEMP2);
|                WITH TEMP2@ DO BEGIN
|                   KIND := ELSE_CLAUSE;  CTR_NO := MAXINT;
|                   FIRSTLN := MID_LINE;  NEXT   := NIL;
|                   LASTLN  := NEW_NODE@.LASTLN;
|                   NEST := INNER_STMTS( MID_LINE, NEW_NODE@.CTR_NO );  END;
|                NEW(TEMP1);
|                WITH TEMP1@ DO BEGIN
|                   KIND := THEN_CLAUSE;  CTR_NO := NEW_NODE@.CTR_NO;
|                   FIRSTLN := NEW_NODE@.FIRSTLN;  LASTLN := MID_LINE - 1;
|                   IF LASTLN < FIRSTLN THEN LASTLN := FIRSTLN;
|                   NEST := INNER_STMTS( FIRSTLN, NEW_NODE@.CTR_NO );
|                   NEXT := TEMP2;                                       END;
|                NEW_NODE@.NEST := TEMP1;
|          END;
| 
|       CASE_STMT:
|          IF MID_LINE = 0 THEN BEGIN  (* CASE CLAUSE *)
|             NEW_NODE@.KIND := CASE_CLAUSE;
|             NEW_NODE@.NEST := INNER_STMTS( NEW_NODE@.FIRSTLN,
|                                            NEW_NODE@.CTR_NO );  END
|          ELSE BEGIN  (* END OF ENTIRE CASE STMT *)
|             TEMP1 := NIL;
|             WHILE MID_LINE > 0 DO
|                IF NODE_LIST <> NIL THEN
|                   BEGIN
|                      IF NODE_LIST@.KIND <> CASE_CLAUSE THEN EXIT(101);
|                      TEMP2 := NODE_LIST;  NODE_LIST := TEMP2@.NEXT;
|                      TEMP2@.NEXT := TEMP1;  TEMP1 := TEMP2;
|                      MID_LINE := MID_LINE - 1;
|                   END
|                ELSE EXIT(102);
|             NEW_NODE@.NEST := TEMP1;
|             NEW_NODE@.CTR_NO := MAXINT;
|          END;
| 
|       GOTO_STMT:
|          NEW_NODE@.CTR_NO := MAXINT;
| 
|       LAB_STMT:
|          (* NOTHING *) ;
|       END  (* CASE *) ;
|       NEW_NODE@.NEXT := NODE_LIST;
|       NODE_LIST := NEW_NODE;
|    END (* BUILD_TREE *) ;
| 
| PROCEDURE FILL_LINE;
|    BEGIN
|    (**LEN := 0;  REPEAT  LEN := LEN + 1;  READ(PRD, L.LINE(/LEN/) );
|                  UNTIL   EOLN(PRD);  READLN(PRD);**)
|        READLN(PRD, L.LINE);
|        LEN := BUFLEN;
|        REPEAT  LEN := LEN-1;  UNTIL (LEN = 1) OR (L.LINE(/LEN/) <> ' ');
|    END  (* FILL_LINE *) ;
| 
| PROCEDURE READLINE;
|    LABEL 10;
|    VAR I: INTEGER;  CH: CHAR;  SEEN: BOOLEAN;
| 
|    FUNCTION HEADLINE: BOOLEAN;
|       VAR  TEST: BOOLEAN;  I: INTEGER;
|       BEGIN  TEST := FALSE;
|          IF L.LINE(/1/) = '1' THEN  (* PAGE CONTROL CHAR? *)
|             TEST := TRUE
|          ELSE BEGIN  (* LOOK FOR WORD "LINE" IN HEADING *)
|             I := 1;  WHILE L.LINE(/I/) = ' ' DO I := I + 1;
|             TEST := (L.LINE(/I/) = 'L');
|          END;
|          IF TEST THEN BEGIN  (* SOME NASTY SIDE-EFFECTS *)
|             IF L.LINE(/1/) <> '1' THEN BEGIN  PAGE;  WRITELN;  END;
|             PAGENUM := PAGENUM + 1;
|             WRITELN( L.SEQUENCE, 'RUN CNT':9, L.REMDR:LEN-9 );
|             FILL_LINE;  READLN(PRD);
|             WRITELN( L.SEQUENCE, '--- ---':9, L.REMDR:LEN-9 );
|             WRITELN;  MODE := LISTING;  END;
|          HEADLINE := TEST;
|       END;
|       BEGIN  (* READLINE *)
|          REPEAT
|             FILL_LINE;
|             L.LINE(/BUFLEN/) := '#';
|             IF LEN = 1 THEN
|                IF EOF(PRD) THEN BEGIN MODE := BRIEF;  GOTO 10;  END;
|          UNTIL NOT HEADLINE;
|          IF MODE = LISTING THEN BEGIN
|             CURLINE := 0;  SEEN := FALSE;
|             FOR I := 1 TO 9 DO BEGIN
|                CH := L.LINE(/I/);
|               IF CH >= '0' THEN BEGIN  SEEN := TRUE;
|                  CURLINE := CURLINE*10 - ORD('0') + ORD(CH);  END;  END;
|             IF NOT SEEN THEN  (* NO LINE # FOUND *)
|                 CURLINE := MAXINT;  END;
|  10: END;
| 
| PROCEDURE ADVANCE( STOPLINE, FREQUENCY: INTEGER );
|    BEGIN
|       WHILE (CURLINE <= STOPLINE) AND (MODE <> BRIEF) DO
|          IF MODE = SOURCE THEN BEGIN
|             IF LINECNT >= MAXLINES THEN BEGIN
|                PAGE;  WRITELN;  PAGENUM := PAGENUM + 1;
|                WRITELN( 'LINE #  RUN CNT':18, 'SOURCE STATEMENT':26,
|                           'PAGE':24, PAGENUM:4 );
|                WRITELN( '---- -  --- ---':18, '------ ---------':26,
|                           '---- ---':28 );
|                WRITELN;  LINECNT := 0;  END;
|             LINECNT := LINECNT + 1;
|             WRITE( CURLINE:9 );
|             IF FREQUENCY = 0
|                THEN WRITE( ' ':8 ) ELSE WRITE( FREQUENCY:8 );
|             WRITELN( ' ':4, L.LINE:LEN );
|             FILL_LINE;
|             IF LEN = 1 THEN
|                IF EOF(PRD) THEN MODE := BRIEF;
|             CURLINE := CURLINE + 1;  END
|           ELSE BEGIN
|             WRITE( L.SEQUENCE:9 );
|             IF FREQUENCY = 0 THEN
|                WRITE( ' ':9 ) ELSE WRITE( FREQUENCY:9 );
|             WRITELN( L.REMDR:LEN-9 );  READLINE;
|           END;
|    END (* ADVANCE *) ;
| 
| PROCEDURE PRINT( NODE: NODE_PTR;  CNT: INTEGER );
|    CONST TAB = 2;
|    BEGIN
|       IF MODE = BRIEF THEN BEGIN
|          IF LINECNT >= MAXLINES THEN BEGIN
|             PAGE;  WRITELN;  LINECNT := 0;  PAGENUM := PAGENUM + 1;
|             WRITELN( 'LINE # RANGE  RUN CNT  CONSTRUCT':35,
|                       'PAGE':10, PAGENUM:4 );
|             WRITELN( '---- - -----  --- ---  ---------':35, '---- ---':14 );
|             WRITELN;  END;
|          LINECNT := LINECNT + 1;
|          WITH NODE@ DO BEGIN
|             WRITE( FIRSTLN:7, '-':3, LASTLN:5, CNT:9,
|                        ' ':(LEVEL*TAB) );
|             CASE KIND OF
|                PROC:         WRITELN( 'PROCEDURE: ', PROC_NAME );
|                LAB_STMT:     WRITELN( 'LABELLED STMT' );
|                WHILE_STMT:   WRITELN( 'WHILE STMT' );
|                REPEAT_STMT:  WRITELN( 'REPEAT STMT' );
|                FOR_STMT:     WRITELN( 'FOR STMT' );
|                THEN_CLAUSE:  WRITELN( 'THEN CLAUSE' );
|                ELSE_CLAUSE:  WRITELN( 'ELSE CLAUSE' );
|                CASE_CLAUSE:  WRITELN( 'CASE CLAUSE' );
|                IF_STMT, CASE_STMT:  WRITELN;
|             END;  END;  END;
|    END  (* PRINT *) ;
| 
| PROCEDURE WALK( NODE: NODE_PTR; DFLT_CNT: INTEGER );
|    VAR  CNT: INTEGER;  ELSE_PTR: NODE_PTR;
|    BEGIN
|       LEVEL := LEVEL + 1;
|       WHILE NODE <> NIL DO
|          WITH NODE@ DO BEGIN
|             ADVANCE( FIRSTLN-1, DFLT_CNT );
|             IF CTR_NO < MAXINT THEN  BEGIN
|                IF CTR_NO < LAST_CTR_NO THEN EXIT(103);
|                WHILE CTR_NO > LAST_CTR_NO DO
|                   BEGIN LAST_CTR_NO := LAST_CTR_NO + 1;
|                      WHILE (QRR@=' ') AND NOT EOF(QRR) DO GET(QRR);
|                      IF EOF(QRR) THEN BEGIN
|                         WRITELN;  WRITELN( '****':9,
|                         'ERROR - COUNTERS FILE INCONSISTANT':36 );
|                         EXIT(200);  END;
|                         READ( QRR, LAST_CNT );  END;
|                CNT := LAST_CNT;  END
|             ELSE CNT := DFLT_CNT;
|             IF KIND = IF_STMT THEN BEGIN
|                ELSE_PTR := NEST@.NEXT;
|                NEST@.NEXT := NIL;
|                WALK( NEST, DFLT_CNT );  WALK( ELSE_PTR, DFLT_CNT - CNT );
|                "NEST@.NEXT := ELSE_PTR;"  END
|             ELSE BEGIN
|                IF (KIND <> CASE_STMT) AND
|                   (KIND <> GOTO_STMT) THEN PRINT( NODE, CNT );
|                IF NEST <> NIL THEN WALK( NEST, CNT );
|                ADVANCE( LASTLN, CNT );
|                IF (KIND = GOTO_STMT) OR (KIND = CASE_CLAUSE) THEN
|                   DFLT_CNT := 0
|                ELSE IF KIND = LAB_STMT THEN
|                   DFLT_CNT := CNT;  END;
|             NODE := NEXT;
|          END (* WITH *) ;
|       LEVEL := LEVEL - 1;
|    END  (* WALK *) ;
| 
| BEGIN  (* PROFILE *)
|    RESET(PRD);  RESET(QRR);
|    MODE := UNKNOWN;  LINECNT := MAXLINES;  LAST_CTR_NO := -1;
|    MARK( HEAP_MARK );  NODE_LIST := NIL;   OK := FALSE;
|    PROC_NAME := '            ';            PAGENUM := 0;
|    READLINE;
|    IF MODE = UNKNOWN THEN BEGIN
|       MODE := SOURCE;  CURLINE := 1;  END;
| 
|    WHILE NOT EOF(QRD) DO BEGIN
|       READ( QRD, LAB );
|       IF LAB = '#CTR' THEN BEGIN
|          NEW( NEW_NODE );  OK := TRUE;
|          WITH NEW_NODE@ DO BEGIN
|             READLN( QRD, FAKE.INT, CTR_NO, FIRSTLN, MID_LINE, LASTLN );
|             KIND := FAKE.KIND;
|             NEST := NIL;  NEXT := NIL;
|             BUILD_TREE( NEW_NODE );
|             IF KIND = PROC THEN
|                IF LASTLN > 0 THEN BEGIN
|                   LEVEL := 0;
|                   WALK( NEW_NODE, 0 );  RELEASE( HEAP_MARK );
|                   PROC_NAME := '            ';
|                   NODE_LIST := NIL;  END  END  END
|        ELSE IF LAB = '#BGN' THEN BEGIN
|           WHILE QRD@ = ' ' DO GET(QRD);
|           READLN( QRD, PROC_NAME );  END
|        ELSE READLN( QRD );  END;
|    IF OK THEN
|       ADVANCE( MAXINT, 0 )
|    ELSE BEGIN
|       WRITELN;  WRITELN( '****':9, 'ERROR - K+ OPTION NOT ENABLED':36 ); END;
| END.
> Member PSUBSET
| (*$M-,D-*)
| (* PASCALS.P                                                                  *)
| PROGRAM PASCALS(INPUT,OUTPUT);     (*1.7.75*)
| (*$M-, T-,P-  N.WIRTH,  E.T.H.
|       CLAUSIUSSTR.55   CH-8006 ZURICH    *)
| (* #INCLUDE "GLOBALS.I"                                                       *)
| (* GLOBALS.I                                                                  *)
| LABEL 99;
| CONST NKW = 27;     (*NO. OF KEY WORDS*)
| ## TABCH = ' ' "TAB";
|     ALNG =  10;     (*NO. OF SIGNIFICANT CHARS IN IDENTIFIERS*)
|     LLNG = 120;     (*INPUT LINE LENGTH*)
|     EMAX = 322;     (*MAX EXPONENT OF REAL NUMBERS*)
|     EMIN =-292;     (*MIN EXPONENT*)
|     KMAX =  15;     (*MAX NO. OF SIGNIFICANT DIGITS*)
|     TMAX = 100;     (*SIZE OF TABLE*)
|     BMAX =  20;     (*SIZE OF BLOCK-TABLE*)
|     AMAX =  30;     (*SIZE OF ARRAY-TABLE*)
|     C2MAX = 20;     (*SIZE OF REAL CONSTANT TABLE*)
|     CSMAX = 30;     (*MAX NO. OF CASES*)
|     CMAX = 500;     (*SIZE OF CODE*)
|     LMAX =   7;     (*MAXIMUM LEVEL*)
|     SMAX = 400;     (*SIZE OF STRING-TABLE*)
|     ERMAX = 58;     (*MAX ERROR NO.*)
|     OMAX =  66;     (*HIGHEST ORDER CODE*)
| (* { SHIT, LOOK AT THIS NUMBER×××××                                           *)
| (*  NMAX = 281474976710655;     2**48-1*)
| (* }                                                                          *)
| ##  NMAX = "MAXINT" 32767;
|     XMAX = NMAX;    (*131071 = 2**17 - 1*)
|     LINELENG = 136; (*OUTPUT LINE LENGTH*)
|     LINELIMIT = 200;
|     STACKSIZE = 200;
| 
| TYPE SYMBOL = (INTCON,REALCON,CHARCON,STRING,
|           NOTSY,PLUS,MINUS,TIMES,IDIV,RDIV,IMOD,ANDSY,ORSY,
|           EQL,NEQ,GTR,GEQ,LSS,LEQ,
|           LPARENT,RPARENT,LBRACK,RBRACK,COMMA,SEMICOLON,PERIOD,
|           COLON,BECOMES,CONSTSY,TYPESY,VARSY,FUNCSY,
|           PROCSY,ARRAYSY,RECORDSY,PROGRAMSY,IDENT,
|           BEGINSY,IFSY,CASESY,REPEATSY,WHILESY,FORSY,
|           ENDSY,ELSESY,UNTILSY,OFSY,DOSY,TOSY,DOWNTOSY,THENSY);
| 
| #   INDEX  = 0(*-XMAX*) .. +XMAX;
|     ALFA = PACKED ARRAY [1..ALNG] OF CHAR;
|     OBJECT = (KONSTANT,VARIABLE,TYPE1,PROZEDURE,FUNKTION);
|     TYPES  = (NOTYP,INTS,REALS,BOOLS,CHARS,ARRAYS,RECORDS);
|     SYMSET = SET OF SYMBOL;
|     TYPSET = SET OF TYPES;
|     ITEM   = RECORD
|           TYP: TYPES; REF: INDEX;
|         END ;
|     ORDER  = PACKED RECORD
|           F: -OMAX..+OMAX;
|           X: -LMAX..+LMAX;
| #         Y: 0(*-NMAX*)..+NMAX;
|         END ;
| 
| VAR SY: SYMBOL;          (*LAST SYMBOL READ BY INSYMBOL*)
|     ID: ALFA;            (*IDENTIFIER FROM INSYMBOL*)
|     INUM: INTEGER;       (*INTEGER FROM INSYMBOL*)
|     RNUM: REAL;          (*REAL NUMBER FROM INSYMBOL*)
|     SLENG: INTEGER;      (*STRING LENGTH*)
|     CH: CHAR;            (*LAST CHARACTER READ FROM SOURCE PROGRAM*)
|     LINE: ARRAY [1..LLNG] OF CHAR;
|     CC: INTEGER;         (*CHARACTER COUNTER*)
|     LC: INTEGER;         (*PROGRAM LOCATION COUNTER*)
|     LL: INTEGER;         (*LENGTH OF CURRENT LINE*)
|     ERRS: SET OF 0..ERMAX;
|     ERRPOS: INTEGER;
|     PROGNAME: ALFA;
|     IFLAG, OFLAG: BOOLEAN;
|     CONSTBEGSYS,TYPEBEGSYS,BLOCKBEGSYS,FACBEGSYS,STATBEGSYS: SYMSET;
|     KEY: ARRAY [1..NKW] OF ALFA;
|     KSY: ARRAY [1..NKW] OF SYMBOL;
|     SPS: ARRAY [CHAR] OF SYMBOL;  (*SPECIAL SYMBOLS*)
| 
|     T,A,B,SX,C1,C2: INTEGER;  (*INDICES TO TABLES*)
|     STANTYPS: TYPSET;
|     DISPLAY: ARRAY [0 .. LMAX] OF INTEGER;
| 
|     TAB:     ARRAY [0 .. TMAX] OF     (*IDENTIFIER TABLE*)
|           PACKED RECORD
|        NAME: ALFA;  LINK: INDEX;
|        OBJ: OBJECT; TYP: TYPES;
|        REF: INDEX;  NORMAL: BOOLEAN;
|        LEV: 0 .. LMAX; ADR: INTEGER;
|           END ;
|     ATAB:    ARRAY [1 .. AMAX] OF     (*ARRAY-TABLE*)
|           PACKED RECORD
|        INXTYP, ELTYP: TYPES;
|        ELREF, LOW, HIGH, ELSIZE, SIZE: INDEX;
|           END ;
|     BTAB:    ARRAY [1 .. BMAX] OF    (*BLOCK-TABLE*)
|           PACKED RECORD
|         LAST, LASTPAR, PSIZE, VSIZE: INDEX
|           END ;
|     STAB:    PACKED ARRAY [0..SMAX] OF CHAR;  (*STRING TABLE*)
|     RCONST:  ARRAY [1 .. C2MAX] OF REAL;
|     CODE:    ARRAY [0 .. CMAX] OF ORDER;
| (* EOF                                                                        *)
| (* #INCLUDE "ERROR.I"                                                         *)
| (* ERROR.I                                                                    *)
| 
| PROCEDURE ERRORMSG;
|    VAR K: INTEGER;
|        MSG: ARRAY [0..ERMAX] OF ALFA;
| BEGIN
|   MSG[ 0] := 'UNDEF ID  '; MSG[ 1] := 'MULTI DEF ';
|   MSG[ 2] := 'IDENTIFIER'; MSG[ 3] := 'PROGRAM   ';
|   MSG[ 4] := ')         '; MSG[ 5] := ':         ';
|   MSG[ 6] := 'SYNTAX    '; MSG[ 7] := 'IDENT, VAR';
|   MSG[ 8] := 'OF        '; MSG[ 9] := '(         ';
|   MSG[10] := 'ID, ARRAY '; MSG[11] := '[         ';
|   MSG[12] := ']         '; MSG[13] := '..        ';
|   MSG[14] := ';         '; MSG[15] := 'FUNC. TYPE';
|   MSG[16] := '=         '; MSG[17] := 'BOOLEAN   ';
|   MSG[18] := 'CONVAR TYP'; MSG[19] := 'TYPE      ';
|   MSG[20] := 'PROG.PARAM'; MSG[21] := 'TOO BIG   ';
|   MSG[22] := '.         '; MSG[23] := 'TYP (CASE)';
|   MSG[24] := 'CHARACTER '; MSG[25] := 'CONST ID  ';
|   MSG[26] := 'INDEX TYPE'; MSG[27] := 'INDEXBOUND';
|   MSG[28] := 'NO ARRAY  '; MSG[29] := 'TYPE ID   ';
|   MSG[30] := 'UNDEF TYPE'; MSG[31] := 'NO RECORD ';
|   MSG[32] := 'BOOLE TYPE'; MSG[33] := 'ARITH TYPE';
|   MSG[34] := 'INTEGER   '; MSG[35] := 'TYPES     ';
|   MSG[36] := 'PARAM TYPE'; MSG[37] := 'VARIAB ID ';
|   MSG[38] := 'STRING    '; MSG[39] := 'NO.OF PARS';
|   MSG[40] := 'TYPE      '; MSG[41] := 'TYPE      ';
|   MSG[42] := 'REAL TYPE '; MSG[43] := 'INTEGER   ';
|   MSG[44] := 'VAR, CONST'; MSG[45] := 'VAR, PROC ';
|   MSG[46] := 'TYPES (:=)'; MSG[47] := 'TYP (CASE)';
|   MSG[48] := 'TYPE      '; MSG[49] := 'STORE OVFL';
|   MSG[50] := 'CONSTANT  '; MSG[51] := ':=        ';
|   MSG[52] := 'THEN      '; MSG[53] := 'UNTIL     ';
|   MSG[54] := 'DO        '; MSG[55] := 'TO DOWNTO ';
|   MSG[56] := 'BEGIN     '; MSG[57] := 'END       ';
|   MSG[58] := 'FACTOR    ';
|   K := 0; WRITELN; WRITELN(' KEY WORDS');
|   WHILE ERRS <> [] DO
|   BEGIN WHILE NOT (K IN ERRS) DO K := K+1;
|         WRITELN(K,'  ',MSG[K]); ERRS := ERRS - [K]
|   END
| END (*ERRORMSG*) ;
| 
| 
| PROCEDURE ERROR(N: INTEGER);
| BEGIN IF ERRPOS = 0 THEN WRITE(' ****');
|    IF CC > ERRPOS THEN
|       BEGIN WRITE(' ': CC-ERRPOS, '@', N:2);
|          ERRPOS := CC+3; ERRS := ERRS + [N]
|       END
| END (*ERROR*) ;
| 
| PROCEDURE FATAL(N: INTEGER);
|    VAR MSG: ARRAY [1..7] OF ALFA;
| BEGIN WRITELN; ERRORMSG;
|    MSG[ 1] := 'IDENTIFIER'; MSG[ 2] := 'PROCEDURES';
|    MSG[ 3] := 'REALS     '; MSG[ 4] := 'ARRAYS    ';
|    MSG[ 5] := 'LEVELS    '; MSG[ 6] := 'CODE      ';
|    MSG[ 7] := 'STRINGS   ';
|    WRITELN(' COMPILER TABLE FOR ', MSG[N], ' IS TOO SMALL');
|    (*GOTO 99*)  EXIT(99)    (* TERMINATE COMPILATION*)
| END (*FATAL*) ;
| 
| (* EOF                                                                        *)
| (* #INCLUDE "SCANNER.I"                                                       *)
| (* SCANNER.I                                                                  *)
| PROCEDURE NEXTCH;   (*READ NEXT CHARACTER; PROCESS LINE END*)
| BEGIN IF CC = LL THEN
|       BEGIN IF EOF(INPUT) THEN
|             BEGIN WRITELN;
|                WRITELN(' PROGRAM INCOMPLETE');
|                ERRORMSG; (*GOTO 99*)  EXIT(99)
|             END ;
|          IF ERRPOS <> 0 THEN
|             BEGIN WRITELN; ERRPOS := 0
|             END ;
|          WRITE(LC:6, '  ');
|          LL := 0; CC := 0;
|          WHILE NOT EOLN(INPUT) DO
|             BEGIN LL := LL+1; READ(CH); WRITE(CH); LINE[LL] := CH
|             END ;
|          WRITELN; LL := LL+1; READ(LINE[LL])
|       END ;
|    CC := CC+1; CH := LINE[CC];
| END (*NEXTCH*) ;
| 
| PROCEDURE INSYMBOL;           (*READS NEXT SYMBOL*)
|    LABEL 1,2,3;
|    VAR I,J,K,E: INTEGER;
| 
|    PROCEDURE READSCALE;
|       VAR S, SIGN: INTEGER;
|    BEGIN NEXTCH; SIGN := 1; S := 0;
|       IF CH = '+' THEN NEXTCH ELSE
|       IF CH = '-' THEN BEGIN NEXTCH; SIGN := -1 END ;
|       WHILE CH IN ['0'..'9'] DO
|          BEGIN S := 10*S + ORD(CH) - ORD('0'); NEXTCH
|          END ;
|       E := S*SIGN + E
|    END (*READSCALE*) ;
| 
|    PROCEDURE ADJUSTSCALE;
|       VAR S: INTEGER; D,T: REAL;
|    BEGIN IF K+E > EMAX THEN ERROR(21) ELSE
|          IF K+E < EMIN THEN RNUM := 0 ELSE
|      BEGIN S := ABS(E); T := 1.0; D := 10.0;
|        REPEAT
|          WHILE NOT ODD(S) DO
| #           BEGIN S := S DIV 2; D := D*D (*SQR(D)*)
|             END ;
|          S := S-1; T := D*T
|        UNTIL S = 0;
|        IF E >= 0 THEN RNUM := RNUM*T ELSE RNUM := RNUM/T
|      END
|    END (*ADJUSTSCALE*) ;
| 
| BEGIN (*INSYMBOL*)
| 1: WHILE (CH = ' ') OR (CH = TABCH) DO NEXTCH;
|    IF CH IN ['A'..'Z'] THEN
|    BEGIN (*IDENTIFIER OR WORDSYMBOL*)  K := 0; ID := '          ';
|       REPEAT IF K < ALNG THEN
|              BEGIN K := K+1; ID[K] := CH
|              END ;
|          NEXTCH
|       UNTIL NOT (CH IN ['A'..'Z','0'..'9']);
|       I := 1; J := NKW;   (*BINARY SEARCH*)
|       REPEAT K := (I+J) DIV 2;
|          IF ID <= KEY[K] THEN J := K-1;
|          IF ID >= KEY[K] THEN I := K+1
|       UNTIL I > J;
|       IF I-1 > J THEN SY := KSY[K] ELSE SY := IDENT
|    END ELSE
|    IF CH IN ['0'..'9'] THEN
|    BEGIN (*NUMBER*) K := 0; INUM := 0; SY := INTCON;
|       REPEAT INUM := INUM*10 + ORD(CH) - ORD('0');
|          K := K+1; NEXTCH
|       UNTIL NOT (CH IN ['0'..'9']);
|       IF (K > KMAX) OR (INUM > NMAX) THEN
|         BEGIN ERROR(21); INUM := 0; K := 0
|         END ;
|       IF CH = '.' THEN
|       BEGIN NEXTCH;
|          IF CH = '.' THEN CH := ':' ELSE
|             BEGIN SY := REALCON; RNUM := INUM; E := 0;
|                WHILE CH IN ['0'..'9'] DO
|                BEGIN E := E-1;
|                   RNUM := 10.0*RNUM + (ORD(CH)-ORD('0')); NEXTCH
|                END ;
|                IF CH = 'E' THEN READSCALE;
|                IF E <> 0 THEN ADJUSTSCALE
|             END
|       END ELSE
|       IF CH = 'E' THEN
|       BEGIN SY := REALCON; RNUM := INUM; E := 0;
|          READSCALE; IF E <> 0 THEN ADJUSTSCALE
|       END ;
|    END ELSE
|    CASE CH OF
| ':' : BEGIN NEXTCH;
|           IF CH = '=' THEN
|             BEGIN SY := BECOMES; NEXTCH
|             END  ELSE SY := COLON
|       END ;
| '<' : BEGIN NEXTCH;
|          IF CH = '=' THEN BEGIN SY := LEQ; NEXTCH END ELSE
|          IF CH = '>' THEN BEGIN SY := NEQ; NEXTCH END ELSE SY := LSS
|       END ;
| '>' : BEGIN NEXTCH;
|          IF CH = '=' THEN BEGIN SY := GEQ; NEXTCH END ELSE SY := GTR
|       END ;
| '.' : BEGIN NEXTCH;
|          IF CH = '.' THEN
|             BEGIN SY := COLON; NEXTCH
|             END  ELSE SY := PERIOD
|       END ;
| '''': BEGIN K := 0;
|     2:  NEXTCH;
|         IF CH = '''' THEN
|           BEGIN NEXTCH; IF CH <> '''' THEN GOTO 3
|           END ;
|         IF SX+K = SMAX THEN FATAL(7);
|         STAB[SX+K] := CH; K := K+1;
|         IF CC = 1 THEN
|           BEGIN (*END OF LINE*) K := 0;
|           END
|         ELSE GOTO 2;
|     3:  IF K = 1 THEN
|            BEGIN SY := CHARCON; INUM := ORD(STAB[SX])
|            END ELSE
|         IF K = 0 THEN
|            BEGIN ERROR(38); SY := CHARCON; INUM := 0
|            END ELSE
|            BEGIN SY := STRING; INUM := SX; SLENG := K; SX := SX+K
|            END
|       END ;
| '(' : BEGIN NEXTCH;
|          IF CH <> '*' THEN SY := LPARENT ELSE
|          BEGIN (*COMMENT*) NEXTCH;
|             REPEAT
|                WHILE CH <> '*' DO NEXTCH;
|                NEXTCH
|             UNTIL CH = ')';
|             NEXTCH; GOTO 1
|          END
|       END ;
| '+', '-', '*', '/', ')', '=', ',', '[', ']', '#', '&', ';' :
|       BEGIN SY := SPS[CH]; NEXTCH
|       END ;
| '$', (*'\',*) '×', (*'?',*) '@', '_', '"', '^' :
|       BEGIN ERROR(24); NEXTCH; GOTO 1
|       END
|    END;
| END (*INSYMBOL*) ;
| 
| (* EOF                                                                        *)
| (* #INCLUDE "TABLES.I"                                                        *)
| (* TABLES.I                                                                   *)
| PROCEDURE ENTER(X0: ALFA; X1: OBJECT;
|                 X2: TYPES; X3: INTEGER);
| BEGIN T := T+1;   (*ENTER STANDARD IDENTIFIER*)
|    WITH TAB[T] DO
|    BEGIN NAME := X0; LINK := T-1; OBJ := X1;
|       TYP := X2; REF := 0; NORMAL := TRUE;
|       LEV := 0; ADR := X3
|    END
| END (*ENTER*) ;
| 
| PROCEDURE ENTERARRAY(TP: TYPES; L,H: INTEGER);
| BEGIN IF L > H THEN ERROR(27);
|    IF (ABS(L)>XMAX) OR (ABS(H)>XMAX) THEN
|       BEGIN ERROR(27); L := 0; H := 0;
|       END ;
|    IF A = AMAX THEN FATAL(4) ELSE
|       BEGIN A := A+1;
|         WITH ATAB[A] DO
|             BEGIN INXTYP := TP; LOW := L; HIGH := H
|             END
|       END
| END (*ENTERARRAY*) ;
| 
| PROCEDURE ENTERBLOCK;
| BEGIN IF B = BMAX THEN FATAL(2) ELSE
|       BEGIN B := B+1; BTAB[B].LAST := 0; BTAB[B].LASTPAR := 0
|       END
| END (*ENTERBLOCK*) ;
| 
| PROCEDURE ENTERREAL(X: REAL);
| BEGIN IF C2 = C2MAX-1 THEN FATAL(3) ELSE
|       BEGIN RCONST[C2+1] := X; C1 := 1;
|          WHILE RCONST[C1] <> X DO  C1 := C1+1;
|          IF C1 > C2 THEN C2 := C1
|       END
| END (*ENTERREAL*) ;
| 
| PROCEDURE EMIT(FCT: INTEGER);
| BEGIN IF LC = CMAX THEN FATAL(6);
|    CODE[LC].F := FCT; LC := LC+1
| END (*EMIT*) ;
| 
| PROCEDURE EMIT1(FCT,B: INTEGER);
| BEGIN IF LC = CMAX THEN FATAL(6);
|    WITH CODE[LC] DO
|       BEGIN F := FCT; Y := B END ;
|    LC := LC+1
| END (*EMIT1*) ;
| 
| PROCEDURE EMIT2(FCT,A,B: INTEGER);
| BEGIN IF LC = CMAX THEN FATAL(6);
|    WITH CODE[LC] DO
|      BEGIN F := FCT; X := A; Y := B END ;
|    LC := LC+1
| END (*EMIT2*) ;
| 
| PROCEDURE PRINTTABLES;
|    VAR I: INTEGER; O: ORDER;
| BEGIN
|    WRITELN('0IDENTIFIERS          LINK', '  OBJ  TYP  REF  NRM  LEV  ADR');
|    FOR I := BTAB[1].LAST +1 TO T DO
|       WITH TAB[I] DO
|       WRITELN(I,' ',NAME,LINK:5, ORD(OBJ):5, ORD(TYP):5, REF:5,
|             ORD(NORMAL):5, LEV:5, ADR:5);
|    WRITELN('0BLOCKS    LAST LPAR PSZE VSZE');
|    FOR I := 1 TO B DO
|       WITH BTAB[I] DO
|       WRITELN(I, LAST:5, LASTPAR:5, PSIZE:5, VSIZE:5);
|    WRITELN('0ARRAYS    XTYP ETYP EREF  LOW HIGH ELSZ SIZE');
|    FOR I := 1 TO A DO
|       WITH ATAB[I] DO
|       WRITELN(I, ORD(INXTYP):5, ORD(ELTYP):5,
|               ELREF:5, LOW:5, HIGH:5, ELSIZE:5, SIZE:5);
|    WRITELN('0CODE:');
|    FOR I := 0 TO LC-1 DO
|    BEGIN IF I MOD 5 = 0 THEN
|          BEGIN WRITELN; WRITE(I:5)
|          END ;
|       O := CODE[I]; WRITE(O.F:5);
|       IF O.F < 31 THEN
|         IF O.F < 4 THEN WRITE(O.X:2, O.Y:5)
|                     ELSE WRITE(O.Y:7)
|       ELSE WRITE('       ');
|       WRITE(',')
|    END ;
|    WRITELN;
| END (*PRINTTABLES*) ;
| 
| (* EOF                                                                        *)
| (* #INCLUDE "BLOCK.I"                                                         *)
| (* BLOCK.I                                                                    *)
| PROCEDURE BLOCK(FSYS: SYMSET; ISFUN: BOOLEAN; LEVEL: INTEGER);
| 
|    TYPE CONREC =
|       RECORD CASE TP: TYPES OF
|          INTS,CHARS,BOOLS: (I: INTEGER);
|          REALS: (R: REAL)
|       END ;
| 
|    VAR DX: INTEGER;    (*DATA ALLOCATION INDEX*)
|        PRT: INTEGER;   (*T-INDEX OF THIS PROCEDURE*)
|        PRB: INTEGER;   (*B-INDEX OF THIS PROCEDURE*)
|        X: INTEGER;
|    PROCEDURE SKIP(FSYS: SYMSET; N: INTEGER);
|    BEGIN ERROR(N);
|       WHILE NOT (SY IN FSYS) DO INSYMBOL
|    END (*SKIP*) ;
| 
|    PROCEDURE TEST(S1,S2: SYMSET; N: INTEGER);
|    BEGIN IF NOT (SY IN S1) THEN
|          SKIP(S1+S2,N)
|    END (*TEST*) ;
| 
|    PROCEDURE TESTSEMICOLON;
|    BEGIN
|      IF SY = SEMICOLON THEN INSYMBOL ELSE
|      BEGIN ERROR(14);
|        IF SY IN [COMMA,COLON] THEN INSYMBOL
|      END ;
|      TEST([IDENT]+BLOCKBEGSYS, FSYS, 6)
|    END (*TESTSEMICOLON*) ;
| 
|    PROCEDURE ENTER(ID: ALFA; K: OBJECT);
|       VAR J,L: INTEGER;
|    BEGIN IF T = TMAX THEN FATAL(1) ELSE
|          BEGIN TAB[0].NAME := ID;
|             J := BTAB[DISPLAY[LEVEL]].LAST;  L := J;
|             WHILE TAB[J].NAME <> ID DO  J := TAB[J].LINK;
|             IF J <> 0 THEN ERROR(1) ELSE
|             BEGIN T := T+1;
|               WITH TAB[T] DO
|               BEGIN NAME := ID; LINK := L;
|                OBJ := K; TYP := NOTYP; REF := 0; LEV := LEVEL; ADR := 0
|               END ;
|               BTAB[DISPLAY[LEVEL]].LAST := T
|             END
|          END
|    END (*ENTER*) ;
| 
|    FUNCTION LOC(ID: ALFA): INTEGER;
|       VAR I,J: INTEGER;     (*LOCATE ID IN TABLE*)
|    BEGIN I := LEVEL; TAB[0].NAME := ID;   (*SENTINEL*)
|       REPEAT J := BTAB[DISPLAY[I]].LAST;
|          WHILE TAB[J].NAME <> ID DO  J := TAB[J].LINK;
|          I := I-1;
|       UNTIL (I<0) OR (J<>0);
|       IF J = 0 THEN ERROR(0);  LOC := J
|    END (*LOC*) ;
| 
|   PROCEDURE ENTERVARIABLE;
|   BEGIN IF SY = IDENT THEN
|           BEGIN ENTER(ID,VARIABLE); INSYMBOL
|           END
|         ELSE ERROR(2)
|   END (*ENTERVARIABLE*) ;
| 
|    PROCEDURE CONSTANT(FSYS: SYMSET; VAR C: CONREC);
|      VAR X, SIGN: INTEGER;
|    BEGIN C.TP := NOTYP; C.I := 0;
|      TEST(CONSTBEGSYS, FSYS, 50);
|      IF SY IN CONSTBEGSYS THEN
|      BEGIN
|          IF SY = CHARCON THEN
|            BEGIN C.TP := CHARS; C.I := INUM; INSYMBOL
|            END
|          ELSE
|            BEGIN SIGN := 1;
|              IF SY IN [PLUS,MINUS] THEN
|                BEGIN IF SY = MINUS THEN SIGN := -1;
|                  INSYMBOL
|                END ;
|              IF SY = IDENT THEN
|                BEGIN X := LOC(ID);
|                  IF X <> 0 THEN
|                    IF TAB[X].OBJ <> KONSTANT THEN ERROR(25) ELSE
|                    BEGIN C.TP := TAB[X].TYP;
|                      IF C.TP = REALS THEN C.R := SIGN*RCONST[TAB[X].ADR]
|                                      ELSE C.I := SIGN*TAB[X].ADR
|                    END ;
|                  INSYMBOL
|                END
|              ELSE
|              IF SY = INTCON THEN
|                BEGIN C.TP := INTS; C.I := SIGN*INUM; INSYMBOL
|                END ELSE
|              IF SY = REALCON THEN
|                BEGIN C.TP := REALS; C.R := SIGN*RNUM; INSYMBOL
|                END ELSE SKIP(FSYS,50)
|            END;
|          TEST(FSYS, [], 6)
|        END
|    END (*CONSTANT*) ;
|    PROCEDURE TYP(FSYS: SYMSET; VAR TP: TYPES; VAR RF, SZ: INTEGER);
|      VAR X: INTEGER;
|          ELTP: TYPES; ELRF: INTEGER;
|          ELSZ, OFFSET, T0,T1: INTEGER;
| 
|      PROCEDURE ARRAYTYP(VAR AREF,ARSZ: INTEGER);
|         VAR ELTP: TYPES;
|            LOW, HIGH: CONREC;
|            ELRF, ELSZ: INTEGER;
|      BEGIN CONSTANT([COLON,RBRACK,RPARENT,OFSY]+FSYS, LOW);
|         IF LOW.TP = REALS THEN
|            BEGIN ERROR(27); LOW.TP := INTS; LOW.I := 0
|            END ;
|         IF SY = COLON THEN INSYMBOL ELSE ERROR(13);
|         CONSTANT([RBRACK,COMMA,RPARENT,OFSY]+FSYS, HIGH);
|         IF HIGH.TP <> LOW.TP THEN
|            BEGIN ERROR(27); HIGH.I := LOW.I
|            END ;
|         ENTERARRAY(LOW.TP, LOW.I, HIGH.I); AREF := A;
|         IF SY = COMMA THEN
|            BEGIN INSYMBOL; ELTP := ARRAYS; ARRAYTYP(ELRF,ELSZ)
|            END ELSE
|         BEGIN
|            IF SY = RBRACK THEN INSYMBOL ELSE
|               BEGIN ERROR(12);
|                  IF SY = RPARENT THEN INSYMBOL
|               END ;
|            IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
|            TYP(FSYS,ELTP,ELRF,ELSZ)
|         END ;
|         WITH ATAB[AREF] DO
|         BEGIN ARSZ := (HIGH-LOW+1)*ELSZ; SIZE := ARSZ;
|            ELTYP := ELTP; ELREF := ELRF; ELSIZE := ELSZ
|         END ;
|      END (*ARRAYTYP*) ;
| 
|    BEGIN (*TYP*) TP := NOTYP; RF := 0; SZ := 0;
|      TEST(TYPEBEGSYS, FSYS, 10);
|      IF SY IN TYPEBEGSYS THEN
|        BEGIN
|          IF SY = IDENT THEN
|          BEGIN X := LOC(ID);
|            IF X <> 0 THEN
|            WITH TAB[X] DO
|              IF OBJ <> TYPE1 THEN ERROR(29) ELSE
|              BEGIN TP := TYP; RF := REF; SZ := ADR;
|                IF TP = NOTYP THEN ERROR(30)
|              END ;
|            INSYMBOL
|          END ELSE
|          IF SY = ARRAYSY THEN
|          BEGIN INSYMBOL;
|              IF SY = LBRACK THEN INSYMBOL ELSE
|                 BEGIN ERROR(11);
|                    IF SY = LPARENT THEN INSYMBOL
|                 END ;
|              TP := ARRAYS; ARRAYTYP(RF,SZ)
|          END ELSE
|          BEGIN (*RECORDS*) INSYMBOL;
|            ENTERBLOCK; TP := RECORDS; RF := B;
|            IF LEVEL = LMAX THEN FATAL(5);
|            LEVEL := LEVEL+1; DISPLAY[LEVEL] := B; OFFSET := 0;
|            WHILE SY <> ENDSY DO
|            BEGIN (*FIELD SECTION*)
|              IF SY = IDENT THEN
|              BEGIN T0 := T; ENTERVARIABLE;
|                WHILE SY = COMMA DO
|                  BEGIN INSYMBOL; ENTERVARIABLE
|                  END ;
|                IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
|                T1 := T;
|                TYP(FSYS+[SEMICOLON,ENDSY,COMMA,IDENT],ELTP,ELRF,ELSZ);
|                WHILE T0 < T1 DO
|                BEGIN T0 := T0+1;
|                  WITH TAB[T0] DO
|                  BEGIN TYP := ELTP; REF := ELRF; NORMAL := TRUE;
|                    ADR := OFFSET; OFFSET := OFFSET + ELSZ
|                  END
|                END
|              END ;
|              IF SY <> ENDSY THEN
|              BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE
|                    BEGIN ERROR(14);
|                      IF SY = COMMA THEN INSYMBOL
|                    END ;
|                 TEST([IDENT,ENDSY,SEMICOLON], FSYS, 6)
|              END
|            END ;
|            BTAB[RF].VSIZE := OFFSET; SZ := OFFSET; BTAB[RF].PSIZE := 0;
|            INSYMBOL; LEVEL := LEVEL-1
|          END ;
|          TEST(FSYS, [], 6)
|        END
|    END (*TYP*) ;
| 
|    PROCEDURE PARAMETERLIST;     (*FORMAL PARAMETER LIST*)
|       VAR TP: TYPES;
|           RF, SZ, X, T0: INTEGER;
|           VALPAR: BOOLEAN;
|    BEGIN INSYMBOL; TP := NOTYP; RF := 0; SZ := 0;
|      TEST([IDENT, VARSY], FSYS+[RPARENT], 7);
|      WHILE SY IN [IDENT,VARSY] DO
|        BEGIN IF SY <> VARSY THEN VALPAR := TRUE ELSE
|                BEGIN INSYMBOL; VALPAR := FALSE
|                END ;
|          T0 := T; ENTERVARIABLE;
|          WHILE SY = COMMA DO
|             BEGIN INSYMBOL; ENTERVARIABLE;
|             END ;
|          IF SY = COLON THEN
|            BEGIN INSYMBOL;
|              IF SY <> IDENT THEN ERROR(2) ELSE
|              BEGIN X := LOC(ID); INSYMBOL;
|                IF X <> 0 THEN
|                WITH TAB[X] DO
|                  IF OBJ <> TYPE1 THEN ERROR(29) ELSE
|                    BEGIN TP := TYP; RF := REF;
|                      IF VALPAR THEN SZ := ADR ELSE SZ := 1
|                    END ;
|              END ;
|              TEST([SEMICOLON,RPARENT], [COMMA,IDENT]+FSYS, 14)
|            END
|          ELSE ERROR(5);
|          WHILE T0 < T DO
|          BEGIN T0 := T0+1;
|            WITH TAB[T0] DO
|            BEGIN TYP := TP; REF := RF;
|                NORMAL := VALPAR; ADR := DX; LEV := LEVEL;
|                DX := DX + SZ
|            END
|          END ;
|          IF SY <> RPARENT THEN
|          BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE
|                BEGIN ERROR(14);
|                  IF SY = COMMA THEN INSYMBOL
|                END ;
|             TEST([IDENT,VARSY], [RPARENT]+FSYS, 6)
|          END
|        END (*WHILE*) ;
|      IF SY = RPARENT THEN
|        BEGIN INSYMBOL;
|          TEST([SEMICOLON,COLON], FSYS, 6)
|        END
|      ELSE ERROR(4)
|    END (*PARAMETERLIST*) ;
| 
|    PROCEDURE CONSDECLARATION;
|      VAR C: CONREC;
|    BEGIN INSYMBOL;
|      TEST([IDENT], BLOCKBEGSYS, 2);
|      WHILE SY = IDENT DO
|        BEGIN ENTER(ID,KONSTANT); INSYMBOL;
|          IF SY = EQL THEN INSYMBOL ELSE
|             BEGIN ERROR(16);
|                IF SY = BECOMES THEN INSYMBOL
|             END ;
|          CONSTANT([SEMICOLON,COMMA,IDENT]+FSYS,C);
|          TAB[T].TYP := C.TP; TAB[T].REF := 0;
|          IF C.TP = REALS THEN
|            BEGIN ENTERREAL(C.R); TAB[T].ADR := C1 END
|          ELSE TAB[T].ADR := C.I;
|          TESTSEMICOLON
|        END
|    END (*CONSDECLARATION*) ;
| 
|    PROCEDURE TYPEDECLARATION;
|      VAR TP: TYPES; RF, SZ, T1: INTEGER;
|    BEGIN INSYMBOL;
|      TEST([IDENT], BLOCKBEGSYS, 2);
|      WHILE SY = IDENT DO
|        BEGIN ENTER(ID,TYPE1); T1 := T; INSYMBOL;
|          IF SY = EQL THEN INSYMBOL ELSE
|             BEGIN ERROR(16);
|                IF SY = BECOMES THEN INSYMBOL
|             END ;
|          TYP([SEMICOLON,COMMA,IDENT]+FSYS, TP, RF, SZ);
|          WITH TAB[T1] DO
|            BEGIN TYP := TP; REF := RF; ADR := SZ
|            END ;
|          TESTSEMICOLON
|        END
|    END (*TYPEDECLARATION*) ;
| 
|    PROCEDURE VARDECLARATION;
|      VAR T0, T1, RF, SZ: INTEGER;
|          TP: TYPES;
|    BEGIN INSYMBOL;
|      WHILE SY = IDENT DO
|      BEGIN T0 := T; ENTERVARIABLE;
|        WHILE SY = COMMA DO
|          BEGIN INSYMBOL; ENTERVARIABLE;
|          END ;
|        IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
|        T1 := T;
|        TYP([SEMICOLON,COMMA,IDENT]+FSYS, TP, RF, SZ);
|        WHILE T0 < T1 DO
|        BEGIN T0 := T0+1;
|          WITH TAB[T0] DO
|          BEGIN TYP := TP; REF := RF;
|            LEV := LEVEL; ADR := DX; NORMAL := TRUE;
|            DX := DX + SZ
|          END
|        END ;
|        TESTSEMICOLON
|      END
|    END (*VARDECLARATION*) ;
| 
|    PROCEDURE PROCDECLARATION;
|       VAR ISFUN: BOOLEAN;
|    BEGIN ISFUN := SY = FUNCSY; INSYMBOL;
|      IF SY <> IDENT THEN
|         BEGIN  ERROR(2); ID := '          '
|         END ;
|      IF ISFUN THEN ENTER(ID,FUNKTION) ELSE ENTER(ID,PROZEDURE);
|      TAB[T].NORMAL := TRUE;
|      INSYMBOL; BLOCK([SEMICOLON]+FSYS, ISFUN, LEVEL+1);
|      IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
|      EMIT(32+ORD(ISFUN))    (*EXIT*)
|    END (*PROCEDUREDECLARATION*) ;
| 
| (*---------------------------------------------------------STATEMENT--*)
| 
|    PROCEDURE STATEMENT(FSYS: SYMSET);
|       VAR I: INTEGER;
|       PROCEDURE EXPRESSION(FSYS: SYMSET; VAR X: ITEM); FORWARD;
| 
|       PROCEDURE SELECTOR(FSYS: SYMSET; VAR V:ITEM);
|          VAR X: ITEM; A,J: INTEGER;
|       BEGIN (*SY IN [LPARENT, LBRACK, PERIOD]*)
|         REPEAT
|           IF SY = PERIOD THEN
|           BEGIN INSYMBOL;  (*FIELD SELECTOR*)
|             IF SY <> IDENT THEN ERROR(2) ELSE
|             BEGIN
|               IF V.TYP <> RECORDS THEN ERROR(31) ELSE
|               BEGIN (*SEARCH FIELD IDENTIFIER*)
|                 J := BTAB[V.REF] .LAST; TAB[0].NAME := ID;
|                 WHILE TAB[J].NAME <> ID DO J := TAB[J].LINK;
|                 IF J = 0 THEN ERROR(0);
|                 V.TYP := TAB[J].TYP; V.REF := TAB[J].REF;
|                 A := TAB[J].ADR; IF A <> 0 THEN EMIT1(9,A)
|               END ;
|               INSYMBOL
|             END
|           END ELSE
|           BEGIN (*ARRAY SELECTOR*)
|             IF SY <> LBRACK THEN ERROR(11);
|             REPEAT INSYMBOL;
|               EXPRESSION(FSYS+[COMMA,RBRACK], X);
|               IF V.TYP <> ARRAYS THEN ERROR(28) ELSE
|                 BEGIN A := V.REF;
|                   IF ATAB[A].INXTYP <> X.TYP THEN ERROR(26) ELSE
|                 IF ATAB[A].ELSIZE = 1 THEN EMIT1(20,A) ELSE EMIT1(21,A);
|                   V.TYP := ATAB[A].ELTYP; V.REF := ATAB[A].ELREF
|                 END
|             UNTIL SY <> COMMA;
|             IF SY = RBRACK THEN INSYMBOL ELSE
|               BEGIN ERROR(12); IF SY = RPARENT THEN INSYMBOL
|               END
|           END
|         UNTIL NOT (SY IN [LBRACK,LPARENT,PERIOD]);
|         TEST(FSYS, [], 6)
|       END (*SELECTOR*) ;
| 
|       PROCEDURE CALL(FSYS: SYMSET; I: INTEGER);
|          VAR X: ITEM;
|              LASTP, CP, K: INTEGER;
|       BEGIN EMIT1(18,I);  (*MARK STACK*)
|         LASTP := BTAB[TAB[I].REF].LASTPAR; CP := I;
|         IF SY = LPARENT THEN
|         BEGIN (*ACTUAL PARAMETER LIST*)
|           REPEAT INSYMBOL;
|             IF CP >= LASTP THEN ERROR(39) ELSE
|             BEGIN CP := CP+1;
|               IF TAB[CP].NORMAL THEN
|               BEGIN (*VALUE PARAMETER*)
|                 EXPRESSION(FSYS+[COMMA,COLON,RPARENT], X);
|                 IF X.TYP=TAB[CP].TYP THEN
|                   BEGIN
|                     IF X.REF <> TAB[CP].REF THEN ERROR(36) ELSE
|                   IF X.TYP = ARRAYS THEN EMIT1(22,ATAB[X.REF].SIZE) ELSE
|                     IF X.TYP = RECORDS THEN EMIT1(22,BTAB[X.REF].VSIZE)
|                   END ELSE
|                 IF (X.TYP=INTS) AND (TAB[CP].TYP=REALS) THEN
|                    EMIT1(26,0) ELSE
|                    IF X.TYP<>NOTYP THEN ERROR(36);
|               END ELSE
|               BEGIN (*VARIABLE PARAMETER*)
|                 IF SY <> IDENT THEN ERROR(2) ELSE
|                 BEGIN K := LOC(ID); INSYMBOL;
|                   IF K <> 0 THEN
|                   BEGIN IF TAB[K].OBJ <> VARIABLE THEN ERROR(37);
|                     X.TYP := TAB[K].TYP; X.REF := TAB[K].REF;
|                     IF TAB[K].NORMAL THEN EMIT2(0,TAB[K].LEV,TAB[K].ADR)
|                        ELSE EMIT2(1,TAB[K].LEV,TAB[K].ADR);
|                     IF SY IN [LBRACK,LPARENT,PERIOD] THEN
|                        SELECTOR(FSYS+[COMMA,COLON,RPARENT], X);
|                     IF (X.TYP<>TAB[CP].TYP) OR (X.REF<>TAB[CP].REF) THEN
|                        ERROR(36)
|                   END
|                 END
|               END
|             END ;
|             TEST([COMMA,RPARENT], FSYS, 6)
|           UNTIL SY <> COMMA;
|           IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
|         END ;
|         IF CP < LASTP THEN ERROR(39); (*TOO FEW ACTUAL PARAMETERS*)
|         EMIT1(19, BTAB[TAB[I].REF].PSIZE-1);
|         IF TAB[I].LEV < LEVEL THEN EMIT2(3, TAB[I].LEV, LEVEL)
|       END (*CALL*) ;
| 
|       FUNCTION RESULTTYPE(A,B: TYPES): TYPES;
|       BEGIN
|         IF (A>REALS) OR (B>REALS) THEN
|           BEGIN ERROR(33); RESULTTYPE := NOTYP
|           END ELSE
|         IF (A=NOTYP) OR (B=NOTYP) THEN RESULTTYPE := NOTYP ELSE
|         IF A=INTS THEN
|           IF B=INTS THEN RESULTTYPE := INTS ELSE
|             BEGIN RESULTTYPE := REALS; EMIT1(26,1)
|             END
|         ELSE
|           BEGIN RESULTTYPE := REALS;
|             IF B=INTS THEN EMIT1(26,0)
|           END
|       END (*RESULTTYPE*) ;
| 
|       PROCEDURE EXPRESSION;
|         VAR Y:ITEM; OP:SYMBOL;
| 
|         PROCEDURE SIMPLEEXPRESSION(FSYS:SYMSET; VAR X:ITEM);
|           VAR Y:ITEM; OP:SYMBOL;
| 
|           PROCEDURE TERM(FSYS:SYMSET; VAR X:ITEM);
|             VAR Y:ITEM; OP:SYMBOL;
| 
|             PROCEDURE FACTOR(FSYS:SYMSET; VAR X:ITEM);
|               VAR I,F: INTEGER;
| 
|               PROCEDURE STANDFCT(N: INTEGER);
|                  VAR TS: TYPSET;
|               BEGIN (*STANDARD FUNCTION NO. N*)
|                 IF SY = LPARENT THEN INSYMBOL ELSE ERROR(9);
|                 IF N < 17 THEN
|                   BEGIN EXPRESSION(FSYS+[RPARENT],X);
|                     CASE N OF
| (*ABS,SQR*)      0,2:  BEGIN TS := [INTS,REALS]; TAB[I].TYP := X.TYP;
|                          IF X.TYP = REALS THEN N := N+1
|                        END ;
| (*ODD,CHR*)      4,5:  TS := [INTS];
| (*ORD*)          6: BEGIN
|             IF X.TYP = INTS THEN N := 19;
|             TS := [INTS,BOOLS,CHARS];
|          END;
| (*SUCC,PRED*)    7,8:  TS := [CHARS];
| (*ROUND,TRUNC*)  9,10,11,12,13,14,15,16:
| (*SIN,COS,...*)        BEGIN TS := [INTS,REALS];
|                          IF X.TYP = INTS THEN EMIT1(26,0)
|                        END ;
|                     END ;
|                     IF X.TYP IN TS THEN EMIT1(8,N) ELSE
|                     IF X.TYP <> NOTYP THEN ERROR(48);
|                   END ELSE
| (*EOF,EOLN*)      BEGIN (*N IN [17,18]*)
|                     IF SY <> IDENT THEN ERROR(2) ELSE
|                     IF ID <> 'INPUT     ' THEN ERROR(0) ELSE INSYMBOL;
|                     EMIT1(8,N);
|                   END ;
|                 X.TYP := TAB[I].TYP;
|                 IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
|               END (*STANDFCT*) ;
| 
|             BEGIN (*FACTOR*) X.TYP := NOTYP; X.REF := 0;
|               TEST(FACBEGSYS, FSYS, 58);
|               WHILE SY IN FACBEGSYS DO
|                 BEGIN
|                   IF SY = IDENT THEN
|                   BEGIN I := LOC(ID); INSYMBOL;
|                     WITH TAB[I] DO
|                     CASE OBJ OF
|               KONSTANT: BEGIN X.TYP := TYP; X.REF := 0;
|          CASE X.TYP OF
|             INTS: EMIT1(24,ADR);
|             REALS: EMIT1(25,ADR);
|             BOOLS: EMIT1(64,ADR);
|             CHARS: EMIT1(65,ADR);
|          END;
|                         END ;
|               VARIABLE: BEGIN X.TYP := TYP; X.REF := REF;
|                           IF SY IN [LBRACK,LPARENT,PERIOD] THEN
|                             BEGIN IF NORMAL THEN F := 0 ELSE F := 1;
|                               EMIT2(F, LEV, ADR);
|                               SELECTOR(FSYS,X);
|                               IF X.TYP IN STANTYPS THEN EMIT(34)
|                             END ELSE
|                             BEGIN
|                               IF X.TYP IN STANTYPS THEN
|                                 IF NORMAL THEN F := 1 ELSE F := 2
|                               ELSE
|                                 IF NORMAL THEN F := 0 ELSE F := 1;
|                               EMIT2(F, LEV, ADR)
|                             END
|                         END ;
|               TYPE1, PROZEDURE:    ERROR(44);
|               FUNKTION :BEGIN X.TYP := TYP;
|                           IF LEV <> 0 THEN CALL(FSYS, I)
|                                 ELSE STANDFCT(ADR)
|                         END
|                     END (*CASE,WITH*)
|                   END ELSE
|                   IF SY IN [CHARCON,INTCON,REALCON] THEN
|                    BEGIN
|                      IF SY = REALCON THEN
|                      BEGIN X.TYP := REALS; ENTERREAL(RNUM);
|                        EMIT1(25, C1)
|                      END ELSE
|          BEGIN
|          IF SY = CHARCON THEN BEGIN
|             X.TYP := CHARS;
|             EMIT1(65, INUM);
|          END ELSE BEGIN
|             X.TYP := INTS;
|             EMIT1(24, INUM);
|          END;
|                      END ;
|                      X.REF := 0; INSYMBOL
|                    END ELSE
|                   IF SY = LPARENT THEN
|                    BEGIN INSYMBOL; EXPRESSION(FSYS+[RPARENT], X);
|                      IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
|                    END ELSE
|                   IF SY = NOTSY THEN
|                    BEGIN INSYMBOL; FACTOR(FSYS,X);
|                      IF X.TYP=BOOLS THEN EMIT(35) ELSE
|                        IF X.TYP<>NOTYP THEN ERROR(32)
|                    END ;
|                   TEST(FSYS, FACBEGSYS, 6)
|                 END (*WHILE*)
|             END (*FACTOR*) ;
| 
|           BEGIN (*TERM*)
|             FACTOR(FSYS+[TIMES,RDIV,IDIV,IMOD,ANDSY], X);
|             WHILE SY IN [TIMES,RDIV,IDIV,IMOD,ANDSY] DO
|               BEGIN OP := SY; INSYMBOL;
|                 FACTOR(FSYS+[TIMES,RDIV,IDIV,IMOD,ANDSY], Y);
|                 IF OP = TIMES THEN
|                 BEGIN X.TYP := RESULTTYPE(X.TYP, Y.TYP);
|                   CASE X.TYP OF
|                     NOTYP: ;
|                     INTS : EMIT(57);
|                     REALS: EMIT(60);
|                   END
|                 END ELSE
|                 IF OP = RDIV THEN
|                 BEGIN
|                   IF X.TYP = INTS THEN
|                     BEGIN EMIT1(26,1); X.TYP := REALS
|                     END ;
|                   IF Y.TYP = INTS THEN
|                     BEGIN EMIT1(26,0); Y.TYP := REALS
|                     END ;
|                   IF (X.TYP=REALS) AND (Y.TYP=REALS) THEN EMIT(61) ELSE
|                     BEGIN IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN
|                             ERROR(33);
|                           X.TYP := NOTYP
|                     END
|                 END ELSE
|                 IF OP = ANDSY THEN
|                 BEGIN IF (X.TYP=BOOLS) AND (Y.TYP=BOOLS) THEN
|                          EMIT(56) ELSE
|                       BEGIN IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN
|                                ERROR(32);
|                          X.TYP := NOTYP
|                       END
|                 END ELSE
|                 BEGIN (*OP IN [IDIV,IMOD]*)
|                   IF (X.TYP=INTS) AND (Y.TYP=INTS) THEN
|                     IF OP=IDIV THEN EMIT(58)
|                                ELSE EMIT(59) ELSE
|                     BEGIN IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN
|                              ERROR(34);
|                           X.TYP := NOTYP
|                     END
|                 END
|               END
|           END (*TERM*) ;
| 
|         BEGIN (*SIMPLEEXPRESSION*)
|           IF SY IN [PLUS,MINUS] THEN
|             BEGIN OP := SY; INSYMBOL;
|               TERM(FSYS+[PLUS,MINUS], X);
|               IF X.TYP > REALS THEN ERROR(33) ELSE
|                 IF OP = MINUS THEN
|          IF X.TYP = REALS THEN
|             EMIT(66)
|          ELSE
|             EMIT(36)
|             END ELSE
|           TERM(FSYS+[PLUS,MINUS,ORSY], X);
|           WHILE SY IN [PLUS,MINUS,ORSY] DO
|             BEGIN OP := SY; INSYMBOL;
|                TERM(FSYS+[PLUS,MINUS,ORSY], Y);
|                IF OP = ORSY THEN
|                BEGIN
|                  IF (X.TYP=BOOLS) AND (Y.TYP=BOOLS) THEN EMIT(51) ELSE
|                    BEGIN IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN
|                             ERROR(32);
|                          X.TYP := NOTYP
|                    END
|                END ELSE
|                BEGIN X.TYP := RESULTTYPE(X.TYP, Y.TYP);
|                  CASE X.TYP OF
|                    NOTYP: ;
|                    INTS : IF OP = PLUS THEN EMIT(52)
|                                    ELSE EMIT(53);
|                    REALS: IF OP = PLUS THEN EMIT(54)
|                                    ELSE EMIT(55)
|                  END
|                END
|             END
|         END (*SIMPLEEXPRESSION*) ;
| 
|       BEGIN (*EXPRESSION*)
|         SIMPLEEXPRESSION(FSYS+[EQL,NEQ,LSS,LEQ,GTR,GEQ], X);
|         IF SY IN [EQL,NEQ,LSS,LEQ,GTR,GEQ] THEN
|           BEGIN OP := SY; INSYMBOL;
|              SIMPLEEXPRESSION(FSYS, Y);
|              IF (X.TYP IN [ NOTYP,INTS,BOOLS,CHARS]) AND (X.TYP = Y.TYP) THEN
|                CASE OP OF
|                  EQL: EMIT(45);
|                  NEQ: EMIT(46);
|                  LSS: EMIT(47);
|                  LEQ: EMIT(48);
|                  GTR: EMIT(49);
|                  GEQ: EMIT(50);
|                END ELSE
|              BEGIN IF X.TYP = INTS THEN
|                      BEGIN X.TYP := REALS; EMIT1(26,1)
|                      END ELSE
|                    IF Y.TYP = INTS THEN
|                      BEGIN Y.TYP := REALS; EMIT1(26,0)
|                      END ;
|                IF (X.TYP=REALS) AND (Y.TYP=REALS) THEN
|                  CASE OP OF
|                    EQL: EMIT(39);
|                    NEQ: EMIT(40);
|                    LSS: EMIT(41);
|                    LEQ: EMIT(42);
|                    GTR: EMIT(43);
|                    GEQ: EMIT(44);
|                  END
|                ELSE ERROR(35)
|              END ;
|              X.TYP := BOOLS
|           END
|       END (*EXPRESSION*) ;
| 
|       PROCEDURE ASSIGNMENT(LV,AD: INTEGER);
|          VAR X,Y: ITEM; F: INTEGER;
|          (*TAB[I].OBJ IN [VARIABLE,PROZEDURE]*)
|       BEGIN X.TYP := TAB[I].TYP; X.REF := TAB[I].REF;
|         IF TAB[I].NORMAL THEN F := 0 ELSE F := 1;
|         EMIT2(F, LV, AD);
|         IF SY IN [LBRACK,LPARENT,PERIOD] THEN
|            SELECTOR([BECOMES,EQL]+FSYS, X);
|         IF SY = BECOMES THEN INSYMBOL ELSE
|           BEGIN ERROR(51); IF SY = EQL THEN INSYMBOL
|           END ;
|         EXPRESSION(FSYS, Y);
|         IF X.TYP = Y.TYP THEN
|           IF X.TYP IN STANTYPS THEN EMIT(38) ELSE
|           IF X.REF <> Y.REF THEN ERROR(46) ELSE
|           IF X.TYP = ARRAYS THEN EMIT1(23, ATAB[X.REF].SIZE)
|                             ELSE EMIT1(23, BTAB[X.REF].VSIZE)
|         ELSE
|         IF (X.TYP=REALS) AND (Y.TYP=INTS) THEN
|           BEGIN EMIT1(26,0); EMIT(38)
|           END ELSE
|           IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN ERROR(46)
|       END (*ASSIGNMENT*) ;
| 
|       PROCEDURE COMPOUNDSTATEMENT;
|       BEGIN INSYMBOL;
|         STATEMENT([SEMICOLON,ENDSY]+FSYS);
|         WHILE SY IN [SEMICOLON]+STATBEGSYS DO
|         BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
|           STATEMENT([SEMICOLON,ENDSY]+FSYS)
|         END ;
|         IF SY = ENDSY THEN INSYMBOL ELSE ERROR(57)
|       END (*COMPOUNDSTATEMENET*) ;
| 
|       PROCEDURE IFSTATEMENT;
|          VAR X: ITEM; LC1,LC2: INTEGER;
|       BEGIN INSYMBOL;
|         EXPRESSION(FSYS+[THENSY,DOSY], X);
|         IF NOT (X.TYP IN [BOOLS,NOTYP]) THEN ERROR(17);
|         LC1 := LC; EMIT(11);  (*JMPC*)
|         IF SY = THENSY THEN INSYMBOL ELSE
|           BEGIN ERROR(52); IF SY = DOSY THEN INSYMBOL
|           END ;
|         STATEMENT(FSYS+[ELSESY]);
|         IF SY = ELSESY THEN
|           BEGIN INSYMBOL; LC2 := LC; EMIT(10);
|             CODE[LC1].Y := LC; STATEMENT(FSYS); CODE[LC2].Y := LC
|           END
|         ELSE CODE[LC1].Y := LC
|       END (*IFSTATEMENT*) ;
| 
|       PROCEDURE CASESTATEMENT;
|         VAR X: ITEM;
|             I,J,K,LC1: INTEGER;
|             CASETAB: ARRAY [1..CSMAX] OF
|                        PACKED RECORD VAL, LC: INDEX END ;
|             EXITTAB: ARRAY [1..CSMAX] OF INTEGER;
| 
|         PROCEDURE CASELABEL;
|           VAR LAB: CONREC; K: INTEGER;
|         BEGIN CONSTANT(FSYS+[COMMA,COLON], LAB);
|           IF LAB.TP <> X.TYP THEN ERROR(47) ELSE
|           IF I = CSMAX THEN FATAL(6) ELSE
|             BEGIN I := I+1; K := 0;
|               CASETAB[I].VAL := LAB.I; CASETAB[I].LC := LC;
|               REPEAT K := K+1 UNTIL CASETAB[K].VAL = LAB.I;
|               IF K < I THEN ERROR(1);   (*MULTIPLE DEFINITION*)
|             END
|         END (*CASELABEL*) ;
| 
|         PROCEDURE ONECASE;
|         BEGIN IF SY IN CONSTBEGSYS THEN
|           BEGIN CASELABEL;
|             WHILE SY = COMMA DO
|               BEGIN INSYMBOL; CASELABEL
|               END ;
|             IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
|             STATEMENT([SEMICOLON,ENDSY]+FSYS);
|             J := J+1; EXITTAB[J] := LC; EMIT(10)
|           END
|         END (*ONECASE*) ;
| 
|       BEGIN INSYMBOL; I := 0; J := 0;
|         EXPRESSION(FSYS+[OFSY,COMMA,COLON], X);
|         IF NOT (X.TYP IN [INTS,BOOLS,CHARS,NOTYP]) THEN ERROR(23);
|         LC1 := LC; EMIT(12);  (*JMPX*)
|         IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
|         ONECASE;
|         WHILE SY = SEMICOLON DO
|           BEGIN INSYMBOL; ONECASE
|           END ;
|         CODE[LC1].Y := LC;
|         FOR K := 1 TO I DO
|           BEGIN EMIT1(13,CASETAB[K].VAL); EMIT1(13,CASETAB[K].LC)
|           END ;
|         EMIT1(10,0);
|         FOR K := 1 TO J DO CODE[EXITTAB[K]].Y := LC;
|         IF SY = ENDSY THEN INSYMBOL ELSE ERROR(57)
|       END (*CASESTATEMENT*) ;
| 
|       PROCEDURE REPEATSTATEMENT;
|          VAR X: ITEM; LC1: INTEGER;
|       BEGIN LC1 := LC;
|         INSYMBOL; STATEMENT([SEMICOLON,UNTILSY]+FSYS);
|         WHILE SY IN [SEMICOLON]+STATBEGSYS DO
|         BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
|           STATEMENT([SEMICOLON,UNTILSY]+FSYS)
|         END ;
|         IF SY = UNTILSY THEN
|           BEGIN INSYMBOL; EXPRESSION(FSYS, X);
|             IF NOT (X.TYP IN [BOOLS,NOTYP]) THEN ERROR(17);
|             EMIT1(11,LC1)
|           END
|         ELSE ERROR(53)
|       END (*REPEATSTATEMENT*) ;
| 
|       PROCEDURE WHILESTATEMENT;
|          VAR X: ITEM; LC1,LC2: INTEGER;
|       BEGIN INSYMBOL; LC1 := LC;
|         EXPRESSION(FSYS+[DOSY], X);
|         IF NOT (X.TYP IN [BOOLS,NOTYP]) THEN ERROR(17);
|         LC2 := LC; EMIT(11);
|         IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
|         STATEMENT(FSYS); EMIT1(10,LC1); CODE[LC2].Y := LC
|       END (*WHILESTATEMENT*) ;
| 
|       PROCEDURE FORSTATEMENT;
|          VAR CVT: TYPES; X: ITEM;
|              I,F,LC1,LC2: INTEGER;
|       BEGIN INSYMBOL;
|         IF SY = IDENT THEN
|           BEGIN I := LOC(ID); INSYMBOL;
|             IF I = 0 THEN CVT := INTS ELSE
|             IF TAB[I].OBJ = VARIABLE THEN
|               BEGIN CVT := TAB[I].TYP;
|                 IF NOT TAB[I].NORMAL THEN ERROR(37) ELSE
|                   EMIT2(0, TAB[I].LEV, TAB[I].ADR);
|                 IF NOT (CVT IN [NOTYP,INTS,BOOLS,CHARS]) THEN ERROR(18)
|               END ELSE
|               BEGIN ERROR(37); CVT := INTS
|               END
|           END ELSE SKIP([BECOMES,TOSY,DOWNTOSY,DOSY]+FSYS, 2);
|         IF SY = BECOMES THEN
|           BEGIN INSYMBOL; EXPRESSION([TOSY,DOWNTOSY,DOSY]+FSYS, X);
|             IF X.TYP <> CVT THEN ERROR(19);
|           END ELSE SKIP([TOSY,DOWNTOSY,DOSY]+FSYS, 51);
|         F := 14;
|         IF SY IN [TOSY, DOWNTOSY] THEN
|           BEGIN IF SY = DOWNTOSY THEN F := 16;
|             INSYMBOL; EXPRESSION([DOSY]+FSYS, X);
|             IF X.TYP <> CVT THEN ERROR(19)
|           END ELSE SKIP([DOSY]+FSYS, 55);
|         LC1 := LC; EMIT(F);
|         IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
|         LC2 := LC; STATEMENT(FSYS);
|         EMIT1(F+1,LC2); CODE[LC1].Y := LC
|       END (*FORSTATEMENT*) ;
| 
|       PROCEDURE STANDPROC(N: INTEGER);
|          VAR I,F: INTEGER;
|              X,Y: ITEM;
|       BEGIN
|         CASE N OF
|    1,2: BEGIN (*READ*)
|           IF NOT IFLAG THEN
|             BEGIN ERROR(20); IFLAG := TRUE
|             END ;
|           IF SY = LPARENT THEN
|           BEGIN
|             REPEAT INSYMBOL;
|               IF SY <> IDENT THEN ERROR(2) ELSE
|               BEGIN I := LOC(ID); INSYMBOL;
|                 IF I <> 0 THEN
|                 IF TAB[I].OBJ <> VARIABLE THEN ERROR(37) ELSE
|                 BEGIN X.TYP := TAB[I].TYP; X.REF := TAB[I].REF;
|                   IF TAB[I].NORMAL THEN F := 0 ELSE F := 1;
|                   EMIT2(F, TAB[I].LEV, TAB[I].ADR);
|                   IF SY IN [LBRACK,LPARENT,PERIOD] THEN
|                     SELECTOR(FSYS+[COMMA,RPARENT], X);
|                   IF X.TYP IN [INTS,REALS,CHARS,NOTYP] THEN
|                     EMIT1(27, ORD(X.TYP)) ELSE ERROR(40)
|                 END
|               END ;
|               TEST([COMMA,RPARENT], FSYS, 6);
|             UNTIL SY <> COMMA;
|             IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
|           END ;
|           IF N = 2 THEN EMIT(62)
|         END ;
|    3,4: BEGIN (*WRITE*)
|           IF SY = LPARENT THEN
|           BEGIN
|             REPEAT INSYMBOL;
|               IF SY = STRING THEN
|                 BEGIN EMIT1(24,SLENG); EMIT1(28,INUM); INSYMBOL
|                 END ELSE
|               BEGIN EXPRESSION(FSYS+[COMMA,COLON,RPARENT], X);
|                 IF NOT (X.TYP IN STANTYPS) THEN ERROR(41);
|                 IF SY = COLON THEN
|                 BEGIN INSYMBOL;
|                   EXPRESSION(FSYS+[COMMA,COLON,RPARENT], Y);
|                   IF Y.TYP <> INTS THEN ERROR(43);
|                   IF SY = COLON THEN
|                   BEGIN IF X.TYP <> REALS THEN ERROR(42);
|                     INSYMBOL; EXPRESSION(FSYS+[COMMA,RPARENT], Y);
|                     IF Y.TYP <> INTS THEN ERROR(43);
|                     EMIT(37)
|                   END
|                   ELSE EMIT1(30, ORD(X.TYP))
|                 END
|                 ELSE EMIT1(29, ORD(X.TYP))
|               END
|             UNTIL SY <> COMMA;
|             IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
|           END ;
|           IF N = 4 THEN EMIT(63)
|         END ;
|         END (*CASE*)
|       END (*STANDPROC*) ;
| 
|     BEGIN (*STATEMENT*)
|       IF SY IN STATBEGSYS+[IDENT] THEN
|           CASE SY OF
|             IDENT:    BEGIN I := LOC(ID); INSYMBOL;
|                         IF I <> 0 THEN
|                         CASE TAB[I].OBJ OF
|                           KONSTANT, TYPE1: ERROR(45);
|                           VARIABLE: ASSIGNMENT(TAB[I].LEV, TAB[I].ADR);
|                           PROZEDURE:
|                             IF TAB[I].LEV <> 0 THEN CALL(FSYS, I)
|                                     ELSE STANDPROC(TAB[I].ADR);
|                           FUNKTION:
|                             IF TAB[I].REF = DISPLAY[LEVEL] THEN
|                               ASSIGNMENT(TAB[I].LEV+1, 0) ELSE ERROR(45)
|                         END
|                       END ;
|             BEGINSY:  COMPOUNDSTATEMENT;
|             IFSY:     IFSTATEMENT;
|             CASESY:   CASESTATEMENT;
|             WHILESY:  WHILESTATEMENT;
|             REPEATSY: REPEATSTATEMENT;
|             FORSY:    FORSTATEMENT;
|           END;
|         TEST(FSYS, [], 14)
|     END (*STATEMENT*) ;
| 
| BEGIN (*BLOCK*) DX := 5; PRT := T;
|   IF LEVEL > LMAX THEN FATAL(5);
|   TEST([LPARENT,COLON,SEMICOLON], FSYS, 7);
|   ENTERBLOCK; DISPLAY[LEVEL] := B; PRB := B;
|   TAB[PRT].TYP := NOTYP; TAB[PRT].REF := PRB;
|   IF SY = LPARENT THEN PARAMETERLIST;
|   BTAB[PRB].LASTPAR := T; BTAB[PRB].PSIZE := DX;
|   IF ISFUN THEN
|     IF SY = COLON THEN
|     BEGIN INSYMBOL;   (*FUNCTION TYPE*)
|       IF SY = IDENT THEN
|       BEGIN X := LOC(ID); INSYMBOL;
|         IF X <> 0 THEN
|           IF TAB[X].OBJ <> TYPE1 THEN ERROR(29) ELSE
|             IF TAB[X].TYP IN STANTYPS THEN TAB[PRT].TYP := TAB[X].TYP
|               ELSE ERROR(15)
|       END ELSE SKIP([SEMICOLON]+FSYS, 2)
|     END ELSE ERROR(5);
|   IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
|   REPEAT
|     IF SY = CONSTSY THEN CONSDECLARATION;
|     IF SY = TYPESY THEN TYPEDECLARATION;
|     IF SY = VARSY THEN VARDECLARATION;
|     BTAB[PRB].VSIZE := DX;
|     WHILE SY IN [PROCSY,FUNCSY] DO PROCDECLARATION;
|     TEST([BEGINSY], BLOCKBEGSYS+STATBEGSYS, 56)
|   UNTIL SY IN STATBEGSYS;
|   TAB[PRT].ADR := LC;
|   INSYMBOL; STATEMENT([SEMICOLON,ENDSY]+FSYS);
|   WHILE SY IN [SEMICOLON]+STATBEGSYS DO
|     BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
|       STATEMENT([SEMICOLON,ENDSY]+FSYS)
|     END ;
|   IF SY = ENDSY THEN INSYMBOL ELSE ERROR(57);
|   TEST(FSYS+[PERIOD], [], 6)
| END (*BLOCK*) ;
| 
| (* EOF                                                                        *)
| (* #INCLUDE "INTERPRET.I"                                                     *)
| (* INTERPRET.I                                                                *)
| PROCEDURE INTERPRET;
|   (*GLOBAL CODE, TAB, BTAB*)
|   VAR IR: ORDER;      (*INSTRUCTION BUFFER*)
|       PC: INTEGER;    (*PROGRAM COUNTER*)
|       PS: (RUN,FIN,CASCHK,DIVCHK,INXCHK,STKCHK,LINCHK,LNGCHK,REDCHK);
|       T:  INTEGER;    (*TOP STACK INDEX*)
|       B:  INTEGER;    (*BASE INDEX*)
|       LNCNT, OCNT, BLKCNT, CHRCNT: INTEGER;     (*COUNTERS*)
|       H1,H2,H3,H4: INTEGER;
|       FLD: ARRAY [1..4] OF INTEGER;     (*DEFAULT FIELD WIDTHS*)
| 
|       DISPLAY: ARRAY [1..LMAX] OF INTEGER;
|       S: ARRAY [1..STACKSIZE] OF          (*BLOCKMARK:              *)
|          RECORD CASE TYPES OF             (*   S[B+0] = FCT RESULT  *)
|            INTS:  (I: INTEGER);           (*   S[B+1] = RETURN ADR  *)
|            REALS: (R: REAL);              (*   S[B+2] = STATIC LINK *)
|            BOOLS: (B: BOOLEAN);           (*   S[B+3] = DYNAMIC LINK*)
|            CHARS: (C: CHAR)               (*   S[B+4] = TABLE INDEX *)
|          END ;
| 
| BEGIN (*INTERPRET*)
|   S[1].I := 0; S[2].I := 0; S[3].I := -1; S[4].I := BTAB[1].LAST;
|   B := 0; DISPLAY[1] := 0;
|   T := BTAB[2].VSIZE - 1; PC := TAB[S[4].I].ADR;
|   PS := RUN;
|   LNCNT := 0; OCNT := 0; CHRCNT := 0;
|   FLD[1] := 10; FLD[2] := 22; FLD[3] := 10; FLD[4] := 1;
|   REPEAT IR := CODE[PC]; PC := PC+1; OCNT := OCNT + 1;
|     CASE IR.F OF
|   0: BEGIN (*LOAD ADDRESS*) T := T+1;
|        IF T > STACKSIZE THEN PS := STKCHK
|          ELSE S[T].I := DISPLAY[IR.X] + IR.Y
|      END ;
|   1: BEGIN (*LOAD VALUE*) T := T+1;
|        IF T > STACKSIZE THEN PS := STKCHK
|          ELSE S[T] := S[DISPLAY[IR.X] + IR.Y]
|      END ;
|   2: BEGIN (*LOAD INDIRECT*) T := T+1;
|        IF T > STACKSIZE THEN PS := STKCHK
|          ELSE S[T] := S[S[DISPLAY[IR.X] + IR.Y].I]
|      END ;
|   3: BEGIN (*UPDATE DISPLAY*)
|        H1 := IR.Y; H2 := IR.X; H3 := B;
|        REPEAT DISPLAY[H1] := H3; H1 := H1-1; H3 := S[H3+2].I
|        UNTIL H1 = H2
|      END ;
|   8: CASE IR.Y OF
|       0: S[T].I := ABS(S[T].I);
|       1: S[T].R := ABS(S[T].R);
| #     2: S[T].I := S[T].I*S[T].I (*SQR(S[T].I)*);
|       3: S[T].R := S[T].R*S[T].R (*SQR(S[T].R)*);
|       4: S[T].B := ODD(S[T].I);
|       5: BEGIN
|            IF (S[T].I < 0) OR (S[T].I > 127) THEN PS := INXCHK
|    ELSE S[T].C := CHR(S[T].I)
|          END ;
|       6: S[T].I := ORD(S[T].C) ;
|       7: S[T].C := SUCC(S[T].C);
|       8: S[T].C := PRED(S[T].C);
| ##  (*9: S[T].I := ROUND(S[T].R);*)
|      10: S[T].I := TRUNC(S[T].R);
|      11: S[T].R := SIN(S[T].R);
|      12: S[T].R := COS(S[T].R);
|      13: S[T].R := EXP(S[T].R);
|      14: S[T].R := LN(S[T].R);
|      15: S[T].R := SQRT(S[T].R);
|      16: S[T].R := ARCTAN(S[T].R);
|      17: BEGIN T := T+1;
|            IF T > STACKSIZE THEN PS := STKCHK ELSE S[T].B := EOF(INPUT)
|          END ;
|      18: BEGIN T := T+1;
|            IF T > STACKSIZE THEN PS := STKCHK ELSE S[T].B := EOLN(INPUT)
|          END ;
|      19:
|      END ;
|   9: S[T].I := S[T].I + IR.Y;   (*OFFSET*)
|  10: PC := IR.Y;  (*JUMP*)
|  11: BEGIN (*CONDITIONAL JUMP*)
|        IF NOT S[T].B THEN PC := IR.Y;  T := T-1
|      END ;
|  12: BEGIN (*SWITCH*) H1 := S[T].I; T := T-1;
|        H2 := IR.Y; H3 := 0;
|        REPEAT IF CODE[H2].F <> 13 THEN
|                 BEGIN H3 := 1; PS := CASCHK
|                 END ELSE
|               IF CODE[H2].Y = H1 THEN
|                 BEGIN H3 := 1; PC := CODE[H2+1].Y
|                 END ELSE
|               H2 := H2 + 2
|        UNTIL H3 <> 0
|      END ;
|  14: BEGIN (*FOR1UP*) H1 := S[T-1].I;
|        IF H1 <= S[T].I THEN S[S[T-2].I].I := H1 ELSE
|           BEGIN T := T-3; PC := IR.Y
|           END
|      END ;
|  15: BEGIN (*FOR2UP*) H2 := S[T-2].I; H1 := S[H2].I + 1;
|        IF H1 <= S[T].I THEN
|          BEGIN S[H2].I := H1; PC := IR.Y END
|        ELSE T := T-3;
|      END ;
|  16: BEGIN (*FOR1DOWN*) H1 := S[T-1].I;
|        IF H1 >= S[T].I THEN S[S[T-2].I].I := H1 ELSE
|           BEGIN PC := IR.Y; T := T-3
|           END
|      END ;
|  17: BEGIN (*FOR2DOWN*) H2 := S[T-2].I; H1 := S[H2].I - 1;
|        IF H1 >= S[T].I THEN
|          BEGIN S[H2].I := H1; PC := IR.Y END
|        ELSE T := T-3;
|      END ;
|  18: BEGIN (*MARK STACK*)  H1 := BTAB[TAB[IR.Y].REF].VSIZE;
|        IF T+H1 > STACKSIZE THEN PS := STKCHK ELSE
|          BEGIN T := T+5; S[T-1].I := H1-1; S[T].I := IR.Y
|          END
|      END ;
|  19: BEGIN (*CALL*) H1 := T - IR.Y;  (*H1 POINTS TO BASE*)
|        H2 := S[H1+4].I;            (*H2 POINTS TO TAB*)
|        H3 := TAB[H2].LEV; DISPLAY[H3+1] := H1;
|        H4 := S[H1+3].I + H1;
|        S[H1+1].I := PC; S[H1+2].I := DISPLAY[H3]; S[H1+3].I := B;
|        FOR H3 := T+1 TO H4 DO S[H3].I := 0;
|        B := H1; T := H4; PC := TAB[H2].ADR
|      END ;
|  20: BEGIN (*INDEX1*) H1 := IR.Y;      (*H1 POINTS TO ATAB*)
|        H2 := ATAB[H1].LOW; H3 := S[T].I;
|        IF H3 < H2 THEN PS := INXCHK ELSE
|        IF H3 > ATAB[H1].HIGH THEN PS := INXCHK ELSE
|          BEGIN T := T-1; S[T].I := S[T].I + (H3-H2)
|          END
|      END ;
|  21: BEGIN (*INDEX*)  H1 := IR.Y;      (*H1 POINTS TO ATAB*)
|        H2 := ATAB[H1].LOW; H3 := S[T].I;
|        IF H3 < H2 THEN PS := INXCHK ELSE
|        IF H3 > ATAB[H1].HIGH THEN PS := INXCHK ELSE
|          BEGIN T := T-1; S[T].I := S[T].I + (H3-H2)*ATAB[H1].ELSIZE
|          END
|      END ;
|  22: BEGIN (*LOAD BLOCK*) H1 := S[T].I; T := T-1;
|        H2 := IR.Y + T; IF H2 > STACKSIZE THEN PS := STKCHK ELSE
|        WHILE T < H2 DO
|          BEGIN T := T+1; S[T] := S[H1]; H1 := H1+1
|          END
|      END ;
|  23: BEGIN (*COPY BLOCK*) H1 := S[T-1].I;
|        H2 := S[T].I; H3 := H1 + IR.Y;
|        WHILE H1 < H3 DO
|          BEGIN S[H1] := S[H2]; H1 := H1+1; H2 := H2+1
|          END ;
|        T := T-2
|      END ;
|  24: BEGIN (*LITERAL*) T := T+1;
|        IF T > STACKSIZE THEN PS := STKCHK ELSE S[T].I := IR.Y
|      END ;
|  25: BEGIN (*LOAD REAL*) T := T+1;
|        IF T > STACKSIZE THEN PS := STKCHK ELSE S[T].R := RCONST[IR.Y]
|      END ;
|   64,65: BEGIN T := T + 1; IF T > STACKSIZE THEN PS := STKCHK
|    ELSE S[T].C := CHR(IR.Y) END;
|  26: BEGIN (*FLOAT*) H1 := T - IR.Y; S[H1].R := S[H1].I
|      END ;
|  27: BEGIN (*READ*)
|        IF EOF(INPUT) THEN PS := REDCHK ELSE
|           CASE IR.Y OF
|            1: READ(S[S[T].I].I);
|            2: READ(S[S[T].I].R);
|            4: READ(S[S[T].I].C);
|           END ;
|        T := T-1
|      END ;
|  28: BEGIN (*WRITE STRING*)
|        H1 := S[T].I; H2 := IR.Y; T := T-1;
|        CHRCNT := CHRCNT+H1; IF CHRCNT > LINELENG THEN PS := LNGCHK;
|        REPEAT WRITE(STAB[H2]); H1 := H1-1; H2 := H2+1
|        UNTIL H1 = 0
|      END ;
|  29: BEGIN (*WRIT1*)
|        CHRCNT := CHRCNT + FLD[IR.Y];
|        IF CHRCNT > LINELENG THEN PS := LNGCHK ELSE
|        CASE IR.Y OF
|         1: WRITE(S[T].I: FLD[1]);
|         2: WRITE(S[T].R: FLD[2]);
|         3: WRITE(S[T].B: FLD[3]);
|    4: WRITE(S[T].C);
|        END ;
|        T := T-1
|      END ;
|  30: BEGIN (*WRITE2*)
|        CHRCNT := CHRCNT + S[T].I;
|        IF CHRCNT > LINELENG THEN PS := LNGCHK ELSE
|        CASE IR.Y OF
|         1: WRITE(S[T-1].I: S[T].I);
|         2: WRITE(S[T-1].R: S[T].I);
|         3: WRITE(S[T-1].B: S[T].I);
|         4: WRITE(S[T-1].C: S[T].I);
|        END ;
|        T := T-2
|      END ;
|  31: PS := FIN;
|  32: BEGIN (*EXIT PROCEDURE*)
|        T := B-1; PC := S[B+1].I; B := S[B+3].I
|      END ;
|  33: BEGIN (*EXIT FUNCTION*)
|        T := B; PC := S[B+1].I; B := S[B+3].I
|      END ;
|  34: S[T] := S[S[T].I];
|  35: S[T].B := NOT S[T].B;
|  36: S[T].I := - S[T].I;
|  66: S[T].R := - S[T].R;
|  37: BEGIN CHRCNT := CHRCNT + S[T-1].I;
|        IF CHRCNT > LINELENG THEN PS := LNGCHK ELSE
| ##        WRITE(S[T-2].R: S[T-1].I ": S[T].I");
|        T := T-3
|      END ;
|  38: BEGIN (*STORE*) S[S[T-1].I] := S[T]; T := T-2
|      END ;
|  39: BEGIN T := T-1; S[T].B := S[T].R = S[T+1].R
|      END ;
|  40: BEGIN T := T-1; S[T].B := S[T].R <> S[T+1].R
|      END ;
|  41: BEGIN T := T-1; S[T].B := S[T].R < S[T+1].R
|      END ;
|  42: BEGIN T := T-1; S[T].B := S[T].R <= S[T+1].R
|      END ;
|  43: BEGIN T := T-1; S[T].B := S[T].R > S[T+1].R
|      END ;
|  44: BEGIN T := T-1; S[T].B := S[T].R >= S[T+1].R
|      END ;
|  45: BEGIN T := T-1; S[T].B := S[T].I = S[T+1].I
|      END ;
|  46: BEGIN T := T-1; S[T].B := S[T].I <> S[T+1].I
|      END ;
|  47: BEGIN T := T-1; S[T].B := S[T].I < S[T+1].I
|      END ;
|  48: BEGIN T := T-1; S[T].B := S[T].I <= S[T+1].I
|      END ;
|  49: BEGIN T := T-1; S[T].B := S[T].I > S[T+1].I
|      END ;
|  50: BEGIN T := T-1; S[T].B := S[T].I >= S[T+1].I
|      END ;
|  51: BEGIN T := T-1; S[T].B := S[T].B OR S[T+1].B
|      END ;
|  52: BEGIN T := T-1; S[T].I := S[T].I + S[T+1].I
|      END ;
|  53: BEGIN T := T-1; S[T].I := S[T].I - S[T+1].I
|      END ;
|  54: BEGIN T := T-1; S[T].R := S[T].R + S[T+1].R;
|      END ;
|  55: BEGIN T := T-1; S[T].R := S[T].R - S[T+1].R;
|      END ;
|  56: BEGIN T := T-1; S[T].B := S[T].B AND S[T+1].B
|      END ;
|  57: BEGIN T := T-1; S[T].I := S[T].I * S[T+1].I
|      END ;
|  58: BEGIN T := T-1;
|        IF S[T+1].I = 0 THEN PS := DIVCHK ELSE
|          S[T].I := S[T].I DIV S[T+1].I
|      END ;
|  59: BEGIN T := T-1;
|        IF S[T+1].I = 0 THEN PS := DIVCHK ELSE
|          S[T].I := S[T].I MOD S[T+1].I
|      END ;
|  60: BEGIN T := T-1; S[T].R := S[T].R * S[T+1].R;
|      END ;
|  61: BEGIN T := T-1;
|    IF S[T+1].R = 0.0 THEN PS := DIVCHK ELSE S[T].R := S[T].R / S[T+1].R;
|      END ;
|  62: IF EOF(INPUT) THEN PS := REDCHK ELSE READLN(INPUT);
|  63: BEGIN WRITELN; LNCNT := LNCNT + 1; CHRCNT := 0;
|         IF LNCNT > LINELIMIT THEN PS := LINCHK
|      END
|     END (*CASE*) ;
|   UNTIL PS <> RUN;
| 
|   IF PS <> FIN THEN
|   BEGIN WRITELN;
|     WRITE('0HALT AT', PC:5, ' BECAUSE OF ');
|     CASE PS OF
|       CASCHK: WRITELN('UNDEFINED CASE');
|       DIVCHK: WRITELN('DIVISION BY 0');
|       INXCHK: WRITELN('INVALID INDEX');
|       STKCHK: WRITELN('STORAGE OVERFLOW');
|       LINCHK: WRITELN('TOO MUCH OUTPUT');
|       LNGCHK: WRITELN('LINE TOO LONG');
|       REDCHK: WRITELN('READING PAST END OF FILE');
|     END ;
|     H1 := B; BLKCNT := 10;   (*POST MORTEM DUMP*)
|     REPEAT WRITELN; BLKCNT := BLKCNT - 1;
|       IF BLKCNT = 0 THEN H1 := 0; H2 := S[H1+4].I;
|       IF H1<>0 THEN
|         WRITELN(' ', TAB[H2].NAME, ' CALLED AT', S[H1+1].I: 5);
|       H2 := BTAB[TAB[H2].REF].LAST;
|       WHILE H2 <> 0 DO
|       WITH TAB[H2] DO
|       BEGIN IF OBJ = VARIABLE THEN
|             IF TYP IN STANTYPS THEN
|             BEGIN WRITE('    ', NAME, ' = ');
|               IF NORMAL THEN H3 := H1+ADR ELSE H3 := S[H1+ADR].I;
|               CASE TYP OF
|                INTS:  WRITELN(S[H3].I);
|                REALS: WRITELN(S[H3].R);
|                BOOLS: WRITELN(S[H3].B);
|                CHARS: WRITELN(S[H3].C);
|               END
|             END ;
|             H2 := LINK
|       END ;
|       H1 := S[H1+3].I
|     UNTIL H1 < 0;
|   END ;
|   WRITELN; WRITELN(OCNT, ' STEPS')
| END (*INTERPRET*) ;
| (* EOF                                                                        *)
| 
| BEGIN WRITELN;
|    KEY[ 1] := 'AND       '; KEY[ 2] := 'ARRAY     ';
|    KEY[ 3] := 'BEGIN     '; KEY[ 4] := 'CASE      ';
|    KEY[ 5] := 'CONST     '; KEY[ 6] := 'DIV       ';
|    KEY[ 8] := 'DOWNTO    '; KEY[ 7] := 'DO        ';
|    KEY[ 9] := 'ELSE      '; KEY[10] := 'END       ';
|    KEY[11] := 'FOR       '; KEY[12] := 'FUNCTION  ';
|    KEY[13] := 'IF        '; KEY[14] := 'MOD       ';
|    KEY[15] := 'NOT       '; KEY[16] := 'OF        ';
|    KEY[17] := 'OR        '; KEY[18] := 'PROCEDURE ';
|    KEY[19] := 'PROGRAM   '; KEY[20] := 'RECORD    ';
|    KEY[21] := 'REPEAT    '; KEY[22] := 'THEN      ';
|    KEY[23] := 'TO        '; KEY[24] := 'TYPE      ';
|    KEY[25] := 'UNTIL     '; KEY[26] := 'VAR       ';
|    KEY[27] := 'WHILE     ';
|    KSY[ 1] := ANDSY;        KSY[ 2] := ARRAYSY;
|    KSY[ 3] := BEGINSY;      KSY[ 4] := CASESY;
|    KSY[ 5] := CONSTSY;      KSY[ 6] := IDIV;
|    KSY[ 8] := DOWNTOSY;     KSY[ 7] := DOSY;
|    KSY[ 9] := ELSESY;       KSY[10] := ENDSY;
|    KSY[11] := FORSY;        KSY[12] := FUNCSY;
|    KSY[13] := IFSY;         KSY[14] := IMOD;
|    KSY[15] := NOTSY;        KSY[16] := OFSY;
|    KSY[17] := ORSY;         KSY[18] := PROCSY;
|    KSY[19] := PROGRAMSY;    KSY[20] := RECORDSY;
|    KSY[21] := REPEATSY;     KSY[22] := THENSY;
|    KSY[23] := TOSY;         KSY[24] := TYPESY;
|    KSY[25] := UNTILSY;      KSY[26] := VARSY;
|    KSY[27] := WHILESY;
|    SPS['+'] := PLUS;        SPS['-'] := MINUS;
|    SPS['*'] := TIMES;       SPS['/'] := RDIV;
|    SPS['('] := LPARENT;     SPS[')'] := RPARENT;
|    SPS['='] := EQL;         SPS[','] := COMMA;
|    SPS['['] := LBRACK;      SPS[']'] := RBRACK;
|    SPS['#'] := NEQ;         SPS['&'] := ANDSY;
|    SPS[';'] := SEMICOLON;
|   CONSTBEGSYS := [PLUS,MINUS,INTCON,REALCON,CHARCON,IDENT];
|   TYPEBEGSYS := [IDENT,ARRAYSY,RECORDSY];
|   BLOCKBEGSYS := [CONSTSY,TYPESY,VARSY,PROCSY,FUNCSY,BEGINSY];
|   FACBEGSYS := [INTCON,REALCON,CHARCON,IDENT,LPARENT,NOTSY];
|   STATBEGSYS := [BEGINSY,IFSY,WHILESY,REPEATSY,FORSY,CASESY];
|   STANTYPS := [NOTYP,INTS,REALS,BOOLS,CHARS];
|   LC := 0; LL := 0; CC := 0; CH := ' ';
|   ERRPOS := 0; ERRS := []; INSYMBOL;
|   T := -1; A := 0; B := 1; SX := 0; C2 := 0;
|   DISPLAY[0] := 1;
|   IFLAG := FALSE; OFLAG := FALSE;
|   IF SY <> PROGRAMSY THEN ERROR(3) ELSE
|   BEGIN INSYMBOL;
|     IF SY <> IDENT THEN ERROR(2) ELSE
|     BEGIN PROGNAME := ID; INSYMBOL;
|       IF SY <> LPARENT THEN ERROR(9) ELSE
|       REPEAT INSYMBOL;
|    IF SY <> IDENT THEN ERROR(2) ELSE
|    BEGIN IF ID = 'INPUT     ' THEN IFLAG := TRUE ELSE
|          IF ID = 'OUTPUT    ' THEN OFLAG := TRUE ELSE ERROR(0);
|       INSYMBOL
|    END
|       UNTIL SY <> COMMA;
|       IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4);
|       IF NOT OFLAG THEN ERROR(20)
|     END
|   END ;
|   ENTER('          ', VARIABLE, NOTYP, 0);  (*SENTINEL*)
|   ENTER('FALSE     ', KONSTANT, BOOLS, 0);
|   ENTER('TRUE      ', KONSTANT, BOOLS, 1);
|   ENTER('REAL      ', TYPE1, REALS, 1);
|   ENTER('CHAR      ', TYPE1, CHARS, 1);
|   ENTER('BOOLEAN   ', TYPE1, BOOLS, 1);
|   ENTER('INTEGER   ', TYPE1, INTS , 1);
|   ENTER('ABS       ', FUNKTION, REALS,0);
|   ENTER('SQR       ', FUNKTION, REALS,2);
|   ENTER('ODD       ', FUNKTION, BOOLS,4);
|   ENTER('CHR       ', FUNKTION, CHARS,5);
|   ENTER('ORD       ', FUNKTION, INTS, 6);
|   ENTER('SUCC      ', FUNKTION, CHARS,7);
|   ENTER('PRED      ', FUNKTION, CHARS,8);
|   ENTER('ROUND     ', FUNKTION, INTS, 9);
|   ENTER('TRUNC     ', FUNKTION, INTS, 10);
|   ENTER('SIN       ', FUNKTION, REALS, 11);
|   ENTER('COS       ', FUNKTION, REALS, 12);
|   ENTER('EXP       ', FUNKTION, REALS, 13);
|   ENTER('LN        ', FUNKTION, REALS, 14);
|   ENTER('SQRT      ', FUNKTION, REALS, 15);
|   ENTER('ARCTAN    ', FUNKTION, REALS, 16);
|   ENTER('EOF       ', FUNKTION, BOOLS, 17);
|   ENTER('EOLN      ', FUNKTION, BOOLS, 18);
|   ENTER('READ      ', PROZEDURE, NOTYP, 1);
|   ENTER('READLN    ', PROZEDURE, NOTYP, 2);
|   ENTER('WRITE     ', PROZEDURE, NOTYP, 3);
|   ENTER('WRITELN   ', PROZEDURE, NOTYP, 4);
|   ENTER('          ', PROZEDURE, NOTYP, 0);
|   WITH BTAB[1] DO
|     BEGIN LAST := T; LASTPAR := 1; PSIZE := 0; VSIZE := 0
|     END ;
| 
|   BLOCK(BLOCKBEGSYS+STATBEGSYS, FALSE, 1);
|   IF SY <> PERIOD THEN ERROR(22);
|   EMIT(31);  (*HALT*)
|   IF BTAB[2].VSIZE > STACKSIZE THEN ERROR(49);
|   IF PROGNAME = 'TEST0     ' THEN PRINTTABLES;
| 
|   IF ERRS = [] THEN
|   BEGIN
| (* { MUST BLOCK ALL OF THIS OUT FOR NOW.                                      *)
|     IF IFLAG THEN
| ##  BEGIN  (* GETSEG(INPUT); *)
|       IF EOF(INPUT) THEN WRITELN(' INPUT DATA MISSING') ELSE
|       BEGIN WRITELN(' (EOR)'); (*COPY INPUT DATA*)
| ##(* WHILE NOT EOF(INPUT) DO
| ## BEGIN WRITE(' ');
| ##   WHILE NOT EOLN(INPUT) DO
| ##     BEGIN READ(CH); WRITE(CH)
| ##     END ;
| ##   WRITELN; READ(CH)
| ## END ;
| ## GETSEG(INPUT,0)  *)
|       END
|     END ;
| (*  ALL THIS BECAUSE OF SEGMENTED FILE REPOSITIONING×× }                      *)
|     WRITELN(' (EOF)');
|     INTERPRET
|   END
|   ELSE ERRORMSG;
| 99:
| END .
| (* EOF                                                                        *)
> Member QSORT
| PROGRAM QUICKSORT( OUTPUT ) ;  (*$L+,D- *)
| 
| (* PARTITION-XCHANGE SORT, AFTER J. SEDGEWICK,  S. HAZEGHI.
| 
|    M ::= SIZE OF THE PARTITIONS TO BE BUBBLE-SORTED
|    N ::= NUMBER OF ELEMENTS TO BE SORTED ;
|    N1 ::= N+1 ;
|    STACK_SIZE ::= MAX # OF UNSORTED PARTITIONS ( >= 2*(LOG(N)-3), LOG IS BASE 2)
| *)
| 
| LABEL 101,111 ;
| 
| CONST   M = 9 ;  N = 40;  N1 = 41 ;STACK_SIZE = 25;
| 
| VAR L,R,P,I,J,V,T : INTEGER ;
|     STACK : ARRAY [1..STACK_SIZE] OF INTEGER ;
|     (* STACK_SIZE  2*(LG(N)-3) *)
|     A : ARRAY [1..N1] OF INTEGER ;
| 
| PROCEDURE PRINTDATA ;
| 
|     (* TO PRINT THE RAW AND SORTED DATA, 10 NUMBERS PER LINE *)
| 
|     BEGIN
|     FOR I := 1 TO N1 DO
|         BEGIN
|         IF (I MOD 10) = 1 THEN  WRITELN ;
|         WRITE('  ',A[I]:11 ) ;
|         END;
|     END ;
| 
|     BEGIN  (* QUIKSORT *)
| 
|     (* I- GENERATE RANDOM DATA FOR SORTING *)
| 
|     A[1] := 0; L := 2; R := N1; P := 0;
|     FOR I := 1 TO N DO
|         BEGIN  A[I+1] := A[I]*314159269+453806245;
|         IF A[I+1] < 0 THEN
|             BEGIN  A[I+1] := A[I+1]+2147483647 ;
|             A[I+1] := A[I+1]+1
|             END
|         END ;
| 
|     PRINTDATA ;
| 
|     (* II- PARTITION THE SORT DATA *)
| 
|     REPEAT  I := L-1; J := R; V := A[R];
|         REPEAT
|             REPEAT I := I+1 UNTIL (A[I] >= V) ;
|             A[J] := A[I];
|             REPEAT J := J-1 UNTIL (A[J] <= V) ;
|             IF I >= J THEN GOTO 101 ;
|             A[I] := A[J]
|         UNTIL  FALSE ;
|     101:IF I <> J THEN  J := J+1;
|         A[J] := V;
|         IF J-L > R-J THEN
|             BEGIN
|             IF M >= J-L THEN
|                 BEGIN  IF P = 0 THEN GOTO 111 ;
|                 R := STACK[P+1];  L := STACK[P];  P := P-2;
|                 END
|             ELSE IF R-J > M THEN
|                     BEGIN  P := P+2 ;  STACK[P] := L ;
|                     STACK[P+1] := J-1 ;  L := J+1
|                     END
|                 ELSE  R := J-1
|             END
|         ELSE IF M >= R-J THEN
|                 BEGIN  IF P = 0 THEN GOTO 111 ;
|                 R := STACK[P+1];  L := STACK[P];  P := P-2;
|                 END
|             ELSE IF J-L > M  THEN
|                     BEGIN  P := P+2 ;  STACK[P] := J+1 ;
|                     STACK[P+1] := R ;  R := J-1
|                     END
|                 ELSE  L := J+1
|     UNTIL  FALSE ;
| 
|     (* III- EXCHANGE SORT EACH PARTITION *)
| 
| 111:FOR I := 2 TO N1 DO
|         IF A[I] < A[I-1] THEN
|             BEGIN
|             V := A[I] ;  J := I-1 ;
|             REPEAT  A[J+1] := A[J];  J := J-1  UNTIL (A[J] <= V) ;
|             A[J+1] := V
|             END ;
| 
|     PRINTDATA ;
| 
|     END (* QUIKSORT *).
> Member RNF
|  (*$D-              NO DEBUG *)
|  (*$K-              NO EXECUTION PROFILE *)
|  (*$F-              DO NOT SAVE FLOATING POINT REGS *)
|  (*$Q+              ACCEPT ALL FORMS OF SQUARE BRACKET, (UNL ONLY) *)
| 
| 
| 
| 
| (*                                   RNF
|      RNF IS A TEXT FORMATTING PROGRAM SIMILAR BUT NOT IDENTICAL TO RUNOFF
|  (RUNOFF IS A REGISTERED TRADEMARK OF THE DIGITAL ELECTRONICS CORPORATION).
|      RNF WAS ORIGINALLY WRITTEN, IMPLEMENTED AND MAINTAINED BY ROBERT FOSTER
|  AND LATER MAINTAINED BY RICHARD CHILAUSKY, BOTH OF THE COMPUTING SERVICES
|  OFFICE OF THE UNIVERSITY OF ILLINOIS.
|      IT WAS CONVERTED FROM PASCAL 6000 (FOR CDC MACHINES) TO STANFORD
|  PASCAL (FOR IBM MACHINES) BY CURT HILL OF UNIVERSITY OF NEBRASKA AT
|  LINCOLN. THIS VERSION SHOULD BE PORTABLE TO ANY PASCAL RUNNING ON MACHINES
|  THAT USE THE ASCII OR EBCDIC CHARACTER SETS.
|      OUR THANKS TO RICHARD CHILAUSKY, FOR HIS HELP IN THE ORIGINAL
|  CONVERSION TO STANFORD PASCAL.
|      WE APPRECIATE AND ACKNOWLEDGE GEORGE F. BADGER, JR, DIRECTER OF COMPUTING
|  SERVICES OFFICE AT THE UNIVERSITY OF ILLINOIS AT URBANA-CHAMPAIGN, FOR
|  GRACIOUSLY ALLOWING FREE DISTRIBUTION OF THIS PROGRAM.
|       DISTRIBUTION OF THIS PROGRAM IS PRIMARILY TIED TO DISTRIBUTION
|   OF THE STANFORD PASCAL COMPILER. REVISIONS (IF ANY SHOULD OCCUR), WILL
|   BE DISTRIBUTED IN THE SAME WAY. IF YOU REQUIRE A CDC COMPATIBLE
|   IMPLEMENTATION, CONTACT THE OFFICE OF COMPUTER SERVICES, UNIVERSITY OF
|   ILLINOIS, URBANA, ILLINOIS. IF YOU DESIRE A COPY OF THIS PROGRAM FOR
|   AN IMPLEMENTATION THAT USES THE ASCII OR EBCDIC CHARACTER SET
|   THAT IS NOT BASED ON A CDC OR IBM MACHINE THEN CONTACT ME. BUG REPORTS
|   AND GENERAL COMMENTS SHOULD BE ADDRESSED TO MYSELF OR SASSAN HAZEGHI,
|   WHO WILL RELAY THEM TO ME.
|       THERE ARE NO WARRANTIES, EXPRESSED OR IMPLIED, CONCERNING THIS PROGRAM
|   BY ANYONE MENTIONED HEREIN.
| 
|                                               CURT HILL
|                                               225 NEBRASKA HALL
|                                               UNIVERSITY OF NEBRASKA - LINCOLN
|                                               LINCOLN, NEBRASKA
|                                               (402) 472-3701
| 
|       IF THE ADDRESS CHANGES, CHECK PASCAL NEWS FOR AN UPDATE.
| 
|                *)
| 
|  (* CHANGE HISTORY:
|     MODIFY     4/21 MAKE LINES <= 72 CHARS SO MODIFY CAN WORK. BF
|    NONMP       4/21 SYMPTOM: .NONMP CAUSES PAGES NOT TO BE COUNTED.
|                FIX: REWRITE MACRO. BF
|    PERIOD      5/12 COMMAND WITH NO PREFIX TURNS OFF PERIOD SPACING.
|                FIX: USE TRUE INSTEAD OF YES.BF
|    HL          5/12 HL NOT RESET BY .CH. FIX: ADD TO MACRO. BF
|    PUSHSYL     4/23 SYMPTOM: USING .AP, A FORCED .PP OR THE ENTIRE
|                LINE IT BEGAN SOMETIMES VANISHED.  CAUSE: FORCED
|                COMMANDS WERE NOT SAVED PROPERLY OVER FORCED PAGE
|                EJECTS.  FIX: SAVE THE PENDING SYMBOL WHEN FORCING;
|                FOR THIS SPECIAL CASE, PUSH IT SO WILL COME BACK WHEN
|                .FRCPAGE CONCLUDES.  (INTRODUCES ALLOC TO HANDLE
|                MACRO FREE LIST, WHICH IS NEEDED FOR FUTURE
|                ENHANCEMENTS.) BF
|   GETCUR       5/17 RESTRUCTURE CODE TO ALLOW FOR FUTURE ENHANCEMENTS.
|                MOVE INPUT LINE READING TO GETCUR; MOVE ASIS
|                HANDLING TO COMMAND HANDLER.  CHANGE FIXES BUG WHERE
|                BLANK LINE IN ASIS TEXT CAUSED AUTOPARAGRAPH AFTER ASIS
|                CONCLUDED. BF
|   UNDL         5/18 MAKE UNDERLINING PART OF ENVIRONMENT SO UNDONE
|                BY POPS AND NOT DONE IN PAGE FOOTERS AND HEADERS. BF
|   DOLLAR       5/18 DON'T THINK $BLANK OR $NUMBER IS A VARIABLE. BF
|   BR           5/23 WHEN .SP >1, A .BR AFTER THE FIRST LINE ON A PAGE
|                LEFT ONE OR MORE BLANK LINES.  PROBLEM IS HOKEY CODE
|                AROUND PAGE THROWS.  FIX IT SO EVERY PUSHED LINE FORCES
|                A .CR AND SAVES SYMBOL FOR NEXT TIME AROUND.  MUCH
|                CLEANER NOW. BF
|  USB           5/25 SIGNIFICANT BLANK (SB) BUGS: A) SB AT END OF
|                JUSTIFIED LINE SCREWED UP JUSTIFICATION, B) SB "PUSHED"
|                TO NEW LINE WERE LOST, C) CONTROVERSY OVER WHETHER TO
|                UNDERLINE SB. SOLUTION: ADD .USB COMMAND (UNDERLINE
|                SIGNIFICANT BLANKS) TO TURN ON OR OFF. WHILE UP, FIX
|                BUG WHERE COLON NOT UNDERLINED. BF
|  ARGS          5/27 SIGNIFICANT CHANGE TO MACRO HANDLING: MACRO
|                "PARMS" (MACROS DEFINED BY MACRO INVOCATION) ARE
|                INITIALLY DEFINED AS NULL AND REMAIN WELL-DEFINED
|                UNTIL REDEFINED BY ANOTHER INVOCATION.  PERMITS
|                MACROS SUCH AS ".MACRO CHAP * = .CH .CHAP1", AS
|                .CHAP1 RETAINS ITS MEANING UNTIL .CHAP CALLED AGAIN.
|                NOTE THAT IF THIS HAD BEEN AVAILABLE BEFORE, THE
|                ..TTL CIRCUMLOCUTION WOULD NOT HAVE BEEN NEEDED. BF
|  RIGHT         6/6 ALTERNATING FILL BROKEN BY FORCING .CR AFTER
|                EACH LINE.  RESET ALTERNATING FILL ONLY ON .PP
|                COMMAND. BF
|  DOMID         6/17 NEEDED SOME MORE CLRLINES IN DOMID.  BF
|  EMPTY         7/11 IF THE FIRST SYMBOL IN A LINE EXCEEDED THE
|                RIGHT MARGIN, ADDWORD WOULD NEVER PUT IT ON A
|                LINE, BUT PUSHSYL'D IT INFINITELY.  SYMPTOM:
|                STACK OVERFLOW IN PROCEDURE ALLOC. FIX: DON'T
|                PUSH FIRST SYMBOL ON AN EMPTY LINE. BF
|  ADDSYL        7/13 CHANGE "RIGHT" WAS WRONG; BROKE .X AT
|                LINE OVERFLOW.  NOW NEED SOMETHING TO HOLD
|                SYMBOL IN BOTH IN AND OUT FORMATS; ADDED
|                ADDSYL FOR THIS PURPOSE. BF
|  VAR           7/13 ALLOW .VAR $X = EXPRESSION WHERE BOTH $X AND
|                EXPRESSION CAN BE MACRO ARGUMENTS (OR ANYTHING). BF
| OLNO           7/16 OLNO CHANGE TO PREDEFINED VARIABLE $$OLNO SO
|                THAT OUTPUT LINE NUMBER AVAILABLE AT RUNTIME. RC
|  PARAGR        7/22 IF PARAGRAPH'S TEST PAGE DID A .FRCPAGE, THE
|                PARAGRAPH INDENT WAS LOST.  SHOWED UP IN MANUAL.
|                REPORTED BY RICK CICHELLI. FIX IS TO CALL PUSHSYL. BF
|  PS            9/14 .PS CHANGED RIGHT MARGIN AS WELL AS PAGE # RIGHT
|                MARGIN IF ISSUED AFTER A .RM. CORRECTED TO WORK AS
|                DOCUMENTED IE CHANGE PAGE # RIGHT MARGIN ONLY.
|                IMPLEMENTED CHANGE BY ADDING RNF VARIABLE $$PRM. RC
|  ASIS          9/19 ASIS MODE ALLOWS SPURIOUS UNDERLINING TO HAPPEN.
|                FIX: REINITIALIZE ENTIRE LINE BEFORE PROCESSING ASIS
|                TEXT. RC
|  WHEN          9/20 TWO COMMANDS ADDED ALLOW DATE(.DATE) AND TIME
|                (.TIME) TO BE ACCESSED. DATE AS DD/MM/YY AND TIME AS
|                HH:MM. RC
|  DELMAC        9/20 COMMAND ADDED (.DELMAC) TO ALLOW DELETION OF USER
|                DEFINED MACROS FROM MACRO LIST. RC
|  NONMP         9/23 .FRCPAGE FORCED 6 LINES FOR NON PAGE NUMBERED
|                OUTPUT AND 7 LINES FOR PAGE NUMBERED OUTPUT. FORCE
|                AN EXTRA LINE WHEN PAGE NOT NUMBERED VIA SYSTEM
|                MACRO ..NMP RC
|  ELIST         9/26 ELIST DOES NOT RESET THE LEFT MARGIN UNLESS
|                EXPLICITLY FORCED TO. FIX ADD A CLRLINE AFTER
|                POPPING THE ENVIRONMENT(TWICE) TO RESET THE
|                LEFT MARGIN. RC
|  ASIS1         9/27 ASIS MODE DOES NOT PROCESS THE END OF ASIS
|                MODE FLAG(×) SO THAT THE REMAINDER OF THE LINE
|                WILL BE PROCESSED. FIX: SET THE CHARACTER
|                POINTER(CUP) TO THE CHARACTER FOLLOWING THE FLAG
|                CHARACTER. RC
|  MACDEF        10/3 MACRO DEFINITION NOT ALLOWED ON SAME LINE AS
|                VARIABLE DEFINITION. FIX CHANGE PUSHSYL TO
|                BACKUPSYL. RC
|  NOFILL        10/3 NOFILL TEXT NO LONGER NEEDS AN EXPLICIT BREAK
|                TO FORCE A PAGE WITH SINGLE LINE OF TEXT. ACCOMPLISHED
|                BY CHECKING DEFRSYM IN THE MAIN PROCEDURE AND GETTING
|                A NEW LINE WHEN THERE ARE NO DEFERRED COMMANDS. RC
|  CENTER        10/5 .C DOES AN EXTRA CR. AFFECTS THE SPACING WHEN
|                .SP IS GREATER THAN 1. FIX REMOVE THE EXTRA .CR. RC
|  CENTER2       10/7 CORRECTION IN CENTER WOULD WORK ONLY IN TEXT
|                WAS FILLED. CORRECTED TO WORK FOR BOTH FILLED AND
|                NOFILL TEST.  RC
|  SIGCOM        10/7 WHEN USING .SIG, ALL COMMANDS WHICH REQUIRED
|                ARGUMENTS WERE PICKING UP BLANKS AS ARGUMENTS.
|                ADDED CASE STATEMENT TO TURN .SIG OFF WHEN PROCESSING
|                THESE COMMANDS. RC
|   AUTOCAP       A NEW FACILITY HAS BEEN ADDED. LETTERS THAT BEGIN A SENTENCE,
|                 PARAGRAPH, CHAPTER, OR SUB-CHAPTER ARE AUTOMATICALLY
|                 CAPITALIZED. TO MAINTAIN COMPATIBILITY WITH PREVIOUS VERSIONS
|                 THIS FEATURE IS ONLY DONE FOLLOWING THE .AUTOCAP COMMAND,
|                 AND .NOAUTOCAP IS THE DEFAULT. FURTHER, NO AUTO CAPITALIZATION
|                 IS DONE WHEN IN .ASCII MODE.   CH
|  QRR           THIS IS TO PRINT THE INPUT FILE THAT IS BEING PROCESSED.
|                THIS FILE IS USUALLY IGNORED. CH
|  DEBUG1        THIS IS THE OLD DEBUG PLUS DEBUG2. CH
|  DEBUG2        PRINT ON THE RIGHT MARGIN (LINLEN) THE NUMBER OF THE
|                INPUT LINE THAT GENERATED THIS OUTPUT LINE. THIS AIDS
|                FINDING THE CORRECT INPUT LINE THAT NEEDS CHANGING. CH
|  *)
| 
| PROGRAM RUNOFF (INPUT,OUTPUT,QRR);
| CONST
|  VPAGE = 1; VCH = 2; VHL =3; VLIST = 9; (* NEXT IS 20 *)
|  VLM = 20; VRM = 21; VSP = 22; VNMP = 23; VOLNO = 24; (* NEXT IS 25 *)
|  VPRM = 25; (* NEXT IS 26 *)
|  VARMAX = 100;
|  MACCHR = '.';
|  VARCHR = '$';
|  CMDCHR = '.';
|  TABMAX = 16;
|  LINLEN = 132;
|  MAXENP = 20;
|  HLMAX = 5;
|  MAXLIST = 10;
|  FIGMAX = 10;
|  MACMAX = 10;
|  VHLMAX = 5;
|  CASEDIFF = 64; (* DIFFERENCE BETWEEN UPPER AND LOWER CASE, WITH UPPER>LOWER
|                    ASCII = 32,     EBCDIC = 64;         *)
|  CHARSIZE = 256;    (* NUMBER OF CHARS IN CHARACTER SET FOR EBCDIC *)
| 
| TYPE
|  VARTYP = (VITEM,VARRAY);
|  RELOPR = (EQ,GT,LT,NE,GE,LE);
|  ENRANGE = 0..MAXENP;
|  SIGN = (PLUS,MINUS,UNSIGNED,INVALID);
|  SYMTYP = (WORD,COMMAND,VARS,NONE);
|  LLEN = 0..LINLEN;
|  LALEN = 1..LINLEN;
|  JUSLIN = RECORD
|   NDX: LLEN;
|   POS: ARRAY (/LALEN/) OF INTEGER
|  END;
|  LINE = RECORD
|   CENTER,BBAR: BOOLEAN;
|   VLEN,LEN: LLEN;
|   LIN: ARRAY (/LALEN/) OF CHAR;    (* HOLDS THE LINE TO BE PROCESSEED *)
|   LINT : ARRAY(/LALEN/) OF RECORD
|                            LINC : ARRAY (/1..4/) OF CHAR;
|          (* EACH ELEMENT OF LINT CORRESPONDS TO A LETTER OF LIN.
|             THE FIRST THREE CHARACTERS ARE POSSIBLE OVERSTRIKE CHARACTERS
|             AND THE FOURTH CHARACTER IS A INDEX AS TO THE NUMBER OF OVERSTRIKES
|            *)              END;
|  END;
|  CMDTYP = (CBLANK,CCR,CBREAK,CRESPAG,CRES,
|            CESCCHR,CASCII,CCENTER,CJUST,(*CUL,*)CLMAR,CRMAR,
|            CFILL,CSIG,CPAGE,CSUP,CLPT,CSTD,CPS,CSAV,CP,
|            CPP,CAP,CI,CSP,CS,CTP,CCH,CHL,CNMP,CPNO,CTITLE,CST,
|            CATITLE,CLIST,CLE,CELIST,CFIG,CBAR,CBB,CEB,CU,
|            CT,CTAB,CTABS,CRT,CRIGHT,CLINES,CMACRO,CX,
|            CVAR,CINC,CASIS,CDEC,CDATE,CTIME,CDELMAC,
|            (* END OF CMDTYP SET *)
|            CFLAG,CFLAGCAPS,CFLAGOVER,CFLAGSIG,CLOWER,CUPPER,CPERIOD,
|            CSAVPAG,CTOP,CMID,CBOT,CARRAY,
|            CFMT,CIF,CDOT,CREM,CUPP,CUSB,CADD,CDEBUG1,CDEBUG2,CAUTOCAP,
|            NOTCMD);
|  ENVIRON = RECORD
|             J,F,PR,SG,UN:   BOOLEAN;
|             PM,SP:  INTEGER;
|             LM,RM,PS,PT,PRM: LLEN;
|             TB:  ARRAY (/1..TABMAX/) OF LLEN
|           END;
| MACTYP = (HEADER,PARM);
| MACLEN = 1..MACMAX;
| MACSYM =  ARRAY(/MACLEN/) OF CHAR;
| ALINE =  ARRAY(/LALEN/) OF CHAR;
| MAC = RECORD
|       ON: BOOLEAN;
|       CA,MA: @MAC;
|       CU,BE,EN: LLEN;
|       MT: MACTYP;
|       NP: 0..8;
|       LI: @ALINE;
|       NM: MACSYM
|      END;
| PMAC = @MAC;
|  SETOFCHAR = ARRAY (/0..255/) OF BOOLEAN;
| VAR
|  SYMTYPE: SYMTYP;
|  SYL,OTL,TMPL: LINE;    (* THE LINE ENTERS THROUGH SYL AND THEN IS TRANSFERRED
|                            A WORD AT A TIME INTO TMPL, WHERE THE CASE IS
|                            ADJUSTED AND OVERSTRIKES ADDED AND THEN IS MOVED
|                            OTL WHERE IT IS JUSTIFIED, CENTERED AND WRITTEN *)
|  FRCSYL,ADDSYL: LINE;
|  FREEMACP: PMAC;
|  CMDS: ARRAY (/CMDTYP/) OF  ARRAY (/1..10/) OF CHAR;
|  CMDTYPE: CMDTYP;
|  LN: LLEN;
|  FLAG,LOWER,FLAGCAPS,FLAGOVER,FLAGSIG: BOOLEAN;
|  PQEND,PERIOD,ESCCHR: BOOLEAN;
|  YES,PAGE: BOOLEAN;
|  JUSTIT,RIGHT: BOOLEAN;
|  (*UL,*) LPT: BOOLEAN;
|  FILL,SIGBL: BOOLEAN;
|  SUP: BOOLEAN;
|  PARA,AP,PREL,ATITLE:  BOOLEAN;
|  ILNO: INTEGER;
|  OPNO,OBTXT,OETXT,OVETXT,OEPAG,OVBTXT: INTEGER;
|  TMAR: LLEN;
|  PMAR: INTEGER;
|  JUST,SAVJUST: JUSLIN;
|  ENSTK: ARRAY (/ENRANGE/) OF ENVIRON; ENP: ENRANGE;
|  PARSPACE,PARTEST,SPACING: INTEGER;
|  PAGENV: ENVIRON;
|  DEFRB: INTEGER;
|  FORCE: BOOLEAN;
|  FIRSTCH: BOOLEAN;
|  FIGP: 0..FIGMAX; FIGN: ARRAY (/1..FIGMAX/) OF INTEGER;
|   UNDL: BOOLEAN;
|  BAR,BB,HOLDBB:  BOOLEAN;
|  RIGHTSPACE: 0..136;
|  TABS: ARRAY(/1..TABMAX/) OF LLEN;
|  TAB,DOTN: LLEN;
|  DEFRSYM: BOOLEAN;
|  RT,T,DOT:   BOOLEAN;
|  BREAKSET,OPTBRKSET,CRSET: SET OF CBLANK..CDEC;
|  EMPTY: BOOLEAN;
|  ACTP,MACLSTP,BOTMAC,TTLMACP,STLMACP,CHTMACP: PMAC;
|  NOTMACRO: BOOLEAN;
|  CUR: ARRAY(/LALEN/) OF CHAR;
|  BEG,ENL,CUP,LASTCUP: LLEN;
|  XTEND: BOOLEAN;
|  LASTLEN,LASTVLEN,LASTSLEN,LASTSVLEN: LLEN;
|  VID: ARRAY (/1..VARMAX/) OF ALFA;
|  VAL: ARRAY (/1..VARMAX/) OF INTEGER;
|  VTY: ARRAY (/1..VARMAX/) OF VARTYP;
|  VUP: ARRAY (/1..VARMAX/) OF 1..VARMAX;
|  VARNDX,TV: 1..VARMAX;
|  PUSHED: BOOLEAN;
|  PAGSAV,PAGSAVS,TMPLSAV: LINE;
|  PAGOTL,PAGSYL: BOOLEAN;
|  CH: CHAR;
|  EP: LLEN;
|  ARELOPR: ARRAY (/RELOPR/) OF ALFA;
|  EXPRERR,SHOWEXPR: BOOLEAN;
|   ITEMSET, TERMSET : SETOFCHAR;
|   SUB, ERRORS : INTEGER;
|   LITERAL1 : ARRAY (/1..60/) OF CHAR;
|   LITERAL2 : ARRAY (/1..57/) OF CHAR;
|   LITERAL3 : ARRAY (/1..16/) OF CHAR;
|   LITERAL4 : ARRAY (/1..38/) OF CHAR;
|   LITERAL5 : ARRAY (/1..27/) OF CHAR;
|   BLANKLINC : ARRAY (/1..4/) OF CHAR;
|  ROMLC,LASTFILD: BOOLEAN;
|  EOFINPUT: BOOLEAN;
|  XTRABL,USB: BOOLEAN;
|  CMMD: BOOLEAN;
|  LETTERS : ARRAY (/0..25/) OF CHAR; (* EASES RELIANCE ON UNDERLYING CHAR SET *)
|  DEBUG1, DEBUG2 : BOOLEAN;
|  CAPNEXT : BOOLEAN;
|  AUTOCAP : BOOLEAN;
|    (*$E        *)
|    FUNCTION INLALPHA (CH:CHAR):BOOLEAN;
|      (* THIS FUNCTION IS EXPRESSLY FOR THE PURPOSE OF THE
|         FOLLOWING TEST :
|                 CH IN (×'a'..'z'×)
|                                *)
|     BEGIN
|       INLALPHA := FALSE;
|       IF (CH >= 'a') AND (CH <= 'i')
|          THEN INLALPHA := TRUE
|          ELSE IF (CH>='j') AND (CH<='r')
|                  THEN INLALPHA := TRUE
|                  ELSE IF (CH>='s') AND (CH<='z')
|                          THEN INLALPHA := TRUE
|                          ELSE;
|        END;  (* SO MUCH FOR INLALPHA *)
| 
| 
| 
|    FUNCTION INALPHA (CH:CHAR):BOOLEAN;
|      (* THIS FUNCTION IS EXPRESSLY FOR THE PURPOSE OF THE
|         FOLLOWING TEST :
|                 CH IN (×'A'..'Z'×)
|                                *)
|     BEGIN
|       INALPHA := FALSE;
|       IF (CH >= 'A') AND (CH <= 'I')
|          THEN INALPHA := TRUE
|          ELSE IF (CH>='J') AND (CH<='R')
|                  THEN INALPHA := TRUE
|                  ELSE IF (CH>='S') AND (CH<='Z')
|                          THEN INALPHA := TRUE
|                          ELSE;
|        END;  (* SO MUCH FOR INALPHA *)
| 
|    FUNCTION INDIGIT (CH : CHAR) : BOOLEAN;
|      (* THIS MODULE PERFORMS THE TEST: CH IN (×0..9×) WHICH IS
|         SOMEWHAT DEFICIENT USING EBCDIC.
|                               *)
|      BEGIN
|        INDIGIT := ((CH >= '0') AND (CH <= '9'));
|        END;  (* INDIGIT *)
| 
| 
| 
| 
|    FUNCTION INSETOFCHAR (S : SETOFCHAR; CH : CHAR) : BOOLEAN;
|      (* THIS MODULE PERFORMS THE TEST: CH IN S , WHERE
|         S IS DEFINED AS SET OF CHAR.
|                               *)
|      BEGIN
|        INSETOFCHAR := S(/ ORD (CH) /) = TRUE
|        END;  (* INSETOFCHAR *)                            (*$E  *)
|    PROCEDURE ERR;
|      BEGIN
|        WRITE(' ERROR:  ');
|        ERRORS := ERRORS + 1;
|      END;    (* END OF ERR *)
| 
|   PROCEDURE ERRE;
|     VAR T: PMAC;
|     BEGIN
|      WRITELN(' ON INPUT LINE ',ILNO:4);
|      T := ACTP;
|      WHILE T@.CA<>NIL DO
|         BEGIN
|         WRITELN('       WITHIN MACRO ',T@.NM:10);
|         T := T@.CA;
|         END;
|     END;     (* END OF ERRE *)
| 
| 
| 
|   PROCEDURE SYLERR;
|     BEGIN
|     WRITE(' ''');
|     FOR LN:=1 TO SYL.LEN DO WRITE(SYL.LIN(/LN/));
|     WRITE('''');
|     ERRE
|     END;     (* END OF SYLERR *)
| 
|   PROCEDURE UPCASESYL;
|     VAR I: LLEN;
|     BEGIN
|     I := 0;
|     WITH SYL DO
|       FOR LN:=1 TO LEN DO
|           IF INLALPHA (LIN(/LN/) )
|              THEN LIN (/LN/) := CHR( ORD( LIN(/LN/) ) + CASEDIFF )
|              ELSE
|     END;     (* END OF UPCASESYL *)
|    FUNCTION  LOWERTHECASE (C:CHAR):CHAR;
|       (* LOWER THE CASE IF ADVISABLE  *)
|      BEGIN
|        IF INALPHA(C)
|           THEN LOWERTHECASE := CHR( ORD(C) - CASEDIFF)
|           ELSE LOWERTHECASE := C;
|      END;
| 
| 
| 
|   PROCEDURE NEXTCH;
|     BEGIN
|     IF EP<SYL.LEN THEN BEGIN EP := EP + 1; CH := SYL.LIN(/EP/) END
|            ELSE IF EP=SYL.LEN THEN BEGIN EP := EP + 1; CH := ' ' END
|        ELSE BEGIN EXPRERR := TRUE; CH := ' ' END;
|     END;     (* END OF NEXTCH *)
| 
| FUNCTION TERM:INTEGER; FORWARD;
| FUNCTION VARIABLE: INTEGER;
| VAR V: ALFA; I: INTEGER; VNDX1,VNDX2: 0..VARMAX; VAR1: INTEGER;
| BEGIN
|  NEXTCH;
|  V := '          ';
|  I := 0;
|  WHILE (INALPHA(CH) OR INDIGIT(CH) OR (CH = '$')) DO
|   BEGIN I := I + 1;
|    IF I<=10 THEN V(/I/) := CH;
|    NEXTCH;
|   END;
|  VAR1 := 0;
|  IF I=0 THEN EXPRERR := TRUE
|  ELSE
|   BEGIN
|    VID(/TV/) := V;
|    VNDX1 := 1;
|    VNDX2 := 0;
|    WHILE VID(/VNDX1/)<>V DO VNDX1 := VNDX1 + 1;
|    IF VNDX1<>TV THEN
|     BEGIN
|      IF (VTY(/VNDX1/)=VARRAY) AND (CH='[') THEN
|       BEGIN
|        NEXTCH;
|        VNDX2 := TERM;
|        IF CH<>']' THEN EXPRERR := TRUE ELSE NEXTCH;
|        IF (VNDX2<0) OR (VNDX2>VUP(/VNDX1/)) THEN
|         BEGIN ERR; WRITE('ARRAY INDEX OUT OF BOUNDS'); SYLERR;
|               VNDX2 := 0 END;
|       END;
|      IF CH='=' THEN
|       BEGIN
|        NEXTCH;
|        VAL(/VNDX1+VNDX2/) := TERM;
|       END;
|      VAR1 := VAL(/VNDX1+VNDX2/);
|     END
|    ELSE BEGIN ERR; WRITE('UNDEFINED VARIABLE: $',V); ERRE END;
|   END;
| VARIABLE := VAR1;
| END;     (* END OF VARIABLE *)
| 
| FUNCTION ITEM: INTEGER;
| VAR SIGN,ITEM1: INTEGER;
| BEGIN
|  SIGN := 1;
|  IF CH='-' THEN BEGIN SIGN := 2; NEXTCH END
|  ELSE IF CH='+' THEN NEXTCH
|  ELSE IF CH='#' THEN BEGIN SIGN := 3; NEXTCH END;
|  ITEM1 := 0;
|  IF CH='$' THEN ITEM1 := VARIABLE
|  ELSE IF INDIGIT(CH) THEN
|   REPEAT
|    ITEM1 := ITEM1*10 + (ORD(CH)-ORD('0'));
|    NEXTCH
|   UNTIL NOT (INDIGIT(CH))
|  ELSE EXPRERR := TRUE;
|  CASE SIGN OF
|   2: ITEM1 := - ITEM1;
|   3: IF ITEM1=0 THEN ITEM1 := 1 ELSE ITEM1 := 0;
|   1:
|  END;
|  ITEM := ITEM1;
| END;     (* END OF ITEM *)
| 
| FUNCTION TERM;
| VAR TERM1,TERM2: INTEGER; TCH: CHAR;
| BEGIN
|  TERM1 := 0;
|  IF CH='(' THEN
|   BEGIN
|    NEXTCH;
|    TERM1 := TERM;
|    IF CH<>')' THEN EXPRERR := TRUE ELSE NEXTCH;
|   END
|  ELSE IF INSETOFCHAR(ITEMSET,CH) THEN
|   BEGIN
|    TERM1 := ITEM;
|    WHILE (CH = '+') OR (CH = '-') DO
|     BEGIN
|      TCH := CH;
|      NEXTCH;
|      TERM2 := 0;
|      IF INSETOFCHAR(ITEMSET,CH) THEN TERM2 := ITEM
|      ELSE IF CH='(' THEN TERM2 := TERM;
|      IF TCH='+' THEN TERM1 := TERM1 + TERM2
|      ELSE TERM1 := TERM1 - TERM2;
|     END;
|   END;
|  TERM := TERM1;
| END;     (* END OF TERM *)
| 
| FUNCTION RELOP: RELOPR;
| VAR OP: ALFA; ROP: RELOPR;
| BEGIN
|  NEXTCH;
|  OP := '          ';
|  OP(/1/) := CH; NEXTCH;
|  OP(/2/) := CH; NEXTCH;
|  RELOP := EQ;
|  IF CH='.' THEN NEXTCH;
|  FOR ROP:=EQ TO LE DO IF ARELOPR(/ROP/)=OP THEN RELOP := ROP;
| END;     (* END OF RELOP *)
| 
| FUNCTION EXPR: INTEGER;
| VAR EXPR1,EXPR2,EXPR3: INTEGER; EXPROP: RELOPR;
| BEGIN
|  WITH SYL DO
|   BEGIN
|    UPCASESYL;
|    IF (LIN(/EP/)='$') AND (LIN(/EP+1/)='(') THEN EP := EP + 1;
|    CH := LIN(/EP/);
|    EXPR1 := 0;
|    EXPRERR := FALSE;
|    IF INSETOFCHAR(TERMSET,CH) THEN
|     BEGIN
|      EXPR1 := TERM;
|      IF CH='.' THEN
|       BEGIN
|        EXPROP := RELOP;
|        EXPR2 := 0;
|        IF INSETOFCHAR(TERMSET,CH) THEN EXPR2 := TERM;
|        EXPR3 := 0;
|        CASE EXPROP OF
|         EQ: IF EXPR1=EXPR2 THEN EXPR3 := 1;
|         GT: IF EXPR1>EXPR2 THEN EXPR3 := 1;
|         LT: IF EXPR1<EXPR2 THEN EXPR3 := 1;
|         NE: IF EXPR1<>EXPR2 THEN EXPR3 := 1;
|         GE: IF EXPR1>=EXPR2 THEN EXPR3 := 1;
|         LE: IF EXPR1<=EXPR2 THEN EXPR3 := 1
|         END;
|        EXPR1 := EXPR3;
|       END
|     END;
|    EXPR := EXPR1;
|    SHOWEXPR := TRUE;
|    IF (EP<=LEN) AND (CH=';') THEN BEGIN NEXTCH; SHOWEXPR := FALSE; END;
|    IF EP<=LEN THEN EXPRERR := TRUE;
|    IF EXPRERR THEN
|     BEGIN ERR; WRITE('ERROR IN EXPRESSION:'); SYLERR END;
|   END;
| END;     (* END OF EXPR *)
| 
| PROCEDURE GETNUM(VAR S: SIGN; VAR N: INTEGER);
| BEGIN
|  WITH SYL DO
|   BEGIN
|    N := 0;
|    LN := 2;
|    IF LIN(/1/)='+' THEN S := PLUS
|    ELSE IF LIN(/1/)='-' THEN S := MINUS
|    ELSE BEGIN S := UNSIGNED; LN := 1 END;
|    EP := LN;
|    N := EXPR;
|    IF EXPRERR THEN S := INVALID;
|   END;
| END;     (* END OF GETNUM *)
| 
| PROCEDURE CLRTAB;
| BEGIN
|  FOR LN:=1 TO TABMAX DO TABS(/LN/) := 0;
| END;     (* END OF CLRTAB *)
| 
| FUNCTION GETTAB(X: INTEGER): INTEGER;
| BEGIN
|  LN := 1;
|  TABS(/TABMAX/) := X;
|  WHILE TABS(/LN/)<X DO LN := LN + 1;
|  JUST.NDX := 0;
|  RT := FALSE;
|  T := FALSE;
|  GETTAB := TABS(/LN/);
| END;     (* END OF GETTAB *)
| 
| PROCEDURE SAVENV(VAR E: ENVIRON);
| BEGIN
|  WITH E DO
|   BEGIN
|    LM := VAL(/VLM/); RM := VAL(/VRM/); PM := PMAR;
|    PS := PARSPACE; PT := PARTEST; PR := PREL;
|    J := JUSTIT; F := FILL;
|    SP := VAL (/VSP/);
|    TB := TABS;
|    SG := SIGBL; UN := UNDL;
|    PRM:=VAL(/VPRM/);
|   END
| END;     (* END OF SAVENV *)
| 
| PROCEDURE RESENV(VAR E: ENVIRON);
| BEGIN
|  WITH E DO BEGIN
|   VAL(/VLM/) := LM; VAL(/VRM/) := RM; PMAR := PM;
|   PARSPACE := PS; PARTEST := PT; PREL := PR;
|   JUSTIT := J; FILL := F;
|   VAL(/VSP/) := SP;
|   TABS := TB;
|   SIGBL := SG; UNDL := UN;
|   VAL(/VPRM/):=PRM;
|  END
| END;     (* END OF RESENV *)
| 
| PROCEDURE PSHENV;
| BEGIN
|  SAVENV(ENSTK(/ENP/));
|  IF ENP=MAXENP THEN
|   BEGIN ERR; WRITE('TOO MANY P OR LIST LEVELS'); ERRE END
|  ELSE ENP := ENP + 1;
| END;     (* END OF PSHENV *)
| 
| PROCEDURE POPENV;
| BEGIN
|  IF ENP=0 THEN
|   BEGIN ERR; WRITE('TOO MANY POPS'); ERRE END
|  ELSE ENP := ENP - 1;
|  RESENV(ENSTK(/ENP/));
| END;     (* END OF POPENV *)
| 
| 
|    PROCEDURE UPCASE(VAR L: LINE);
|      VAR I,J: LLEN;
|      BEGIN
|       WITH L DO
|           FOR I := 1 TO LEN DO
|               IF INLALPHA (LIN(/I/) )
|                  THEN LIN(/I/) := CHR (ORD(LIN(/I/) ) + CASEDIFF)
|                  ELSE
|       END;      (* UPCASE *)
| 
| 
| 
| 
| 
| PROCEDURE FLAGERR(C1,C2: CHAR);
| BEGIN
|  WRITELN;
|  WRITELN('FLAG ERROR IN INPUT LINE ',ILNO:5,':');
|  WRITELN('  ''',C1,C2,''' SEQUENCE NOT ALLOWED -- ''',
|   C1,''' DELETED')
| END;     (* END OF FLAGERR *)
| 
| PROCEDURE DOJUST(VAR L: LINE; VAR F: JUSLIN; RIGHT: BOOLEAN);
| VAR
|  I,J,K,N,M: LLEN;
| BEGIN        (* DOJUST *)
|  WITH L,F DO
|   BEGIN
|    IF LEN>2 THEN
|     IF XTRABL THEN BEGIN LEN := LEN - 1 END;
|    IF (NOT CENTER) AND (NDX>1) AND (LEN<=VAL(/VRM/)+1) THEN
|     BEGIN
|      I := NDX; J := VAL(/VRM/);
|      N := (VAL(/VRM/)-LEN+1) DIV (NDX-1);
|      M := (VAL(/VRM/)-LEN+1) MOD (NDX-1);
|      LEN := J + 1;
|      FOR K:=NDX DOWNTO 2 DO
|       BEGIN
|        FOR LN:=POS(/K/) DOWNTO POS(/K-1/)+1 DO
|         BEGIN LINT(/J/) := LINT(/LN/); LIN(/J/) := LIN(/LN/); J := J - 1 END;
|        FOR LN:=1 TO N DO
|         BEGIN LINT(/J/).LINC := BLANKLINC; LIN(/J/) := ' ';
|                  J := J - 1 END;
|        IF RIGHT THEN
|         BEGIN IF (NDX-K)<=M THEN
|          BEGIN LINT(/J/).LINC := BLANKLINC; LIN(/J/) := ' ';
|                    J := J - 1 END
|         END
|        ELSE IF (K-2)<=M THEN
|         BEGIN LINT(/J/).LINC := BLANKLINC;  LIN(/J/) := ' ';
|                          J := J - 1  END
|       END
|     END
|   END;
| END;     (* END OF DOJUST *)
| 
| PROCEDURE SAVOTL;
| BEGIN
|  TMPLSAV := TMPL;
|  PAGSAV := OTL;
|  PAGOTL := TRUE;
| END;     (* END OF SAVOTL *)
| 
| PROCEDURE SAVSYL;
| BEGIN
|  PAGSAVS := OTL;
|  PAGSYL := TRUE;
|  SAVJUST := JUST;
| END;     (* END OF SAVSYL *)
| 
| PROCEDURE CLRLINE;
| BEGIN
|  WITH OTL DO
|   BEGIN
|    FOR LN:=1 TO VAL(/VLM/) DO BEGIN LIN(/LN/) := ' ';
|                                     LINT(/LN/).LINC := BLANKLINC END;
|    VLEN := VAL(/VLM/);
|    LEN  := VAL(/VLM/);
|    JUST.NDX := 0;
|    SUP := FALSE;
|    DEFRB := 0;
|    TAB := 0;
|    EMPTY := TRUE;
|    CENTER := FALSE;
|    FORCE := FALSE;
|    OTL.BBAR := BB;
|   END;
| END;     (* END OF CLRLINE *)
| 
| PROCEDURE WRITEOTL; FORWARD;
| PROCEDURE PUTBLANK; FORWARD;
| PROCEDURE MIDRESTORE;
| VAR LN: INTEGER;
| BEGIN
|  CLRLINE;
|  IF PAGOTL THEN
|   BEGIN
|    TMPL := TMPLSAV;
|    OTL := PAGSAV;
|    WRITEOTL;
|    VAL(/VOLNO/) := VAL(/VOLNO/) + 1;
|    CLRLINE;
|   END;
|  PAGOTL := FALSE;
|  IF PAGSYL THEN
|   BEGIN
|    OTL := PAGSAVS;
|    JUST := SAVJUST;
|    EMPTY := FALSE;
|    CLRLINE;
|   END;
|  PAGSYL := FALSE;
|  BB := HOLDBB; HOLDBB := FALSE;
| END;     (* END OF MIDRESTORE *)
| 
| PROCEDURE STARTLINE(C: CHAR);
| BEGIN
|  IF DEBUG1                      (* DEBUG1STUFF    *)
|     THEN
|          WRITE(VAL(/VOLNO/):3,' ');
|  IF LPT THEN WRITE(C);
|  IF RIGHTSPACE>0 THEN
|   FOR LN:=1 TO RIGHTSPACE DO WRITE(' ');
|  IF BAR THEN
|   BEGIN
|    IF OTL.BBAR THEN WRITE('×')
|    ELSE WRITE(' ');
|    WRITE('  ');
|   END;
| END;     (* END OF STARTLINE *)
| 
| PROCEDURE DOTOP;
| BEGIN
|  IF NOT LPT THEN
|    FOR SUB := VAL (/VOLNO/) TO OEPAG DO WRITELN;
|  VAL(/VOLNO/) := 1;
|  STARTLINE('1');
|  OVETXT := OETXT - 1;
|  OVBTXT := 0;
|  IF NOT HOLDBB THEN BEGIN HOLDBB := BB; BB := FALSE; END;
| END;     (* END OF DOTOP *)
| 
| PROCEDURE FORCECMD(A:ALFA; B:LLEN);
| BEGIN
|  FRCSYL := SYL;
|  FOR SUB := 1 TO 10 DO BEGIN SYL.LIN (/SUB/) := A(/SUB/);
|                              SYL.LINT(/SUB/).LINC := BLANKLINC; END;
|  SYL.LIN(/11/) := ' ';
|  SYL.LEN := B;
|  SYL.VLEN := B;
|  DEFRSYM := TRUE;
| END;     (* END OF FORCECMD *)
| 
| PROCEDURE DOMID;
| VAR DOFIG: BOOLEAN;
| BEGIN
|  OVBTXT := VAL(/VOLNO/);
|  DOFIG := TRUE;
|  IF FIGP>0 THEN
|   WHILE DOFIG DO
|    IF FIGN(/FIGP/)<=OVETXT-OVBTXT+1 THEN
|     BEGIN
|      FOR LN:=1 TO FIGN(/FIGP/) DO
|       BEGIN WRITELN; VAL(/VOLNO/) := VAL(/VOLNO/) + 1 END;
|      FIGP := FIGP - 1;
|      IF FIGP=0 THEN DOFIG := FALSE;
|     END
|    ELSE DOFIG := FALSE;
|  MIDRESTORE;
| END;     (* END OF DOMID *)
| 
| PROCEDURE DOBOT;
| BEGIN
|  FOR LN:=VAL(/VOLNO/) TO OETXT DO WRITELN;
|  VAL(/VOLNO/) := OETXT + 1;
|  OVETXT := 100000;
|  HOLDBB := BB;
| END;     (* END OF DOBOT *)
| 
| PROCEDURE PUTBLANK;
| BEGIN
|  IF VAL(/VOLNO/)>OVBTXT THEN
|   IF VAL(/VOLNO/)<=OVETXT+1 THEN
|    BEGIN
|     VAL(/VOLNO/) := VAL(/VOLNO/) + 1;
|     STARTLINE(' ');
|     WRITELN;
|    END;
| END;     (* END OF PUTBLANK *)
|   (*$E                  *)
| PROCEDURE WRITEOTL;
| VAR I,J,K,CENTS: INTEGER;
| 
| PROCEDURE DOCENTER;
| VAR I: INTEGER;
| BEGIN
|  CENTS := ((VAL(/VRM/)-VAL(/VLM/)) DIV 2) - ((OTL.LEN-VAL(/VLM/)) DIV 2) ;
|  IF OTL.CENTER THEN FOR I := 1 TO CENTS DO WRITE(' ')
|  ELSE CENTS := 0;
| END;     (* END OF DOCENTER *)
| 
| BEGIN
|  WITH OTL DO
|   BEGIN
|    IF LEN>0 THEN LEN := LEN - 1;
| (* IF NOT UL THEN (* CONVERT TO UC *)
|     BEGIN
| (*   FOR LN:=1 TO LEN DO
|       IF LINT(/LN/)<0 THEN
|        BEGIN
| (*      IF (LINC(/LN,0/)='@') AND (LINC(/LN,9/)<='D') THEN      *)
|          CASE LINC(/LN,9/) OF
|           'A': LINC(/LN,9/) := '@';
|           'B': LINC(/LN,9/) := '^';
|           'D': LINC(/LN,9/) := ':';
|           ':','C':
|          END;
|         LINC(/LN,0/) := ':';
|        END      *)
|     END;           *)
|    I := 0;
|    STARTLINE(' ');
|    DOCENTER;
|    K := 0;
|    FOR LN:=1 TO LEN DO (* WRITE THE LINE *)
|     BEGIN
| (*   IF LINT(/LN/)<0 THEN BEGIN K := K + 1; WRITE(LINC(/LN,0/)) END;    *)
|      K := K + 1; WRITE(LIN(/LN/));
|      IF ORD(LINT(/LN/).LINC(/4/))>I THEN I := ORD(LINT(/LN/).LINC(/4/));
|     END;
|    IF I>0 THEN (* COMPUTE LINE LEN *)
|     BEGIN
|      K := RIGHTSPACE + CENTS + K;
|      IF LPT THEN K := K + 1;
|      IF BAR THEN K := K + 3;
|     END;
|    FOR J:=1 TO I DO
|     BEGIN
|      IF LPT THEN BEGIN WRITELN; STARTLINE('+') END
|      ELSE
|       BEGIN
| (*     IF ODD(K) THEN WRITE(' ');
|        WRITELN(':K');
|        WRITE('@ @5@5@5@5@5');
|                                *)
|       WRITELN; WRITELN; WRITELN;
|        STARTLINE(' ');
|       END;
|      DOCENTER;
|      FOR LN:=1 TO LEN DO
|       IF ORD(LINT(/LN/).LINC(/4/))>=J THEN WRITE(LINT(/LN/).LINC(/J/))
|       ELSE WRITE(' ');
|      K := LEN
|     END;
|     IF DEBUG2
|        THEN WRITELN(OUTPUT,' ':(LINLEN-LEN-CENTS-10),ILNO:5)
|        ELSE WRITELN(OUTPUT)
|   END;
| END;     (* END OF WRITEOTL *)
|    (*$E                 *)
| PROCEDURE PUTLINE;
| BEGIN
|  IF (NOT SUP) AND (NOT EMPTY) THEN
|   BEGIN
|    IF (VAL(/VOLNO/)>OVETXT+1) OR (PUSHED AND (VAL(/VOLNO/)>OVETXT)) THEN
|     BEGIN
|      IF VAL(/VOLNO/)>OVETXT+1 THEN LASTFILD := TRUE;
|      SAVOTL;
|      FORCECMD('.FRCPAGE  ',8);
|     END
|    ELSE
|     BEGIN
|      PUSHED := FALSE; (* NO PAGE THROW *)
|      VAL(/VOLNO/) := VAL(/VOLNO/) + 1;
|      WITH OTL DO
|       BEGIN
|        RIGHT := NOT RIGHT;
|        WRITEOTL;
|       END
|     END
|   END;
|  FOR LN:=1 TO DEFRB DO PUTBLANK;
|  CLRLINE;
| END;     (* END OF PUTLINE *)
| 
| PROCEDURE TESTPAGE(N: INTEGER);
| BEGIN
|  IF (N*VAL(/VSP/))-1>(OVETXT-VAL(/VOLNO/)+1) THEN
|  BEGIN SAVSYL; FORCECMD('.FRCPAGE  ',8) END
| END;     (* END OF TESTPAGE *)
| 
| PROCEDURE PUSHSYL(S: LINE); FORWARD;
| PROCEDURE PARAGRAPH;
| BEGIN
|  RIGHT := TRUE; (* RESET ALTERNATING FILL *)
|  FOR LN:=1 TO PARSPACE*VAL(/VSP/) DO PUTBLANK;
|  WITH OTL DO BEGIN
|   IF PREL THEN
|    IF VAL(/VLM/)+PMAR>0 THEN LN := VAL(/VLM/) + PMAR
|    ELSE LN := 1
|   ELSE LN := PMAR;
|   VLEN := LN; LEN := LN;
|   FOR LN:=1 TO LEN DO BEGIN LIN(/LN/) := ' ';
|                       LINT(/LN/).LINC := BLANKLINC; END;
|  END;
|  RIGHT := TRUE;
|  TESTPAGE(PARTEST);
|  IF DEFRSYM THEN PUSHSYL(FRCSYL);
|  CAPNEXT := AUTOCAP AND LOWER;
| END;     (* PARAGRAPH *)
| PROCEDURE MARKJUST(N: LLEN);
| BEGIN
|  WITH JUST DO
|   BEGIN NDX := NDX + 1; POS(/NDX/) := N END
| END;     (* END OF MARKJUST *)
|    (*$E             *)
| PROCEDURE ADDWORD;
| VAR I,J,LN: INTEGER;
| BEGIN
|  WITH OTL DO
|   BEGIN
|    IF (XTEND) AND (JUST.NDX>0) THEN
|     BEGIN
|      JUST.NDX := JUST.NDX -1;
|      FOR LN:=TMPL.LEN DOWNTO 1 DO BEGIN TMPL.LIN(/LN+LASTSLEN/):=TMPL.LIN(/LN/);
|       TMPL.LINT(/LN+LASTSLEN/) := TMPL.LINT(/LN/);   END;
|      FOR LN:=1 TO LASTSLEN DO BEGIN TMPL.LINT(/LN/) := LINT(/LN+LASTLEN-1/);
|                                  TMPL.LIN(/LN/) := LIN(/LN+LASTLEN-1/) END;
|      TMPL.LEN := TMPL.LEN + LASTSLEN;
|      LEN := LASTLEN;
| (*   FOR LN:=1 TO SYL.LEN DO
|       ADDSYL.LIN(/LN+ADDSYL.LEN/) := SYL.LIN(/LN/);
|      ADDSYL.LEN := ADDSYL.LEN + SYL.LEN *)
|     END;
| (* ELSE ADDSYL := SYL; *)
|    XTEND := FALSE;
|    TAB := 0; DOTN := 0;
|    IF RT THEN TAB := GETTAB(LEN+TMPL.LEN-1) - TMPL.LEN + 1
|    ELSE IF T THEN TAB := GETTAB(LEN);
|    WHILE LEN<TAB DO
|     BEGIN
|      IF DOT AND (NOT (LEN=TAB-1)) THEN LIN(/LEN/) := '.'
|      ELSE LIN(/LEN/) := ' ';
|      LINT(/LEN/).LINC := BLANKLINC;
|      LEN := LEN + 1; DOTN := DOTN + 1;
|     END;
|    IF (LEN+TMPL.LEN-1>VAL(/VRM/)) AND (NOT EMPTY) THEN
|      BEGIN
|       IF JUSTIT THEN DOJUST(OTL,JUST,RIGHT);
|       PUSHED := TRUE;
|       FORCECMD('.CR       ',3);  (* FORCE THE END OF LINE *)
|       PUSHSYL(ADDSYL);         (* AND SAVE THE CURRENT SYMBOL *)
|       PUTLINE;
| (*    IF NOT XTEND THEN PUSHSYL(ADDSYL) (* SAVE CURRENT SYMBOL *)
|       ELSE
|        BEGIN
|         XTEND := FALSE;
|         ADDWORD
|       END; *)
|       IF PUSHED THEN           (* RETURN FLAG MEANS PAGE THROWN *)
|        PUSHSYL(FRCSYL);        (* SAVE THE .CR *)
|       PUSHED := FALSE;         (* TURN IT OFF NOW *)
|      END
|    ELSE
|     BEGIN
|      EMPTY := FALSE;
|      (*DEBUG*)
|      IF LEN=0 THEN
|       BEGIN ERR; WRITE('LEN=0;');FOR LN:=1 TO 10 DO WRITE(LIN(/LN/));
|          WRITE(' -- ');
|          FOR LN:=1 TO 10 DO WRITE(TMPL.LIN(/LN/));
|         ERRE END;
|      FOR LN:=1 TO TMPL.LEN DO BEGIN LINT(/LEN+LN-1/) := TMPL.LINT(/LN/);
|                                     LIN(/LEN+LN-1/) := TMPL.LIN(/LN/) END;
|      LASTLEN := LEN; LASTSLEN := TMPL.LEN;
|      LEN := LEN + TMPL.LEN;
|      MARKJUST(LEN-1);
|      IF NOT SIGBL THEN
|       BEGIN
|        LIN(/LEN/) := ' ';
|        LINT(/LEN/).LINC := BLANKLINC; LEN := LEN + 1;
|        IF PQEND THEN
|         BEGIN LIN(/LEN/):=' ';LINT(/LEN/).LINC:=BLANKLINC; LEN := LEN+1  END;
|        XTRABL := PQEND
|       END;
|     END;
|   END;
|  PUSHED := FALSE;
| END;     (* END OF ADDWORD *)
| 
| PROCEDURE ADDN(N: INTEGER; VAR OTL: LINE);
| BEGIN
|  IF N>=10 THEN ADDN(N DIV 10,OTL);
|  WITH OTL DO BEGIN
|   LIN(/LEN/) := CHR((N MOD 10) + ORD('0'));
|   LINT(/LEN/).LINC := BLANKLINC;
|   LEN := LEN + 1;
|   VLEN := VLEN + 1;
|  END
| END;     (* END OF ADDN *)
| 
| 
| PROCEDURE ADDNUM(N: INTEGER; VAR OTL: LINE);
| BEGIN
|  IF N<0 THEN
|   BEGIN
|    WITH OTL DO BEGIN LIN(/LEN/) := '-'; LEN := LEN + 1;
|                      VLEN := VLEN + 1;LINT(/LEN/).LINC := BLANKLINC END;
|    ADDN(-N,OTL)
|   END
|  ELSE ADDN(N,OTL);
| END;     (* END OF ADDNUM *)
| 
| PROCEDURE ADDCHR(C: CHAR);
| BEGIN
|  WITH OTL DO BEGIN
|   LIN(/LEN/) := C;
|   LINT(/LEN/).LINC := BLANKLINC;
|   LEN := LEN + 1; VLEN := VLEN + 1;
|  END;
| END;     (* END OF ADDCHR *)
|     (*$E           *)
| PROCEDURE UNFLAG(VAR L: LINE; LOWER: BOOLEAN);
|   (* LOWERS THE CASE ADDS OVERSTRIKES AND TRANSFERS STUFF FROM L TO TMPL *)
| VAR
|  FUP : 0..3;
|  VCHN,RCHN: LLEN;
|  SKIP,OVER: BOOLEAN;
|  OUTF: CHAR;
| 
|  PROCEDURE OUT(C: CHAR);
|  BEGIN
|   RCHN := RCHN + 1;
|   TMPL.LINT(/RCHN/).LINC := BLANKLINC;
|   IF INLALPHA(C) OR INALPHA(C)
|      THEN BEGIN    (*  ONLY INVERT LETTERS *)
|           IF (OUTF <> ':') AND (NOT CAPNEXT) (* INVERT? *)
|              THEN TMPL.LIN(/RCHN/) := LOWERTHECASE(C)
|              ELSE TMPL.LIN(/RCHN/) := C;
|           CAPNEXT := FALSE; (* RESET WHETHER USED OR NOT *)
|           END
|      ELSE TMPL.LIN(/RCHN/) := C;
|   OUTF := ':';
|  END;     (* END OF OUT *)
| 
| PROCEDURE OVERS(C: CHAR);
| VAR Z: INTEGER;
| BEGIN
|  WITH TMPL DO
|   BEGIN
|    Z := ORD(LINT(/RCHN/).LINC(/4/));
|    IF (Z<3) AND (RCHN>0) AND (Z>-1) THEN
|     BEGIN
|      Z := Z + 1;
|      LINT(/RCHN/).LINC(/4/) := CHR(Z);
|      LINT(/RCHN/).LINC(/Z/) := C;
|     END
|   END;
| END;     (* END OF OVERS *)
| 
| BEGIN     (* UNFLAG *)
|  WITH L DO
|   BEGIN
|      FUP := 0; (* NO CASE FORCING *)
|      VCHN := 0;
|      RCHN := 0;
|      LN := 1;
|      OUTF := ':';
|      PQEND := FALSE;
|      WHILE LN<=LEN DO
|       BEGIN
|        OVER := FALSE;
|       IF NOT ( (LIN(/LN/) = '''' )  OR
|                (LIN(/LN/) = '"'  )  OR
|                (LIN(/LN/) = ')'  )       ) THEN PQEND := FALSE;
|       SKIP := FALSE;
|        CASE LIN(/LN/) OF
|         '^':
|           BEGIN
|            LN := LN + 1;
|            CASE FUP OF
|             2: OUTF := '^';
|             0:
|              IF FLAG THEN
|               BEGIN
|                IF NOT(LOWER AND INALPHA( LIN(/LN/) ) ) THEN
|                 OUTF := '^';
|               END
|              ELSE  OUT('^');
|             1:
|            END;
|           END;
|         'A','B','C','D','E','F','G',
|         'H','I','J','K','L','M','N',
|         'O','P','Q','R','S','T','U',
|         'V','W','X','Y','Z':
|           CASE FUP OF
|            0: IF LOWER AND FLAG THEN OUTF := '^';
|            2: OUTF := '^';
|            1:
|           END;
|         '@':
|           BEGIN
|            LN := LN + 1;
|            IF FLAG  THEN BEGIN
|                          CASE LIN(/LN/) OF
|                                'A':LIN(/LN/):='@';
|                                'B':LIN(/LN/):='^'
|                               END;
|                          OUTF:=':';
|                          OUT(LIN(/LN/))
|                          END;
|           END;
|         '<':
|           IF FLAGCAPS THEN
|            BEGIN FUP := FUP + 1; IF FUP=3 THEN FUP := 1; SKIP := TRUE;
|            END;
|         '.','?','!':
|          BEGIN
|          CAPNEXT := AUTOCAP AND LOWER;
|          IF PERIOD THEN PQEND := TRUE;
|          END;
|         '_':
|           IF ESCCHR THEN LN := LN + 1;
|         '#':
|          IF FLAGSIG THEN
|           BEGIN
|            OUT(' ');
|            SKIP := TRUE;
|            IF UNDL AND USB THEN OVERS('_');
|           END;
|         '\':
|           IF FLAGOVER THEN
|            BEGIN LN := LN + 1; OVER := TRUE; SKIP := TRUE END;
|          '0'..'9' : CAPNEXT := FALSE;
|         '+','-','*','/',
|         '(',')','$','=',' ',',',
|         '[',']',   '%','"',
|         '&','''','>',';',':' :
|        END;
|        IF NOT SKIP THEN
|         BEGIN
|          OUT(LIN(/LN/)); VCHN := VCHN + 1;
|          IF UNDL THEN OVERS('_');
|         END
|        ELSE IF OVER THEN OVERS(LIN(/LN/));
|        LN := LN + 1
|       END;
|    WITH TMPL DO BEGIN LEN := RCHN; VLEN := RCHN END;
|   END;
| END;     (*$END OF UNFLAG *)
| PROCEDURE ADRC(C: CHAR);
| BEGIN
|  WITH SYL DO
|   BEGIN
|    LEN := LEN + 1;
|    IF ROMLC
|       THEN LIN(/LEN/) := LOWERTHECASE(C)
|       ELSE LIN(/LEN/) := C;
|    LINT(/LEN/).LINC := BLANKLINC;
|   END;
| END;     (* END OF ADRC *)
| 
| PROCEDURE ROMAN(N: INTEGER);
| BEGIN
|     WHILE N > 1000 DO
|        BEGIN     ADRC('M');    N := N - 1000;       END;
|     IF N > 500 THEN
|        BEGIN     ADRC('D');    N := N - 500;        END;
|     WHILE N > 100 DO
|        BEGIN     ADRC('C');    N := N - 100;        END;
|     IF N > 50 THEN
|        BEGIN     ADRC('L');    N := N - 50;         END;
|     WHILE N > 10 DO
|        BEGIN     ADRC('X');    N := N - 10;         END;
|     IF N > 5 THEN
|        BEGIN     ADRC('V');    N := N - 5;          END;
|     WHILE N > 0 DO
|        BEGIN     ADRC('I');    N := N - 1;          END;
| END;     (* END OF ROMAN *)
| 
| PROCEDURE DOFMT(F,N: INTEGER);
| BEGIN
| SYL.LEN := 0;
| IF (F>=0) AND (F<=5) THEN
|  CASE F OF
|   0: BEGIN SYL.LEN := 1; ADDNUM(N,SYL); SYL.LEN := SYL.LEN - 1; END;
|   1: BEGIN
|       SYL.LIN(/1/) := LETTERS(/ (N-1) MOD 26 /);
|       SYL.LINT(/1/).LINC := BLANKLINC;
|       SYL.LEN := 1;
|      END;
|   2: BEGIN
|       SYL.LIN(/1/) := LOWERTHECASE(LETTERS(/ (N-1) MOD 26 /) );
|       SYL.LINT(/1/).LINC := BLANKLINC;
|       SYL.LEN := 1;
|      END;
|   3: BEGIN ROMLC := FALSE; ROMAN(N); END;
|   4: BEGIN ROMLC := TRUE; ROMAN(N); END;
|   5: BEGIN
|       SYL.LIN(/1/) := CHR( N MOD CHARSIZE);
|       SYL.LINT(/1/).LINC := BLANKLINC;
|       SYL.LEN := 1;
|      END
|  END;
| IF SYL.LEN>0 THEN BEGIN UNFLAG(SYL,FALSE); ADDWORD; END;
| END;     (* END OF DOFMT *)
| 
| PROCEDURE BREAK;
| BEGIN
|  PUTLINE;
| END;     (* END OF BREAK *)
| 
| PROCEDURE CR;
| BEGIN
|  FOR LN:=2 TO VAL(/VSP/) DO PUTBLANK;
| END;     (* END OF CR *)
| 
| PROCEDURE ENDPARA;
| BEGIN
|  BREAK; CR;
| END;     (* END OF ENDPARA *)
| 
| PROCEDURE BLANKLINE;
| BEGIN
|  IF (NOT AP) THEN
|   BEGIN
|    ENDPARA;
|    PUTBLANK
|   END
|  ELSE BEGIN FORCECMD('.PP       ',3); SYMTYPE := COMMAND END;
| END;     (* END OF BLANKLINE *)
| 
| PROCEDURE ENDLINE;
| BEGIN
|  IF SUP THEN CLRLINE;
|  IF FORCE OR (NOT FILL) OR OTL.CENTER THEN BREAK;
|  IF FORCE OR (NOT FILL) THEN CR;
| END;      (* END OF ENDLINE *)
| 
| PROCEDURE FIN;
| BEGIN
|  PUTLINE;
|  DOTOP;
|   WRITELN;
|   IF ERRORS > 0 THEN WRITELN(ERRORS:9,' ERRORS ENCOUNTERED.');
| END;     (* END OF FIN *)
| (*
| PROCEDURE DBUGWORD;
| BEGIN
|  WITH SYL DO
|   BEGIN
|    WRITE(LEN,' ');
|    FOR LN:=1 TO LEN DO WRITE(LIN(/LN/));
|    WRITELN(' (',LEN:3,',',VLEN:3,')');
|   END
| END;     (* END OF DBUGWORD *)             *)
| 
| PROCEDURE PUTWORD;
| BEGIN
|  UNFLAG(SYL,LOWER);
|  ADDWORD;
| END;     (* END OF PUTWORD *)
| 
| PROCEDURE PUTVAR;
| VAR N: INTEGER; S: SIGN;
| BEGIN
|  GETNUM(S,N);
|  IF S<>INVALID THEN
|   BEGIN
|    IF SHOWEXPR THEN
|     BEGIN
|      SYL.LEN := 1;
|      SYL.VLEN := 1;
|      ADDNUM(N,SYL);
|      SYL.LEN := SYL.LEN - 1;
|      SYL.VLEN := SYL.VLEN - 1;
|      PUTWORD;
|     END
|   END
|  ELSE PUTWORD;
| END;     (* END OF PUTVAR *)
|  (*$E           *)
| PROCEDURE INISTDMACS;
| VAR P: PMAC;
| BEGIN
|  (* .FRCPAGE *)
|  MACLSTP := NIL;
|  NEW(P);
|  WITH P@ DO
|   BEGIN
|    ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
|    EN := 60; MT := HEADER; NP := 0;
|    NEW(LI);
|    FOR SUB := 1 TO 60 DO LI@(/SUB/) := LITERAL1(/SUB/);
| 
|    NM := 'FRCPAGE   ';
|   END;
|  MACLSTP := P; NEW(P);
|  (* ..NMP *)
|  WITH P@ DO
|   BEGIN
|    ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
|    EN := 57; MT := HEADER; NP := 0;
|    NEW(LI);
|    FOR SUB := 1 TO 57 DO LI@(/SUB/) := LITERAL2 (/SUB/);
| 
|    NM := '.NMP      ';
|   END;
|  MACLSTP := P; NEW(P);
|  (* ..NONMP *)
|  WITH P@ DO
|   BEGIN
|    ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
|    EN := 16; MT := HEADER; NP := 0;
|    NEW(LI);
|    FOR SUB := 1 TO 16 DO LI@ (/SUB/) := LITERAL3 (/SUB/);
|    NM := '.NONMP    ';
|   END;
|  MACLSTP := P; NEW(P);
|  (* ..TTL *)
|  WITH P@ DO
|   BEGIN
|    ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
|    EN := 1; MT := HEADER; NP := 0;
|    NEW(LI); NM := '.TTL      ';
|   END;
|  MACLSTP := P; TTLMACP := P; NEW(P);
|  (* ..STL *)
|  WITH P@ DO
|   BEGIN
|    ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
|    EN := 1; MT := HEADER; NP := 0;
|    NEW(LI); NM := '.STL      ';
|   END;
|  MACLSTP := P; STLMACP := P; NEW(P);
|  (* ..CH *)
|  WITH P@ DO
|   BEGIN
|    ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
|    EN := 65; MT := HEADER; NP := 0;
|    NEW(LI);
|    FOR SUB := 1 TO 38 DO LI@ (/SUB/) := LITERAL4(/SUB/);
|    FOR SUB := 1 TO 27 DO LI@ (/SUB+38/) := LITERAL5(/SUB/);
|    NM := '.CH       ';
|   END;
|  MACLSTP := P; NEW(P);
|  (* ..CHT *)
|  WITH P@ DO
|   BEGIN
|    ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
|    EN := 1; MT := HEADER; NP := 0;
|    NEW(LI); NM := '.CHT      ';
|   END;
|  MACLSTP := P; CHTMACP := P;
| END;     (* END OF INISTDMACS *)
|  (*$E *)
| PROCEDURE INIRELS;
| BEGIN
|  ARELOPR(/EQ/)       := 'EQ        ';
|  ARELOPR(/GT/)       := 'GT        ';
|  ARELOPR(/LT/)       := 'LT        ';
|  ARELOPR(/NE/)       := 'NE        ';
|  ARELOPR(/GE/)       := 'GE        ';
|  ARELOPR(/LE/)       := 'LE        ';
| END;     (* END OF INIRELS *)
| 
| PROCEDURE INIVARS;
| BEGIN
|  VID(/VPAGE/)        := '$PAGE     ';  VTY(/VPAGE/) := VITEM;
|  VID(/VCH/)          := '$CH       ';  VTY(/VCH/) := VITEM;
|  VID(/VHL/)          := '$HL       ';  VTY(/VHL/) := VARRAY;
|          VUP(/VHL/) :=5;
|  VID(/VLIST/)        := '$LIST     ';  VTY(/VLIST/) := VARRAY;
|          VUP(/VLIST/) := 5;
|  VID(/VLM/)          := '$LM       ';  VTY(/VLM/) := VITEM;
|  VID(/VRM/)          := '$RM       ';  VTY(/VRM/) := VITEM;
|  VID(/VSP/)          := '$SP       ';  VTY(/VSP/) := VITEM;
|  VID(/VNMP/)         := '$NMP      ';  VTY(/VNMP/) := VITEM;
|  VID(/VOLNO/)        := '$OLNO     ';  VTY(/VOLNO/) := VITEM;
|  VID(/VPRM/)         := '$PRM      ';  VTY(/VPRM/) := VITEM;
|  TV := 26;
|  FOR LN := 1 TO VARMAX DO VAL(/LN/) := 0;
| END;     (* END OF INIVARS *)
| 
| PROCEDURE INICMDS;
| BEGIN
|  CMDS(/CBLANK/)      := 'B         ';
|  CMDS(/CFLAG/)       := 'FLAG      ';
|  CMDS(/CFLAGCAPS/)   := 'FLAGCAPS  ';
|  CMDS(/CFLAGOVER/)   := 'FLAGOVER  ';
|  CMDS(/CFLAGSIG/)    := 'FLAGSIG   ';
|  CMDS(/CLOWER/)      := 'LOWER     ';
|  CMDS(/CUPPER/)      := 'UPPER     ';
|  CMDS(/CPERIOD/)     := 'PERIOD    ';
|  CMDS(/CBREAK/)      := 'BR        ';
|  CMDS(/CCR/)         := 'CR        ';
|  CMDS(/CESCCHR/)     := 'ESC       ';
|  CMDS(/CASCII   /)   := 'ASCII     ';
|  CMDS(/CCENTER/)     := 'C         ';
|  CMDS(/CJUST/)       := 'J         ';
| (*MDS(/CUL/)         := 'UL        ';
|        *)
|  CMDS(/CLMAR/)       := 'LM        ';
|  CMDS(/CRMAR/)       := 'RM        ';
|  CMDS(/CSUP/)        := 'SUP       ';
|  CMDS(/CSTD/)        := 'STD       ';
|  CMDS(/CPS/)         := 'PS        ';
|  CMDS(/CLPT/)        := 'LPT       ';
|  CMDS(/CSAV/)        := 'SAV       ';
|  CMDS(/CP/)          := 'P         ';
|  CMDS(/CRES/)        := 'RES       ';
|  CMDS(/CPP/)         := 'PP        ';
|  CMDS(/CSP/)         := 'SP        ';
|  CMDS(/CS/)          := 'S         ';
|  CMDS(/CTP/)         := 'TP        ';
|  CMDS(/CNMP/)        := 'NMP       ';
|  CMDS(/CPNO/)        := 'PNO       ';
|  CMDS(/CTITLE/)      := 'TITLE     ';
|  CMDS(/CST/)         := 'ST        ';
|  CMDS(/CATITLE/)     := 'ATITLE    ';
|  CMDS(/CLIST/)       := 'LIST      ';
|  CMDS(/CLE/)         := 'LE        ';
|  CMDS(/CELIST/)      := 'ELIST     ';
|  CMDS(/CFIG/)        := 'FIG       ';
|  CMDS(/CBAR/)        := 'BAR       ';
|  CMDS(/CBB/)         := 'BB        ';
|  CMDS(/CEB/)         := 'EB        ';
|  CMDS(/CU/)          := 'U         ';
|  CMDS(/CT/)          := 'T         ';
|  CMDS(/CTAB/)        := 'TAB       ';
|  CMDS(/CTABS/)       := 'TABS      ';
|  CMDS(/CRT/)         := 'RT        ';
|  CMDS(/CCH/)         := 'CH        ';
|  CMDS(/CAP/)         := 'AP        ';
|  CMDS(/CI/)          := 'I         ';
|  CMDS(/CFILL/)       := 'F         ';
|  CMDS(/CSIG/)        := 'SIG       ';
|  CMDS(/CPAGE/)       := 'PAGE      ';
|  CMDS(/CTOP/)        := 'TOP       ';
|  CMDS(/CMID/)        := 'MID       ';
|  CMDS(/CBOT/)        := 'BOT       ';
|  CMDS(/CARRAY/)      := 'ARRAY     ';
|  CMDS(/CFMT/)        := 'FMT       ';
|  CMDS(/CIF/)         := 'IF        ';
|  CMDS(/CASIS/)       := 'ASIS      ';
|  CMDS(/CDOT/)        := 'DOT       ';
|  CMDS(/CREM/)        := 'REM       ';
|  CMDS(/CUPP/)        := 'UP        ';
|  CMDS(/CUSB/)        := 'USB       ';
|  CMDS(/CADD/)        := 'ADD       ';
|  CMDS(/CHL/)         := 'HL        ';
|  CMDS(/CRIGHT/)      := 'RIGHT     ';
|  CMDS(/CLINES/)      := 'LINES     ';
|  CMDS(/CMACRO/)      := 'MACRO     ';
|  CMDS(/CX/)          := 'X         ';
|  CMDS(/CVAR/)        := 'VAR       ';
|  CMDS(/CINC/)        := 'INC       ';
|  CMDS(/CDEC/)        := 'DEC       ';
|  CMDS(/CSAVPAG/)     := 'SAVPAG    ';
|  CMDS(/CRESPAG/)     := 'RESPAG    ';
|  CMDS(/CDATE/)       := 'DATE      ';
|  CMDS(/CTIME/)       := 'TIME      ';
|  CMDS(/CDELMAC/)     := 'DELMAC    ';
|  CMDS(/CAUTOCAP/)    := 'AUTOCAP   ';
|  CMDS(/CDEBUG1/)     := 'DEBUG1    ';
|  CMDS(/CDEBUG2/)     := 'DEBUG2    ';
|  BREAKSET := (/CCENTER,CTITLE,CST,CI,CCH,CLE,CLIST,CELIST,CHL,CCR,
|               CPP,CPAGE,CFIG,CS,CTP,CBLANK,CASIS,CBREAK,CRES,CRESPAG/);
|  CRSET := BREAKSET - (/CBREAK,CBLANK,CRES,CRESPAG/);
| END;     (*$END OF INICMDS *)
| PROCEDURE BACKUPSYL;
| BEGIN CUP := LASTCUP END;
|      (* END OF BACKUPSYL *)
| 
| PROCEDURE POPMACROS; (* CLEAR ALL ACTIVE MACROS *)
| BEGIN
|  WHILE ACTP@.CA<>NIL DO
|   BEGIN ACTP@.ON := FALSE; ACTP := ACTP@.CA; END
| END;     (* END OF POPMACROS *)
| 
| PROCEDURE GETCUR;
|    VAR I : INTEGER;
| BEGIN
|  IF NOT EOF(INPUT) THEN
|   BEGIN
|    ILNO := ILNO + 1;
|    BEG := 1; CUP := 1; ENL := 1;
|    WHILE NOT EOLN DO
|     BEGIN CUR(/ENL/) := INPUT@; GET(INPUT); ENL := ENL + 1 END;
|    CUR(/ENL/) := ' ';
|    WITH ACTP@ DO
|     BEGIN LI@ := CUR; BE := BEG; EN := ENL END;
|    READLN(INPUT);
|    WRITE (QRR,' ',ILNO:6,'  ');
|    FOR I := 1 TO ENL DO WRITE (QRR,CUR(/I/) );
|    WRITELN(QRR);
|   END
|  ELSE EOFINPUT := TRUE
| END;     (* END OF GETCUR *)
| 
| PROCEDURE GETTOKEN;
| BEGIN        (* GETTOKEN *)
|  IF DEFRSYM THEN DEFRSYM := FALSE
|  ELSE
|   WITH SYL DO
|    BEGIN
|     FOR LN:=1 TO MACMAX+1 DO BEGIN LIN(/LN/) := ' ';
|                                    LINT(/LN/).LINC := BLANKLINC    END;
|     LEN := 0;
|     VLEN := 0;
|     LASTCUP := CUP;
|     IF (CUR(/CUP/)=' ') AND SIGBL AND NOT CMMD THEN
|      WHILE (CUP<ENL) AND (CUR(/CUP/)=' ') DO
|       BEGIN LEN := LEN + 1; LIN(/LEN/) := CUR(/CUP/); CUP := CUP + 1;
|                   LINT(/LEN/).LINC := BLANKLINC   END
|     ELSE
|      BEGIN
|       WHILE (CUP<ENL) AND (CUR(/CUP/)=' ') DO CUP := CUP + 1;
|       CUR(/ENL/) := ' ';
|       WHILE (CUR(/CUP/) <> ' ') AND (CUP <= ENL) DO
|        BEGIN LEN := LEN + 1; LIN(/LEN/) := CUR(/CUP/); CUP := CUP + 1;
|                     LINT(/LEN/).LINC := BLANKLINC; END
|      END
|    END;
| END;     (* END OF GETTOKEN *)
| 
| PROCEDURE GETMACSYM;
| VAR EXIT: BOOLEAN;
| BEGIN      (*GETMACSYM *)
|  REPEAT
|   GETTOKEN;
|   EXIT := TRUE;
|   IF SYL.LEN=0 THEN
|    BEGIN
|     ACTP@.ON := FALSE;
|     IF ACTP@.CA<>NIL THEN
|      BEGIN
|       EXIT := FALSE;
|       ACTP := ACTP@.CA;
|       WITH ACTP@ DO
|        BEGIN
|         CUR := LI@;
|         CUP := CU; BEG := BE; ENL := EN;
|        END
|      END
|    END
|  UNTIL EXIT
| END;     (* END OF GETMACSYM *)
| 
| PROCEDURE EXPMACRO(T: PMAC);
| VAR N: 0..8;
| BEGIN  (* EXPMACRO *)
|  T@.CA := ACTP;                                  (* CHAIN NEW MACRO  *)
|  ACTP := T;                                      (* NEW CURRENT MACRO*)
|  IF T@.NP<8 THEN                                 (* SCAN PARMS       *)
|   FOR N:=T@.NP DOWNTO 1 DO
|    BEGIN
|     T := T@.MA;                                  (* PARM MACRO       *)
|     WITH T@ DO
|      BEGIN
|       BE := CUP;
|       GETTOKEN;
|       EN := CUP;
|       LI@ := ACTP@.CA@.LI@;
|      END
|    END
|  ELSE
|   BEGIN                                    (* REST OF LINE IS PARM *)
|    T := T@.MA;
|    WITH T@ DO
|     BEGIN BE := CUP; EN := ENL; LI@ := ACTP@.CA@.LI@ END;
|    CUP := ENL
|   END;
|  ACTP@.CA@.CU := CUP;
|  WITH ACTP@ DO                                   (* NOW FILL CUR   *)
|   BEGIN
|    ON := TRUE;
|    CUP := BE; BEG := BE; ENL := EN;
|    CUR := LI@;
| 
| 
|   END;
| END;      (* END OF EXPMACRO *)
| 
| PROCEDURE LOOKUPVAR;
| VAR T: ALFA;
| BEGIN  (* LOOKUPVAR *)
|  UPCASESYL;
|  FOR SUB := 1 TO 10 DO T(/SUB/) := SYL.LIN(/SUB+1/);
|  VID(/TV/) := T;
|  VARNDX := 1;
|  WHILE VID(/VARNDX/)<>T DO VARNDX := VARNDX + 1;
| END;     (* END OF LOOKUPVAR *)
| 
| PROCEDURE LOOKUPMAC;
| VAR L: MACSYM;
|  T: PMAC;
|  EXIT: BOOLEAN;
| BEGIN
|  UPCASESYL;
|  FOR SUB := 1 TO 10 DO L(/SUB/) := SYL.LIN (/SUB + 1/);
|  T := MACLSTP;
|  EXIT := FALSE;
|  REPEAT
|   IF T=NIL THEN BEGIN EXIT := TRUE; NOTMACRO := TRUE END
|   ELSE
|    IF L=T@.NM THEN
|     BEGIN EXIT := TRUE;
|      IF T@.ON THEN
|       BEGIN
|        ERR; WRITE('RECURSIVE MACRO CALL TO'); SYLERR;
|        NOTMACRO := FALSE;
|       END
|      ELSE
|       BEGIN
|        EXPMACRO(T);
|        NOTMACRO := FALSE;
|       END
|     END
|   ELSE T := T@.MA
|  UNTIL EXIT;
| END;     (* END OF LOOKUPMAC *)
| 
| 
| PROCEDURE GETSYM;
| VAR
|  START: 2..4;
|  I,J: INTEGER;
|  PIN:  ARRAY (/1..10/) OF CHAR;
| BEGIN   (* GETSYM *)
|   WITH SYL DO
|    BEGIN
|     REPEAT
|      GETMACSYM;
|      NOTMACRO := TRUE;
|      IF LIN(/1/)=MACCHR THEN LOOKUPMAC
|     UNTIL NOTMACRO;
|     IF LEN=0 THEN SYMTYPE := NONE
|     ELSE IF (NOT (INDIGIT ( LIN(/2/) ))) AND (LIN(/1/)=CMDCHR) THEN
|      BEGIN
|       SYMTYPE := COMMAND;
|       START := 2;
|       YES := TRUE;
|       IF (LEN>3) AND (LIN(/2/)='N') AND (LIN(/3/)='O') THEN
|        BEGIN YES := FALSE; START := 4 END;
|       FOR LN:=LEN+1 TO START+9 DO BEGIN LIN(/LN/) := ' ';
|                                   LINT(/LN/).LINC := BLANKLINC END;
|       FOR SUB := 1 TO 10 DO PIN(/SUB/) := LIN(/SUB + START -1/);
|       CMDS(/NOTCMD/) := PIN;
|       CMDTYPE := CBLANK;
|       WHILE PIN<>CMDS(/CMDTYPE/) DO CMDTYPE := SUCC(CMDTYPE);
|       IF CMDTYPE=NOTCMD THEN
|        BEGIN ERR; WRITE('UNKNOWN COMMAND'); SYLERR END;
|      END
|     ELSE IF (SYL.LIN(/1/)=VARCHR)
|             AND  NOT (INDIGIT(SYL.LIN(/2/)) OR (SYL.LIN(/2/)=' ') )  THEN
|               SYMTYPE := VARS
|     ELSE SYMTYPE := WORD
|    END;
| END;     (* END OF GETSYM *)
| 
| PROCEDURE ALLOC(VAR T: PMAC);
| LABEL 1;
| VAR P: PMAC;
| BEGIN           (* ALLOC *)
|  P := FREEMACP;
|  1:
|   IF P<>NIL THEN
|    IF P@.ON THEN BEGIN P := P@.MA; GOTO 1 END;
|  IF P=NIL THEN
|   BEGIN
|    NEW(T);
|    NEW(T@.LI);
|    T@.MA := FREEMACP;
|    FREEMACP := T;
|   END
|  ELSE T := P;
| END;     (* END OF ALLOC *)
| 
| PROCEDURE PUSHSYL (* (S:LINE) ; FROM THE FORWARD DECL *)  ;
| VAR M: PMAC;
| BEGIN
|  ALLOC(M);
|  WITH M@ DO
|   BEGIN
|    ON := FALSE;
|    CU := 1; BE := 1; EN := S.LEN + 1;
|    MT := HEADER; NP := 0;
|    LI@ := S.LIN;
|    NM := '* DEFER * ';
|   END;
|  EXPMACRO(M);
| END;     (* END OF PUSHSYL *)
| 
| FUNCTION GETEXP: INTEGER;
| BEGIN
|  GETSYM;
|  EP := 0;
|  NEXTCH;
|  GETEXP := EXPR;
| END;     (* END OF GETEXP *)
| 
| 
| PROCEDURE SETSTD;
| BEGIN
|  FLAG := YES; FLAGCAPS := YES; LOWER := YES;
|  ESCCHR := YES; PERIOD := YES; JUSTIT := YES;
|  LOWER := YES; FILL := YES; SIGBL := NOT YES;
|  IF YES THEN OPTBRKSET := BREAKSET
|  ELSE OPTBRKSET := (//);
| END;     (* END OF SETSTD *)
|  (*$E *)
| PROCEDURE DOCOMMAND;
| VAR
|  S: SIGN;
|  I,N,LN: INTEGER;
|  N8: 0..8;
|  L: LLEN;
|  TMACP,MACP: PMAC;
|  EXIT: BOOLEAN;
|  TL: LINE;
|  VTEMP: 1..VARMAX;
|  V: ALFA;
| 
| PROCEDURE STUFFMAC(P: PMAC);
| BEGIN     (* STUFFMAC *)
|  WITH P@ DO
|   IF YES THEN
|    BEGIN
|     LI@ := CUR;
|     BE := CUP; CU := CUP; EN := ENL;
|     CUP := ENL;
|    END
|   ELSE CU := EN;
| END;    (* END OF STUFFMAC *)
| 
| PROCEDURE SYLTOMAC;
| BEGIN
|  WITH TMACP@ DO
|   BEGIN
|    FOR SUB := 1 TO MACMAX DO NM(/SUB/) := SYL.LIN(/SUB/);
|    CU := 0; BE := 0; EN := 0; NP := 0;
|    CA := NIL; LI := ACTP@.LI; ON := FALSE;
|   END;
| END;     (* END OF SYLTOMAC *)
| 
| PROCEDURE MAKPARM;
| BEGIN
|  SYL := TL;
|  ADDNUM(N-N8+1,SYL);
|  NEW(TMACP); SYLTOMAC;
|  WITH TMACP@ DO
|   BEGIN
|    MA := MACP@.MA; MACP@.MA := TMACP;
|    NP := 0; MT := PARM;
|    NEW(LI);
|    MACP := TMACP;
|   END;
| END;     (* END OF MAKPARM *)
| 
| PROCEDURE CLRLISTS;
| BEGIN
|  ENP := 0;
|  VAL(/VLIST/) := 0;
| END;     (* END OF CLRLISTS *)
| 
| PROCEDURE GETOPTN;
| BEGIN
|  GETSYM;
|  IF ((INDIGIT( SYL.LIN(/1/))) OR
|      (SYL.LIN (/1/) = '$')    OR
|      (SYL.LIN (/1/) = '(')        )      THEN
|   BEGIN
|    GETNUM(S,N);
|    IF (S=INVALID) OR (N<=0) THEN
|     BEGIN
|      ERR; WRITE('EXPECTING POSITIVE NUMBER; GOT'); SYLERR;
|      S := INVALID;
|     END;
|   END
|  ELSE BEGIN BACKUPSYL; S := INVALID; END;
| END;     (* END OF GETOPTN *)
| 
| PROCEDURE GETSN;
| BEGIN GETSYM; GETNUM(S,N) END;
|      (* END OF GETSN *)                                   (*$E *)
|     PROCEDURE CPPROC;  (* MOVED HERE FOR ADDRESABILITY REASONS *)
|        BEGIN          (* CPPROC *)
|         GETSN;
|         IF (S<>INVALID) THEN
|          BEGIN
|           CASE S OF
|            UNSIGNED: BEGIN PREL := FALSE; PMAR := N END;
|            MINUS:    BEGIN PREL := TRUE;  PMAR := -N END;
|            PLUS:     BEGIN PREL := TRUE;  PMAR := N END
|           END;
|           GETSN;
|           IF (S=UNSIGNED) AND (N>=0) AND (N<=5) THEN
|            BEGIN
|             PARSPACE := N;
|             GETSN;
|             IF (S=UNSIGNED) THEN
|              PARTEST := N
|             ELSE BEGIN ERR; WRITE('PARAGRAPH TP'); SYLERR END
|            END
|           ELSE BEGIN ERR; WRITE('PARAGRAPH SPACE'); SYLERR END
|          END
|         ELSE BEGIN ERR; WRITE('PARAGRAPH INDENT'); SYLERR END
|        END;       (* CPPROC *)
| 
| 
| 
| 
|      PROCEDURE CHLPROC;   (* MOVED HERE FOR ADDRESSABILITY REASONS *)
|      BEGIN     (* CHLPROC *)
|        IF (OVETXT-VAL(/VOLNO/)+1)>8 THEN
|         BEGIN
|          CLRLISTS;
|          GETSN;
|          IF (S=UNSIGNED) AND (N>0) AND (N<=VHLMAX) AND
|          (N<=VAL(/VHL/)+1) THEN
|           BEGIN
|            IF FIRSTCH THEN BEGIN SAVENV(PAGENV); FIRSTCH := FALSE END;
|            RESENV(PAGENV); ENP := 0; CLRLINE;
|            FOR LN:=1 TO 3 DO PUTBLANK;
|            IF N>VAL(/VHL/) THEN VAL(/VHL+N/) := 0;
|            VAL(/VHL/) := N;
|            N := VHL + N;
|            VAL(/N/) := VAL(/N/) + 1;
|            IF VAL(/VCH/)>0 THEN BEGIN LN := VHL+1; ADDNUM(VAL(/VCH/),OTL) END
|               ELSE BEGIN LN := VHL+2; ADDNUM(VAL(/VHL+1/),OTL) END;
|            FOR LN:=LN TO N DO BEGIN ADDCHR('.'); ADDNUM(VAL(/LN/),OTL) END;
|            ADDCHR(' '); ADDCHR(' ');
|            DEFRB := 1; FORCE := TRUE;
|           END
|          ELSE BEGIN ERR; WRITE('BAD HEADER LEVEL'); SYLERR END;
|         END
|        ELSE BEGIN BACKUPSYL; FORCECMD('.FRCPAGE  ',8) END;
|        CAPNEXT := AUTOCAP AND LOWER;
|     END;        (* CHLPROC *)                                    (*$E *)
| 
| 
| 
|     PROCEDURE CMACROPROC;    (* MOVED HERE FOR ADDRESSABILITY REASONS *)
|      BEGIN    (* CMACROPROC *)
|        IF ACTP@.CA=NIL THEN
|         BEGIN
|          GETTOKEN;
|          IF SYL.LEN<>0 THEN
|           BEGIN
|            NEW(TMACP);
|            UPCASESYL;
|            SYLTOMAC;
|            NEW(TMACP@.LI);
|            TMACP@.MA := MACLSTP;
|            TMACP@.MT := HEADER;
|            TL := SYL;                              (* SAVE MACRO NAME  *)
|            TL.LEN := TL.LEN + 1;                   (* FOR ADDNUM       *)
|            IF TL.LEN>10 THEN TL.LEN := 10;
|            GETTOKEN;
|            IF NOT ((SYL.LIN(/1/) = '*' ) OR
|                    (SYL.LIN(/1/) = '=' ) ) THEN GETNUM (S,N)
|                ELSE S := INVALID;
|            IF S=UNSIGNED THEN GETTOKEN
|               ELSE IF (SYL.LIN(/1/)='*') AND (SYL.LEN=1) THEN
|                       BEGIN N := 8; GETTOKEN END
|                       ELSE N := 0;
|            IF (SYL.LIN(/1/)='=') AND (SYL.LEN=1) THEN
|               BEGIN
|               MACLSTP := TMACP;
|               WITH TMACP@ DO
|                 BEGIN
|                 FOR SUB:=1 TO (LINLEN-CUP+1) DO LI@ (/SUB/):=CUR(/SUB-1+CUP/);
|                 BE := 1;
|                 EN := ENL-CUP+1;
|                 CU := 1
|                 END;
|               IF N<8 THEN
|                BEGIN
|                 TMACP@.NP := N;
|                 MACP := MACLSTP;
|                 FOR N8:=N DOWNTO 1 DO MAKPARM
|                 END
|              ELSE
|               BEGIN
|                TMACP@.NP := 8; N8 := N;
|                MACP := MACLSTP;
|                MAKPARM
|               END;
|              CUP := ENL;
|             END
|            ELSE BEGIN ERR; WRITE('MISSING = IN MACRO DEF'); ERRE END
|           END
|          ELSE BEGIN ERR; WRITE('NO MACRO NAME'); ERRE END;
|         END
|        ELSE BEGIN ERR; WRITE('NESTED MACRO DEFS'); ERRE END;
|       END;    (* CMACROPROC *)
| 
| 
| 
| 
|      PROCEDURE CVARPROC;   (* MOVED HERE FOR ADDRESSABILITY REASONS *)
|        BEGIN
|         GETSYM;
|         IF SYMTYPE=VARS THEN
|          BEGIN
|           LOOKUPVAR;
|           IF VARNDX<VARMAX THEN
|            BEGIN
|             IF VARNDX=TV THEN
|              BEGIN TV := TV + 1; VTY(/VARNDX/) := VITEM END;
|             GETMACSYM;
|             IF (SYL.LEN=1) AND (SYL.LIN(/1/)='=') THEN
|              BEGIN
|               GETSN;
|               IF S<>INVALID THEN
|                BEGIN
|                 IF S=MINUS THEN N := -N;
|                 VAL(/VARNDX/) := N
|                END
|              END
|             ELSE BACKUPSYL
|            END
|           ELSE BEGIN ERR; WRITE('TOO MANY VARIABLES'); ERRE END
|          END
|         ELSE BEGIN ERR; WRITE('NEED VAR NAME; GOT'); SYLERR END
|      END;        (* CVARPROC *)
| 
| 
| 
|      PROCEDURE CARRAYPROC;  (* MOVED HERE FOR ADDRESABILITY REASONS *)
|        BEGIN
|         GETSYM;
|         IF SYMTYPE=VARS THEN
|          BEGIN
|           LOOKUPVAR;
|           IF VARNDX=TV THEN
|             BEGIN
|             N := GETEXP;
|             IF (N>0) AND (NOT EXPRERR) THEN
|              IF N+TV<VARMAX THEN
|               BEGIN
|                TV := TV + N + 1;
|                VUP(/VARNDX/) := N;
|                VTY(/VARNDX/) := VARRAY;
|               END
|              ELSE BEGIN ERR; WRITE('NO ROOM FOR ARRAY ',VID(/VARNDX/)); ERRE
|                   END
|             ELSE BEGIN ERR; WRITE('BAD ARRAY SIZE'); SYLERR END
|            END
|           ELSE BEGIN ERR; WRITE('ALREADY DECLARED'); SYLERR END
|          END
|         ELSE BEGIN ERR; WRITE('NOT A VARIABLE SYMBOL'); SYLERR END
|        END;        (* CARRAYPROC *)
| 
| 
| 
|      PROCEDURE CASISPROC;    (* MOVED HERE FOR ADDRESABILITY REASONS *)
|        BEGIN
|         POPMACROS;
|         FOR I:=1 TO LINLEN DO BEGIN OTL.LIN(/I/) := ' ';
|                                     OTL.LINT(/I/).LINC := BLANKLINC  END;
|         IF NOT EOF(INPUT) THEN
|          REPEAT
|           GETCUR;
|           IF CUR(/1/)<>'!' THEN
|            BEGIN
|             LN := VAL(/VLM/); CUP := 1;
|             WHILE CUP < ENL DO (* EACH ITERATION ADDS 1 CHAR TO OTL *)
|              BEGIN
|               OTL.LIN(/LN/) := CUR(/CUP/);
|               OTL.LINT(/LN/).LINC := BLANKLINC;
|               CUP := CUP + 1; LN := LN + 1;
|              END;
|             OTL.LEN := LN; CUP := ENL;
|             EMPTY := FALSE;
|             PUTLINE;
|            END;
|          UNTIL (CUR(/1/)='!') OR DEFRSYM OR EOFINPUT;
|         CUP := CUP+1;
|         IF DEFRSYM THEN PUSHSYL(FRCSYL);
|        END;     (* CASISPROC *)
|   (*$E    *)
| BEGIN       (* DOCOMMAND *)
|  IF CMDTYPE<=CDEC THEN BEGIN          (* PROTECT AGAINST SET OUT OF RANGE *)
|                        IF CMDTYPE IN OPTBRKSET THEN BREAK;
|                        IF CMDTYPE IN CRSET THEN CR;           END;
|  (* ABOVE BREAK MAY FORCE PAGE EJECT;
|     USE DEFRSYM FLAG TO TEST FOR THIS
|     AND RE-DO COMMAND AFTER EJECT *)
|  IF DEFRSYM THEN PUSHSYL(FRCSYL)
|  ELSE
|  WITH SYL DO
|   BEGIN
|    CASE CMDTYPE OF
| 
|     CBLANK,CLMAR,CRMAR,CPS,CP,CI,CSP,
|     CS,CTP,CHL,CPNO,CLIST,CFIG,CTAB,
|     CTABS,CRIGHT,CLINES,CMACRO,CVAR,
|     CINC,CDEC,CARRAY,CIF,CUPP:
| 
|      CMMD := TRUE;
| 
|     CCR,CBREAK,CRESPAG,CRES,CESCCHR,
|     CASCII,CCENTER,CJUST,(*CUL,*)CFILL,
|     CSIG,CPAGE,CSUP,CLPT,CSTD,CSAV,
|     CPP,CAP,CCH,CNMP,CTITLE,CST,
|     CATITLE,CLE,CELIST,CBAR,CBB,CEB,
|     CU,CT,CRT,CX,CASIS,CDATE,CTIME,
|     CFLAG,CFLAGCAPS,
|     CFLAGOVER,CFLAGSIG,CLOWER,CUPPER,
|     CPERIOD,CSAVPAG,CTOP,
|     CMID,CBOT,CFMT,CDOT,CREM,CUSB,CADD,CAUTOCAP,CDEBUG1,CDEBUG2,NOTCMD:
| 
|    END;
|    CASE CMDTYPE OF
|     CBLANK:
|      (* BREAK FOLLOWED BY N EXTRA BLANK LINES *)
|      BEGIN
|       GETOPTN;
|       IF S<>INVALID THEN FOR LN:=1 TO N DO PUTBLANK
|       ELSE PUTBLANK;
|      END;
|     CFLAG:
|      FLAG := YES;
|     CFLAGCAPS:
|      FLAGCAPS := YES;
|     CLOWER:
|      LOWER := YES;
|     CUPPER:
|      LOWER := NOT YES;
|     CESCCHR:
|      ESCCHR := YES;
|     CPERIOD:
|      PERIOD := YES;
|     CBREAK:
|      (* DOESN'T DO ANYTHING *)
|      BEGIN END;
|     CCR:
|      (* DOESN'T DO ANYTHING *)
|      BEGIN END;
|     CASCII:
|      LOWER := NOT YES;
|     CCENTER:
|      OTL.CENTER := TRUE;
|     CJUST:
|      JUSTIT := YES;
| (*  CUL:
|      UL := YES;              *)
|     CLMAR:
|      BEGIN GETSN;
|       IF OTL.LEN=VAL(/VLM/) THEN OTL.LEN := 0;
|       CASE S OF
|        MINUS:    IF (VAL(/VLM/)-N)<0 THEN
|                   BEGIN ERR; WRITE('LM<0'); ERRE END
|                  ELSE VAL(/VLM/) := VAL(/VLM/) - N;
|        PLUS:     IF (VAL(/VLM/)+N)>136 THEN
|                   BEGIN ERR; WRITE('LM>136'); ERRE END
|                  ELSE VAL(/VLM/) := VAL(/VLM/) + N;
|        UNSIGNED: IF (N<1) OR (N>136) THEN
|                   BEGIN ERR; WRITE('LM OUT OF RANGE'); ERRE END
|                  ELSE VAL(/VLM/) := N;
|        INVALID:  BEGIN ERR; WRITE('LM FOLLOWED BY'); SYLERR END
|       END;
|       IF OTL.LEN=0 THEN
|        BEGIN OTL.LEN := VAL(/VLM/); OTL.VLEN := VAL(/VLM/);
|         FOR LN:=1 TO VAL(/VLM/) DO BEGIN OTL.LIN(/LN/) := ' ';
|                                         OTL.LINT(/LN/).LINC := BLANKLINC  END;
|        END
|      END;
|     CRMAR:
|      BEGIN GETSN;
|       CASE S OF
|        PLUS:     IF (VAL(/VRM/)+N)>136 THEN
|                   BEGIN ERR; WRITE('RM>136'); ERRE END
|                  ELSE VAL(/VRM/) := VAL(/VRM/) + N;
|        MINUS:    IF (VAL(/VRM/)-N)<1 THEN
|                   BEGIN ERR; WRITE('RM<1'); ERRE END
|                  ELSE VAL(/VRM/) := VAL(/VRM/) - N;
|        UNSIGNED: IF (N<1) OR (N>136) THEN
|                   BEGIN ERR; WRITE('RM OUT OF RANGE'); ERRE END
|                  ELSE VAL(/VRM/) := N;
|        INVALID:  BEGIN ERR; WRITE('RM FOLLOWED BY'); SYLERR END
|       END;
|      END;
|     CFILL:
|      FILL := YES;
|     CSIG:
|      SIGBL := YES;
|     CPAGE:  BEGIN
|             FORCECMD('.FRCPAGE  ',8);
|             CAPNEXT := AUTOCAP AND LOWER;
|             END;
|     CTOP:
|      DOTOP;
|     CMID:
|      DOMID;
|     CBOT:
|      DOBOT;
|     CSUP:
|      SUP := YES;
|     CLPT:
|      LPT := YES;
|     CSTD:
|      SETSTD;
|     CPS:
|      BEGIN
|       GETSN;
|       IF (S=UNSIGNED) AND (N>10) THEN
|        BEGIN
|         OETXT := N;
|         OVETXT := N - 1;
|         GETSN;
|         IF (S=UNSIGNED) AND (N>0) THEN
|          BEGIN
|           VAL(/VPRM/) := N;
|           PAGENV.PRM := N;
|          END
|         ELSE BEGIN ERR; WRITE('INVALID PS COLUMN'); SYLERR END
|        END
|       ELSE BEGIN ERR; WRITE('INVALID PS LINES'); SYLERR END
|      END;
|     CSAV:
|      PSHENV;
|     CP: CPPROC;
|     CRES:
|      BEGIN POPENV; CLRLINE END;
|     CPP:
|      PARAGRAPH;
|     CAP:
|      AP := YES;
|     CI:
|      BEGIN
|       GETSN;
|       IF S<>INVALID THEN
|        BEGIN
|         CASE S OF
|          PLUS:     N := N + VAL(/VLM/);
|          MINUS:    N := VAL(/VLM/) - N;
|          UNSIGNED:
|         END;
|         IF N>0 THEN
|          BEGIN
|           WITH OTL DO BEGIN
|            LEN := N; VLEN := N;
|            FOR LN:=1 TO N DO BEGIN LIN(/LN/) := ' ';
|                                   LINT(/LN/).LINC := BLANKLINC    END;
|           END
|          END
|         ELSE BEGIN ERR; WRITE('INDENT LESS THAN 0'); ERRE END
|        END
|       ELSE BEGIN ERR; WRITE('I FOLLOWED BY'); SYLERR END
|      END;
|     CSP:
|      BEGIN
|       GETSN;
|       IF (S<>INVALID) AND (N>=1) AND (N<=5) THEN VAL(/VSP/) := N
|       ELSE BEGIN ERR; WRITE('S FOLLOWED BY'); SYLERR END
|      END;
|     CS:
|      (* RETURN PLUS N EXTRA CARRIAGE RETURNS *)
|      BEGIN
|       GETOPTN;
|       IF S<>INVALID THEN FOR LN:=1 TO N*VAL(/VSP/) DO PUTBLANK
|       ELSE FOR LN:=1 TO VAL(/VSP/) DO PUTBLANK;
|      END;
|     CTP:
|      BEGIN
|       GETSN;
|       IF S=UNSIGNED THEN TESTPAGE(N)
|       ELSE BEGIN ERR; WRITE('TP FOLLOWED BY'); SYLERR END
|      END;
|     CCH:
|      BEGIN
|       YES := TRUE;
|       LN := CUP; (*SAVE THIS*)
|       STUFFMAC(CHTMACP);
|       IF ATITLE THEN
|        BEGIN
|         CUP := LN; (*SAME AS ABOVE*)
|         STUFFMAC(TTLMACP);
|         STUFFMAC(STLMACP);
|        END;
|       FORCECMD('..CH      ',4);    CAPNEXT := AUTOCAP AND LOWER;
|      END;
|     CHL: CHLPROC;
|     CNMP:
|      IF YES THEN VAL(/VNMP/) := 1 ELSE VAL(/VNMP/) := 0;
|     CPNO:
|      BEGIN
|       GETSN;
|       IF (S=UNSIGNED) AND (N<1000) THEN VAL(/VPAGE/) := N - 1
|       ELSE BEGIN ERR; WRITE('PAGE NUMBER WAS'); SYLERR END
|      END;
|     CTITLE:
|      BEGIN STUFFMAC(TTLMACP); CAPNEXT := AUTOCAP AND LOWER; END;
|     CST:
|      BEGIN STUFFMAC(STLMACP); CAPNEXT := AUTOCAP AND LOWER; END;
|     CATITLE:
|      ATITLE := YES;
|     CLIST:
|      BEGIN
|       GETSN;
|       IF (S=UNSIGNED) AND (N>0) AND (N<6) THEN
|        BEGIN
|         PSHENV;
|         IF VAL(/VLIST/)=0 THEN VAL(/VLM/) := VAL(/VLM/) + 9
|         ELSE VAL(/VLM/) := VAL(/VLM/) + 4;
|         VAL(/VLIST/) := VAL(/VLIST/) + 1;
|         VAL(/VLIST+VAL(/VLIST/)/) := 0;
|         VAL(/VSP/) := N;
|         PARSPACE := N + 1;
|         PMAR := 0;
|         PREL := TRUE;
|         PSHENV;
|        END
|       ELSE BEGIN ERR; WRITE('LIST SPACING'); SYLERR END;
|      END;
|     CLE:
|      IF VAL(/VLIST/)>0 THEN
|       BEGIN
|        FOR LN:=1 TO VAL(/VSP/) DO PUTBLANK;
|        RESENV(ENSTK(/ENP-1/));
|        CLRLINE;
|        VAL(/VLIST+VAL(/VLIST/)/) := VAL(/VLIST+VAL(/VLIST/)/) + 1;
|        OTL.LEN := VAL(/VLM/) - 4;
|        ADDNUM(VAL(/VLIST+VAL(/VLIST/)/),OTL);
|        ADDCHR('.');
|        OTL.LEN := VAL(/VLM/);
|        OTL.VLEN := VAL(/VLM/);
|       END
|      ELSE BEGIN ERR; WRITE('NO ACTIVE LIST'); ERRE END;
|     CELIST:
|      IF VAL(/VLIST/)>0 THEN
|       BEGIN
|        VAL(/VLIST/) := VAL(/VLIST/) - 1;
|        POPENV; POPENV; CLRLINE;
|       END
|      ELSE BEGIN ERR; WRITE('NO ACTIVE LIST'); ERRE END;
|     CFIG:
|      BEGIN
|       GETSN;
|       IF (S=UNSIGNED) THEN
|        BEGIN
|         IF N<=OVETXT-VAL(/VOLNO/)+1 THEN
|          BEGIN
|           OVBTXT := 0; (* SO PUTBLANK WORKS *)
|           FOR LN:=1 TO N DO PUTBLANK
|          END
|         ELSE
|          BEGIN
|           IF FIGP<FIGMAX THEN
|            BEGIN
|             FIGP := FIGP + 1;
|             FIGN(/FIGP/) := N;
|            END
|           ELSE BEGIN ERR; WRITE('TOO MANY PENDING FIGS'); ERRE END
|          END
|        END
|       ELSE BEGIN ERR; WRITE('FIG FOLLOWED BY'); SYLERR END
|      END;
|     CBAR:
|      BAR := YES;
|     CBB:
|      BEGIN BB := TRUE; OTL.BBAR := TRUE END;
|     CEB:
|        BEGIN
|       IF EMPTY THEN OTL.BBAR := FALSE;
|       BB := FALSE;
|      END;
|     CU:
|      UNDL := YES;
|     CT:
|      T := TRUE;
|     CTAB,CTABS:
|      BEGIN
|       L := 1;
|       CLRTAB;
|       REPEAT
|        GETOPTN;
|        IF S<>INVALID THEN
|         IF L<=TABMAX THEN BEGIN TABS(/L/) := N; L := L + 1 END
|       UNTIL S=INVALID;
|       BACKUPSYL;
|      END;
|     CRT:
|      RT := TRUE;
|     CDOT:
|      DOT := YES;
|     CRIGHT:
|      BEGIN
|       GETSN;
|       IF (S=UNSIGNED) AND (N<=136) THEN RIGHTSPACE := N
|       ELSE BEGIN ERR; WRITE('RIGHT SPACE '); SYLERR END
|      END;
|     CLINES:
|      BEGIN
|       GETSN;
|       IF (S=UNSIGNED) THEN
|        OEPAG := N
|       ELSE BEGIN ERR; WRITE('LINES FOL BY'); SYLERR END
|      END;
|     CMACRO: CMACROPROC;
|     CX:
|      BEGIN XTEND := YES; CAPNEXT := FALSE END;
|     CVAR: CVARPROC;
|     CINC:
|      BEGIN
|       GETSYM;
|       IF SYMTYPE=VARS THEN
|        IF VARNDX<TV THEN VAL(/VARNDX/) := VAL(/VARNDX/) + 1
|        ELSE BEGIN ERR; WRITE('UNDEDECLARED VAR'); SYLERR END
|       ELSE BEGIN ERR; WRITE('INC FOLLOWED BY'); SYLERR END
|      END;
|     CDEC:
|      BEGIN
|       GETSYM;
|       IF SYMTYPE=VARS THEN
|        IF VARNDX<TV THEN VAL(/VARNDX/) := VAL(/VARNDX/) - 1
|        ELSE BEGIN ERR; WRITE('UNDECLARED VAR'); SYLERR END
|       ELSE BEGIN ERR; WRITE('DEC FOLLOWED BY'); SYLERR END
|      END;
|     CSAVPAG:
|      BEGIN SAVENV(PAGENV); FIRSTCH := FALSE END;
|     CRESPAG:
|      RESENV(PAGENV);
|     CARRAY: CARRAYPROC;
|     CFMT:
|      BEGIN N := GETEXP; DOFMT(N,GETEXP) END;
|     CIF:
|      IF GETEXP=0 THEN CUP := ENL;
|     CASIS: CASISPROC;
|     CFLAGOVER:
|      FLAGOVER := YES;
|     CFLAGSIG:
|      FLAGSIG := YES;
|     CREM:
|      CUP := ENL; (* MAKES REST OF LINE A COMMENT *)
|     CUPP:
|      (* FORCE NEXT SYMBOL UPPER *)
|      BEGIN GETSYM; UPCASESYL; ADDWORD; END;
|     CUSB:
|      USB := YES;
|     CADD:
|      ADDWORD;
|     CDATE:
|      BEGIN
|    (* DATE(V); *)    V:='          ';
|       WITH SYL DO
|        BEGIN
|         FOR I:=3 TO 6 DO BEGIN LIN(/I/) := V(/I+1/);
|                          LINT(/I/).LINC := BLANKLINC END;
|         LIN(/1/) := V(/8/); LIN(/2/) := V(/9/);
|         LIN(/7/) := V(/2/); LIN(/8/) := V(/3/);
|         LEN := 8;
|        END;
|       PUTWORD;
|      END;
|     CTIME:
|      BEGIN
|     (*TIME(V); *)     V:='          ';
|       WITH SYL DO
|        BEGIN
|         FOR I:=1 TO 5 DO BEGIN LIN(/I/) := V(/I+1/);
|                          LINT(/I/).LINC := BLANKLINC    END;
|         LIN(/3/) := ':';
|        END;
|       PUTWORD;
|      END;
|    CDELMAC:
|     BEGIN
|      TMACP := MACLSTP;
|      GETTOKEN;
|      IF SYL.LEN<>0 THEN
|       BEGIN
|        UPCASESYL;
|        FOR SUB := 1 TO 10 DO V(/SUB/) := SYL.LIN(/SUB/);
|        WHILE (TMACP@.NM<>V) AND (TMACP<>CHTMACP) DO
|         BEGIN MACP := TMACP; TMACP := TMACP@.MA; END;
|        IF TMACP=CHTMACP THEN
|         BEGIN ERR; WRITE('NO MACRO ',V,' DEFINED'); ERRE END
|        ELSE IF TMACP=MACLSTP THEN MACLSTP := TMACP@.MA
|         ELSE MACP@.MA := TMACP@.MA;
|       END
|      ELSE BEGIN ERR; WRITE('NO MACRO NAME'); ERRE END;
|     END;
|     CDEBUG1 : BEGIN  DEBUG1 := YES; DEBUG2 := YES; END;
|     CDEBUG2 : DEBUG2 := YES;
|     CAUTOCAP : BEGIN AUTOCAP := YES; CAPNEXT := AUTOCAP AND LOWER; END;
|     NOTCMD: BEGIN END
|    END
|   END;
|  CMMD := FALSE;
| END;     (*$END OF DOCOMMAND *)
| 
| PROCEDURE INI;
| BEGIN
|  LITERAL1 := '.TOP .SAV .RESPAG .B 3 ..TTL ..NMP .BR ..STL .B 2 .RES .MID ';
|  LITERAL2 := '$$PAGE=$$PAGE+1; ..NONMP .IF $$NMP .TAB $$PRM .RT $$PAGE ';
|  LITERAL3 := '.IF #$$NMP .B 1 ';
|  LITERAL4 := '.PAGE .FIG 12 .C <CHAPTER $$CH=$$CH+1 ';
|  LITERAL5 := '$$HL=0; .B 2 .C ..CHT .B 3 ';
|   BLANKLINC := '    ';
|   BLANKLINC(/4/) := CHR(0);
|  VAL(/VLM/) := 1;
|  CMMD := FALSE;
|  USB := TRUE;
|  UNDL := FALSE;
|  ILNO := 0; EOFINPUT := FALSE;
|  FREEMACP := NIL;
|  INISTDMACS;
|  FLAGOVER := TRUE; FLAGSIG := TRUE;
|  T := FALSE; RT := FALSE; DOT := FALSE;
|   FOR ERRORS := 0 TO (CHARSIZE - 1) DO BEGIN
|       ITEMSET(/ERRORS/) := FALSE;
|       TERMSET(/ERRORS/) := FALSE;
|       END;
|   ERRORS := 0;
|   ITEMSET (/ ORD('$') /) := TRUE; ITEMSET (/ ORD('+') /) := TRUE;
|   ITEMSET (/ ORD('-') /) := TRUE; ITEMSET (/ ORD('#') /) := TRUE;
|   FOR CH := '0' TO '9' DO  ITEMSET (/ORD(CH)/) := TRUE;
|   TERMSET := ITEMSET;
|   TERMSET (/ ORD('(') /) := TRUE;
|  INIRELS;
|  PUSHED := FALSE;
|  PMAR := 0;
|  AP := FALSE;
|  PARA := FALSE;
|  OTL.CENTER := FALSE;
|  RIGHT := TRUE;
|  OPNO := 5;
|  OBTXT := 7;
|  OVETXT := 58; OETXT := 58;
|  OEPAG := 66;
|  LPT := TRUE;                      (* THIS IS CHANGED FROM ORIGINAL SPECS *)
|  ENP := 0;
|  SUP := FALSE;
|  PAGE := FALSE;
|  YES := TRUE;
|  ENP := 0;
|  PARSPACE := 1;
|  PARTEST := 3;
|  DEFRB := 0;
|  PREL := TRUE;
|  FIRSTCH := TRUE;
|  FORCE := FALSE;
|  ATITLE := FALSE;
|  FIGP := 0;
|  BAR := FALSE; BB := FALSE;
| (* LINELIMIT(OUTPUT,50000); *)
|  CLRTAB;
|  TAB := 0;
|  DEFRSYM := FALSE;
|  RT := FALSE;
|  CLRLINE;
|  NEW(ACTP);
|  WITH ACTP@ DO
|   BEGIN NP := 0; CA := NIL; ON := FALSE; NEW(LI) END;
|  BOTMAC := ACTP;
|  XTEND := FALSE;
|  INICMDS;
|  SETSTD;
|  INIVARS;
|  VAL(/VNMP/) := 1;
|  VAL(/VLM/) := 1;
|  VAL(/VRM/) := 72;
|  VAL(/VPRM/) := 72;
|  OTL.LEN := VAL(/VLM/); OTL.VLEN := VAL(/VLM/);
|  VAL(/VSP/) := 1;
|  VAL(/VOLNO/) := 1000000;
|  SAVENV(PAGENV);
|  WITH ADDSYL DO
|   BEGIN LIN(/1/) := '.'; LIN (/2/) := 'A'; LIN(/3/) := 'D'; LIN(/4/):='D';
|         LEN := 4; END;
|  LETTERS := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
|  DEBUG1 := FALSE;
|  DEBUG2 := FALSE;
|  RIGHTSPACE := 0;
|   AUTOCAP := FALSE;
|   CAPNEXT := FALSE;
| END;     (*$END OF INI *)
|           (* MAIN *)
| 
| BEGIN             REWRITE(QRR);
|  INI;
|  GETCUR;
|  WHILE NOT EOFINPUT DO
|   BEGIN
|    IF (CUR(/1/)=' ') AND AP THEN FORCECMD('.PP       ',3);
|    GETSYM;
|    IF SYMTYPE=NONE THEN BLANKLINE
|    ELSE
|     BEGIN
|      WHILE SYMTYPE<>NONE DO
|       BEGIN
|        CASE SYMTYPE OF
|         WORD: PUTWORD;
|         VARS: PUTVAR;
|         COMMAND: DOCOMMAND
|        END;
|        GETSYM
|       END;
|     END;
|    ENDLINE;
|    IF NOT DEFRSYM THEN GETCUR;
|   END;
|  FIN
| END.
> Member RNFDOC
| 1
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
|                                           RNF
| +                                         ___
| 
|                                     Text Processor
| +                                   ____ _________
| 
| 
|                                     Reference Guide
| 1
| 
| 
|         Introduction               RNF                                  1
| 
| 
| 
| 
| 
| 
| 
|                                        CHAPTER 1
| 
|                                      INTRODUCTION
| 
| 
| 
| 
|         RNF is a text formatting program for the Cyber similiar  to  the  RUNOFF
|         program available on the DECsystem-10.
| 
|         RNF accepts (mostly) free-format text which has been put in a  file  and
|         edited  by  BOSS,  and  produces output suitable for a line printer or a
|         typewriter-like terminal device.
| 
| 
| 
|         1.1  Features
| 
| 
|         RNF does any or all of the following for the user:
| 
|          Pagination      RNF automatically breaks text up  into  pages,  and  by
|                          default numbers them sequentially.
| 
|          Fill            Using the margins set by the  user,  RNF  automatically
|                          "fills"  each  line of the output with as many words as
|                          it  can  hold  without  exceeding  the  right   margin.
|                          Filling stops at the end of a paragraph, etc.
| 
|          Justification   RNF will optionally justify filled lines on the  right,
|                          so that the right margin "lines up" evenly.
| 
|          Chaptering      RNF will format chapter  titles,  and  number  chapters
|                          sequentially.
| 
|          Sectioning      RNF will format section headers and number sections and
|                          subsections sequentially.
| 
|          Lists           RNF will format and number lists and sublists.
| 
|         In addition to the features which are built in, RNF provides an easy  to
|         use  macro  facility which permits the user to define commands which are
|         customized to a particular application.
| 1
| 
| 
|         2                          RNF                       Introduction
| 
| 
|         1.2  Input Text
| 
| 
|         The input to RNF may be prepared either on an  upper  case  only  device
|         like  a  Teletype  or punched cards, or on an upper/lower case terminal.
|         These are called NORMAL and ASCII devices, respectively.
| 
|         Regardless of the input medium, output from RNF is in upper/lower  case.
|         This is accomplished by the following conventions:
| 
| 
| 
|         1.2.1  NORMAL Input
| 
| 
|         By convention, RNF inverts the case  of  alphabetic  characters  in  the
|         input.   Upper  case  characters  are  indicated  by a preceding ^.  For
|         example, the following NORMAL input
| 
|          ^THIS IS AN ^U^P^P^E^R/LOWER CASE LINE.
| 
|         is output by RNF as
| 
|          This is an UPPER/lower case line.
| 
|         As a convenience, the < character will invert the case of all alphabetic
|         characters which follow it in the same word.  For example,
| 
|          ^SOME <UPPER <CASE AND SOME LOWER CASE.
| 
|          SOME<OF<BOTH
| 
|         are output as
| 
|          Some UPPER CASE and some lower case.
| 
|          someOFboth
| 
|         In exchange for this  convenience,  the  characters  ^  and  @  must  be
|         represented in NORMAL input as @B and @A, respectively.
| 
| 
| 
|         1.2.2  ASCII Input
| 
| 
|         Upper/lower case text can be entered in a file by using  ASCII  mode  in
|         BOSS.   When  submitted  to RNF, this text must be preceded by an .ASCII
|         command.  The < character works the same.
| 1
| 
| 
|         Introduction               RNF                                  3
| 
| 
|         1.3  WORDS
| 
| 
|         RNF input is a series  of  words,  where  a  word  is  any  sequence  of
|         non-blank characters.
| 
|         Blanks in the input text are not (usually) significant  to  RNF,  except
|         that  they  delimit words.  RNF inserts one blank between each word, and
|         two blanks after words which end sentences.
| 
|         If a sequence of blanks must appear in the output, the significant blank
|         character # is used.  For example, be####tween is output as be    tween.
| 
| 
| 
|         1.4  LINES
| 
| 
|         In default mode, words are picked from the input one by one  and  placed
|         into  an  output  line.  When an output line is full, it is written into
|         the output file.
| 
|         The user sets the left and right margins of the output page by  the  .LM
|         and  .RM  commands,  respectively.   Text  on the output line is written
|         beginning at the left margin and not past the right margin.
| 
|         Filling means that (unless the user specifically directs  otherwise)  as
|         many words as possible are used to fill each output line.
| 
|         Justification means that blank characters are  added  between  words  so
|         that the last character on each line is exactly on the right margin.
| 
|         The .F and .J commands control filling and justification.
| 
|         The default left margin is 1 and the default right margin  is  72.   For
|         Elite  type  (12  characters per inch) this produces a 6-inch wide line,
|         which allows 1 and 1/4 inch margins on standard 8 and  1/2  inch  paper.
|         For Pica type (10 characters per inch) .LM 1 and .RM 60 provide the same
|         size line.
| 
|         For most purposes, it is recommended that the left margin  be  initially
|         set  to  1, as this is easy to work with and remember.  If the text must
|         be shifted to the right for output on  a  typewriter  page,  the  .RIGHT
|         command may be used.
| 1
| 
| 
|         4                          RNF                       Introduction
| 
| 
|         1.5  SPACING
| 
| 
|         The input to RNF is single spaced.  The output  may  be  single  spaced,
|         double spaced, or triple spaced as the user chooses.
| 
|         Spacing is set by the .SP command,.  Once set,  RNF  will  automatically
|         control  spacing without requiring any further action on the part of the
|         user.  If extra spaces or non-standard spacing is desired, however,  RNF
|         provides commands for these, too.
| 
|         The .CR command provides the equivalent of a carriage return key  on  an
|         electric typewriter.  The .CR ends the current line and spaces as set by
|         .SP.  That is, if single spacing is selected (.SP 1), the  .CR  "returns
|         the  carriage"  to the next line; if double spacing is selected (.SP 2),
|         the .CR leaves a single blank line after the current line,  and  so  on.
|         Throughout  this  manual,  the  action  of  the  .CR is referred to as a
|         "return".  Many commands cause a return as a prelude to further action.
| 
|         The .S command causes a return, followed by any number of extra returns.
|         .S  and  .S 1  mean the same, i.e., a return and one extra return.  .S 2
|         provides two extra returns, and so on.
| 
|         .CR and .S always honor the spacing set by .SP.   The  user  can  escape
|         spacing by means of the .BR and .B commands.
| 
|         .BR provides a "break"; it returns the carriage and proceeds on the next
|         line,  regardless of spacing.  .B causes any number of blank lines after
|         the current line.  .B and .B 1 mean the same: break and leave one  blank
|         line after the current line.  .B 2 leaves two blank lines, and so on.
| 
|         Thus, the user can create spacing independent text by using only .CR and
|         .S  commands  for  spacing.   .BR  and .B are used when spacing is to be
|         fixed regardless of the .SP setting.
| 
| 
| 
|         1.6  PARAGRAPHS
| 
| 
|         RNF provides both explicit and automatic paragraphing  facilities.   The
|         .P  command  controls  the  indentation,  spacing,  and location of each
|         paragraph.  The .PP command begins a new paragraph.
| 
|         Autoparagraphing, controlled by the .AP command, causes an implicit  .PP
|         command  each time either a blank line or a line beginning with blank is
|         encountered in the input text.  This is a  convenient  format  for  text
|         entry, and allows easy modification.  By use of the .SP (SPacing) and .P
|         commands, the same input text can be used for producing both double  (or
|         triple) spaced drafts and single spaced final copy.
| 
| 1
| 
| 
|         Introduction               RNF                                  5
| 
| 
|         Paragraphing is sufficiently flexible to be used for "hanging  indents".
|         In  addition,  the  fact  that  paragraph  indentation  can be specified
|         relative to the left  margin  (even  if  it  is  later  changed)  allows
|         paragraphing to be conveniently used in indented text.
| 
| 
| 
|         1.7  PAGES
| 
| 
|         Lines are automatically separated  into  pages  by  RNF.   Two  commands
|         control the size of RNF pages: .PS (Page Size) and .LINES.
| 
|         The first argument of .PS  specifies  the  number  of  lines  which  are
|         allowed  on  a page before an automatic page throw is done.  This number
|         includes the lines in the header at the top of each page, and the normal
|         text  on the page, but does not include the lines in the footer (if any)
|         at the bottom of the page.  The .LINES command specifies the  number  of
|         lines  on  the  entire  page.   This number is used when simulating page
|         ejects on terminals with continuous forms.
| 
|         The default .PS first argument and .LINES are 58 and  66,  respectively.
|         This allows at least a 1 and 1/3 inch bottom margin with 6 line per inch
|         printing, and a 1 inch margin with line per inch  printing  on  standard
|         CSO reduced forms.
| 
|         Some terminals use reduced forms but print 6 lines per inch.  This means
|         there are 51 lines on each page; a .PS first argument of 44 will allow a
|         1 inch bottom margin.
| 
| 
| 
|         1.7.1  Explicit paging control
| 
| 
|         The  .PAGE  command  allows  the  user  to  advance  to  the  next  page
|         explicitly.   The .NMP and .PNO commands control page numbering, and the
|         .TITLE, .ST, and .ATITLE commands provide for printing titles at the top
|         of each page.
| 
| 
| 
|         1.7.2  Page Format
| 
| 
|         A page is divided into three areas:
| 
|            . The top, which contains the upper margin and  optional  titles  and
|              page number.
| 
| 1
| 
| 
|         6                          RNF                       Introduction
| 
| 
|            . The middle, which contains the text of the document.
| 
|            . The bottom, which may contain a footer.  (By default, no footer  is
|              printed.)
| 
| 
|         The default header consists of an optional title on  the  left  and  the
|         page  number  as an Arabic number on the right of the fourth line on the
|         page.  The subtitle, if any, is below the title on the  following  line.
|         Two blank lines are left below the header.
| 
|         If this default format is not satisfactory for a specific document,  the
|         user  may  substitute any arbitrary header and footer text by means of a
|         .FRCPAGE macro  definition  (see  Chapter  3)  and  use  of  the  paging
|         intrinsics .TOP, .MID, and .BOT.
| 
|         The page number used  by  RNF  may  be  accessed  directly  through  the
|         predefined variable $$PAGE (see Chapter 4).
| 1
| 
| 
|         Commands                   RNF                                  7
| 
| 
| 
| 
| 
| 
| 
|                                        CHAPTER 2
| 
|                                        COMMANDS
| 
| 
| 
| 
|         Any sequence of non-blank characters beginning with a  period  (.)   are
|         taken  by  RNF  to  be  a command.  If the command is not recognized, an
|         error message is produced.
| 
|         Many commands require arguments, i.e., words which  follow  the  command
|         and  modify  its  action  in some way.  The only commands which permit a
|         variable number of arguments are .TAB (or .TABS), .B, and  .S.   if  any
|         other command requires an argument, it must be specified.
| 
|         Commands may be freely interspersed with text.  Some  commands  cause  a
|         "return"  (that  is, act as if they were preceded by a .CR command) as a
|         part of their action.  If a command causes a return, this  is  indicated
|         in parenthesis after the command format.  Other commands cause a "break"
|         (that is, act as if they were preceded by a .BR command) as  a  part  of
|         their action.  These are indicated by (Break) in parenthesis.
| 
|         Note that a blank must follow a command if there is  more  text  on  the
|         same  line.   For example, the sequence ".B.I 5" is in error; it must be
|         written as ".B .I 5".
| 
| 
|      .AP
| 
|          Any  blank  line  or any line beginning with a blank character begins a
|          new  paragraph.   See  the  .P  and  the  .PP  commands.   .NOAP  turns
|          autoparagraphing off and is the default.
| 
| 
|      .ARRAY variablename n
| 
|          This command declares an array variable with the name specified and n+1
|          elements.  An element of the array is later accessed or  changed  by  a
|          reference of the form:
| 
|          variablename[expression]
| 
|          where  expression may be in the range 0 through n.  The zeroeth element
|          of the array may be  referred  to  without  a  [0]  subscript,  and  is
|          commonly used as an index into the remainder of the array.
| 
| 1
| 
| 
|         8                          RNF                           Commands
| 
| 
|          All array elements have the initial value zero.  Array  names  must  be
|          formed as defined for the .VAR command.
| 
| 
|      .ASCII
| 
|          The  input  was prepared in ASCII mode on an upper/lower case terminal.
|          When in ASCII mode cahracters  are  not  automatically  case  inverted.
|          Also  the effect of the ^ character is reversed, in ASCII mode ^ lowers
|          a capital letter and does nothing to a lower case letter.  The  default
|          is .NOASCII.
| 
| 
|      .ASIS                                                       (Return)
| 
|          Terminates  the current input line and enters as is mode beginning with
|          the next input line.
| 
|          In  as  is  mode, input lines are copied directly to the output (except
|          that the left  margin,  change  bars,  and  .RIGHT  spacing  are  still
|          honored).
| 
|          As is mode is terminated by a line with an  exclamation  mark  (!)   in
|          column  1.   All characters after the exclamation mark are ignored, and
|          normal processing begins with the following line.
| 
|          Note that as is text which is intended to be output as upper/lower case
|          (ASCII) must be input in ASCII.  No processing is done on as is text.
| +                                         __
| 
| 
|      .ATITLE
| 
|          Enables autotitling, which makes each new chapter heading the title for
|          all but the first page of the chapter.  The default is .NOATITLE.
| 
| 
|      .AUTOCAP
| 
|          Enables  the auto capitalization, which makes the character following a
|          ., !, ?, remain in upper case.  This is disabled  in  ASCII  mode.   It
|          takes  effect  after  the  first punctuation mark, so it may not affect
|          titles or the first line.  NOAUTOCAP is the default.
| 
| 
|      .B                                                           (Break)
|      .B n                                                         (Break)
| 
|          Ends the  current  line  and  writes  it  without  further  filling  or
|          justification (causes a break), then writes n blank lines.  .B and .B 1
|          are equivalent.
| 
| 
| 1
| 
| 
|         Commands                   RNF                                  9
| 
| 
|      .BAR
| 
|          Enables  change  bars.   All text following the .BAR command is shifted
|          right three spaces.  See the .BB and  .EB  commands.   The  default  is
|          .NOBAR.
| 
| 
|      .BB
| 
|          Begin  placing change bars (vertical bars) in the margin created by the
|          .BAR command beginning with the line which contains the first  word  in
|          the text following the .BB command.  See the .EB command.
| 
| 
|      .BOT
| 
|          Sets  the  beginning  of  user text (on the page) to the current output
|          line number and restores any output lines which might have  been  saved
|          on a forced page eject (see .FRCPAGE).  If any deferred text is pending
|          (see the .FIG command), as much of it as possible is  output  by  .BOT.
|          If  as  is  mode  was in effect at the time of the last .FRCPAGE, it is
|          restored.
| 
|          The  .BOT command is to be used only when overriding the default header
|          format via macros.
| 
|          The  .B and .S commands have no effect at the beginning of user text on
|          a page.  This prevents spurious blank lines at the top of a text page.
| 
| 
|      .BR                                                          (Break)
| 
|          Ends  the current outtput line and writes it without further filling or
|          justification.  No extra blank lines are left  by  .BR,  regardless  of
|          spacing.
| 
| 
|      .C text                                                     (Return)
| 
|          Centers  the  text  which  follows  the  .C  command  on the same line.
|          Centering is between the current left and right margins.
| 
| 
|      .CH title                                                   (Return)
| 
|          Begins  a new chapter with the title which follows on the same line.  A
|          new page is begin, titles and subtitles are cleared, a .FIG 12 is done,
|          followed  by  the  word  CHAPTER  centered, a .B, followed by the title
|          centered.  Page numbering is not  affected.   If  .ATITLE  is  on,  the
|          chapter title is set as the .TITLE for succeeding pages.
| 
| 
| 1
| 
| 
|         10                         RNF                           Commands
| 
| 
|      .CR                                                         (Return)
| 
|          Causes  a carriage return, which is a .BR followed by spacing minus one
|          blank lines.
| 
|          Note  that  .CR  is  implied  before  any command for which (Return) is
|          indicated.
| 
| 
|      .DEBUG1
| 
|          Causes all following lines to be prefixed with the relative line number
|          of the page.  This precedes the carriage control, if any.  .DEBUG1 also
|          includes  .DEBUG2.   .NODEBUG1  is  the  default.   This  is useful for
|          finding problems when creating a document with many page ejects.
| 
| 
|      .DEBUG2
| 
|          Causes  all  following  lines to be trailed by the input line number on
|          the extreme right margin (not necesarily the margin set by .RM).   This
|          is  very useful for document preparation, to correlate a problem to the
|          input line causing it.  .NODEBUG2 is the default.
| 
| 
|      .DEC variablename
| 
|          Decrement the variablename.
| 
| 
|      .DELMAC macroname
| 
|          Deletes the macro name, so that it may be reused.
| 
| 
|      .DOT
| 
|          Causes  all  following  .T  or .RT commands to fill with dots (periods)
|          instead of spaces.  A blank is always left before and after the  string
|          of dots.  .NODOTS returns to filling tabs with spaces.
| 
| 
|      .EB
| 
|          End  change  bars.  The last line flagged is the one which contains the
|          word just preceding the .EB command.
| 
| 
|      .ELIST
| 
|          End  list.   Terminates  the  innermost  active  list.   See  the .LIST
|          command.
| 1
| 
| 
|         Commands                   RNF                                 11
| 
| 
|      .ESC
| 
|          Enables the escape character _ (backarrow or underline).  When enabled,
|          the escape character causes the character which follows it to be copied
|          to  the  output text without special action.  For example, 23_.  causes
|          23. to be typed without an extra trailing blank.  The default is .ESC.
| 
| 
|      .F
| 
|          Fills  each  output  line with as many words from the input as possible
|          without exceeding the right margin.  Blanks are removed from the input.
|          Each  word of the output is followed by at least one blank, while words
|          which end in ., !, or ? are followed by  at  least  two  blanks.   .NOF
|          suppresses fill.
| 
| 
|      .FIG n
| 
|          Reserves  n  lines  for a figure.  If the lines will fit on the current
|          page, .FIG causes a return and leaves n blank lines.  If not,  n  blank
|          lines are left at the beginning of the next page.
| 
| 
|      .FLAG
| 
|          Causes  ^  and  @  to  be  recognized as flag characters.  .FLAG is the
|          default; .NOFLAG suppresses recognition.
| 
| 
|      .FLAGCAPS
| 
|          Causes  the  <  character  to  invert the case of any letters in a word
|          which  follow  it.   For  example,  <UP<AND<THEN<DOWN  is   output   as
|          UPandTHENdown.   .NOFLAG suppresses special action for the < character.
|          .FLAG is the default.
| 
| 
|      .FLAGOVER
| 
|          The  .FLAGOVER  command  enables  recognition  of  \ (backslash) as the
|          strikeover character.  The strikeover character is written between  the
|          character to be overstruck and the character which is to overstrike it.
|          For example, STRIKEO\/VER is output as STRIKEOVER.
| +                                                     /
| 
|          Underlining  counts as one overstrike.  Any character may be overstruck
|          up to three times.  Overstriking may be used only within  a  word;  the
|          overstrike character has no meaning by itself or beginning a word.
| 
|          .FLAGOVER is the default.  .NOFLAGOVER turns it off.
| 
| 
| 1
| 
| 
|         12                         RNF                           Commands
| 
| 
|      .FLAGSIG
| 
|          The   .FLAGSIG   command  enables  recognition  of  #  (sharp)  as  the
|          significant blank character.   .FLAGSIG  is  the  default.   .NOFLAGSIG
|          turns it off.
| 
| 
|      .FRCPAGE
| 
|          This command is used internally by RNF to force a page eject.  That is,
|          if a line is about to be written which would exceed the page size,  the
|          line is saved, and a .FRCPAGE command is executed as though it had been
|          encountered in the input text.
| 
| 
| 
|          The .FRCPAGE command itself invokes the equivalent of .TOP, prints  the
|          next page header, and invokes the equivalent of .MID.
| 
|          The user may add a footer or reformat the page  header  by  defining  a
|          macro  with the name .FRCPAGE.  This replaces the .FRCPAGE command, and
|          must invoke the  .TOP  and  .MID  commands  (and  optionally  the  .BOT
|          command)  explicitly.   For  correct  operation,  the first word in the
| +                                                              _____
|          .FRCPAGE macro must be either .BOT or .TOP, and the last word should be
|          .MID.
| 
|          Note that .FRCPAGE does not return, nor can  it,  since  a  return  can
|          cause  a  page  eject,  which  will  cause  a  .FRCPAGE  to  be invoked
|          recursively.  The .PAGE command does return, and in fact is defined  as
|          .BR .FRCPAGE.
| 
| 
|      .FMT n1 n2
| 
|          Formats  the  value of n2 according to the format code specified by n1.
|          N1 and n2 may be expressions (see Chapter 4).  N1 must be in the  range
|          0 through 5, and has a meaning as follows:
| 
|          Value      Formats n2 as...
| +        _____      ________________
| 
|              0      Arabic numbers.  That is, .FMT 0 is a no-op except  that  it
|                     forces output of n2.
| 
|              1      Upper case alphabetic characters, where  n2=1  produces  the
|                     character  A, n2=2 produces B, etc.  (Note that in fact n2=n
|                     produces the nth character in the alphabet, where n is taken
|                     modulo 26.)
| 
| 1
| 
| 
|         Commands                   RNF                                 13
| 
| 
|              2      Lower case alphabetic characters, where  n2=1  produces  the
|                     character a, etc.  (The action is the same as that of format
|                     except that the character is lower case.)
| 
|              3      Upper case Roman numerals.  (The numerals produced only make
|                     use of the characters M, D, C, L, X, V, and I.)
| 
|              4      Lower case Roman numerals.  (The numerals produced only make
|                     use of the characters m, d, c, l, x, v, and i.)
| 
|              5      The N2th character of the character set.  This is useful for
|                     printing characters not available on the entry device.
| 
| 
|      .HL n heading                                               (Return)
| 
|          Begins  a  new  section  with  the  heading specified and automatically
|          numbers it.  The n in the .HL command must be in the range 1 through 5.
|          Section  numbers  have  the form i.j.k.l.m.  If a .CH command preceeded
|          the .HL command, i is the chapter number; otherwise it is the number of
|          .HL  1  commands.   Within Chapter 2, the sequence .HL 1, .HL 2, .HL 3,
|          .HL 3, .HL 2, .HL 1 produces sections  numbered  2.1,  2.1.1,  2.1.1.1,
|          2.1.1.2, 2.1.2, and 2.2.
| 
|          Three blank lines are left before each section,  and  two  blank  lines
|          follow the section header.
| 
| 
|      .I  n                                                       (Return)
|      .I +n                                                       (Return)
|      .I -n                                                       (Return)
| 
|          Indent  the following line.  If n is specIfied, it indicates the column
|          number at which the line is to begin.  If +n or -n are  specified,  the
|          indent is plus or minus n characters from the left margin.
| 
| 
|      .IF expression text
| 
|          The  .IF command tests the value of the expression.  If it is zero, the
|          text on the remainder of the line is skipped;  otherwise  the  text  is
|          scanned normally.  .IF provides a single line conditional capability.
| 
|          For a definition of expressions  acceptable  to  .IF,  see  Chapter  4,
|          VARIABLES.
| 
| 
|      .INC variablename
| 
|          increment the following variable.
| 
| 
| 1
| 
| 
|         14                         RNF                           Commands
| 
| 
|      .J
| 
|          Justify  text at the right margin.  This is the default.  Justification
|          is accomplished by inserting extra blanks between words when necessary.
|          (Note  that  a significant blank, the # character, is never expanded.)
|          .NOJ turns justification off.
| 
| 
|      .LE                                                         (Return)
| 
|          Begins  a  list  element.   The  element  is automatically numbered and
|          indented.  See the .LIST and .ELIST commands.
| 
| 
|      .LINES n
| 
|          Sets  the  number  of  lines  in the output page, including the top and
|          bottom margins.  DEFAULT n is 66.  The correct setting for 6  line  per
|          inch devices using 8 line per inch paper (like CSO'S DECwriters) is 51.
| 
| 
|      .LIST n                                                     (Return)
| 
|          Begins   a   list  with  n  spacing.   Each  element  of  the  list  is
|          automatically numbered beginning at 1.   Lists  may  be  nested  within
|          lists,  for  up to 5 levels.  A list is terminated by a .ELIST command.
|          Each list is indented on the right; the outermost list  is  indented  9
|          characters, and each inner list is indented 4 more.
| 
| 
|      .LOWER
| 
|          Formats the output in upper/lower case.  Lower is the default.
| 
| 
|      .LPT
| 
|          Prepare  output  for a line printer, with carriage control in the first
|          character position of each line.  The default is .LPT.  .NOLPT prepares
|          output for an interactive terminal.
| 
| 
|      .LM n
| 
|          Set  the  left  margin  to n.  N must be in the range 1 through 136 (in
|          particular, .LM 0 is flagged as an error).  See .RM also.
| 
| 
|      .MACRO name   = text
|      .MACRO name n = text
|      .MACRO name * = text
| 
| 1
| 
| 
|         Commands                   RNF                                 15
| 
| 
|          Defines  a  macro  with  the  name  specified  equal to the text on the
|          remainder of the same line.  When .name is encountered later, the  text
|          is substituted for it.
| 
|          If n, an integer from 1 to 7, is specified, it indicates the macro  has
|          n arguments.  This implicitly defines macros name1,name2...namen, which
|          have a text value equal to the n words which follow the macro  when  it
|          is invoked.
| 
|          If * is specified, it indicates that the macro has one  argument.   The
|          argument  is  the  implicitly defined macro name1, and has a text value
|          equal to the entire rest of the line on which the macro is invoked.
| 
|          For an extended discussion and examples, see Chapter 3, MACROS.
| 
| 
|      .MID                                                        (Return)
| 
|          The  .MID command ends a user-defined .FRCPAGE macro.  .MID outputs any
|          deferred text, followed by any lines saved prior to .FRCPAGE, then sets
|          the beginning of user text to the current line.  This latter suppresses
|          blank lines at the "top of the page" caused by either .S or .B.
| 
| 
|      .NMP
| 
|          Number pages.  This is the default; .NONMP turns it off.
| 
| 
|      .P  n s t
|      .P +n s t
|      .P -n s t
| 
|          Sets  paragraphing  conventions.   N,  s and t are numbers.  N sets the
|          paragraph indent and works like the .I command.   S  sets  the  spacing
|          between paragraphs, where 1 is single spaced, is double spaced, etc.  T
|          sets an automatic .TP t before each paragraph.  See also  the  .PP  and
|          .AP commands.
| 
| 
|      .PAGE                                                       (Return)
| 
|          Begins a new page.
| 
| 
|      .PERIOD
| 
|          Leave an extra blank after ., !, or ?.  This is the default.  It may be
|          suppressed by .NOPERIOD.
| 
| 
| 1
| 
| 
|         16                         RNF                           Commands
| 
| 
|      .PNO n
| 
|          Number the next page n.
| 
| 
|      .PP                                                         (Return)
| 
|          Begin a new paragraph.
| 
| 
|      .PS l r
| 
|          Sets  the  page  size to l lines of text, not counting the lines at the
|          top margin, and the page number right margin to r.  See also the .LINES
|          command.
| 
| 
|      .REM text
| 
|          The  .REM  command and all text which follows it on the same input line
|          is treated as a remark (comment).   The  text  is  not  copied  to  the
|          output.
| 
| 
|      .RES                                                         (Break)
| 
|          Restores  the  margins,  fill  and  justify  modes, paragraph settings,
|          spacing, and tab stops to their state as of the last .SAV command.
| 
| 
|      .RESPAG                                                     (Return)
| 
|          Like  .RES;  replaces  the  margins,  fill and justify modes, paragraph
|          settings, spacing, and tab stops to their state as of the last  .SAVPAG
|          command.   Restores the page environment, which is used to align titles
|          and page numbers.
| 
| 
|      .RIGHT n                                                    (Return)
| 
|          Shift  output  text  right  n  spaces.  the .RIGHT spaces precede those
|          caused by the .BAR command.
| 
| 
|      .RM n
| 
|          Sets the right margin to column n.
| 
| 
| 1
| 
| 
|         Commands                   RNF                                 17
| 
| 
|      .RT
| 
|          Right  tab.   Causes  the following word to be right justified (end in)
|          the next tab stop.  See the .TABS and .T commands.  This is useful  for
|          tables of numeric data.
| 
| 
|      .S                                                          (Return)
|      .S n                                                        (Return)
| 
|          Leave n+1 times spacing blank lines, where spacing is set  by  the  .SP
|          command.   .S does nothing at the beginning of a page.  .S and .S 1 are
|          equivalent.
| 
| 
|      .SAV
| 
|          Save  the  current margins, fill and justify modes, paragraph settings,
|          spacing,  and  tab  stops  --  which  are   collectively   called   the
|          "environment".   The environment is restored by the .RES command.  .SAV
|          and .RES can be nested.
| 
|          For most text, there are two active environments: the current value and
|          the "page environment".  The latter controls the printing of titles and
|          page numbers at the head of each page.
| 
|          Note that .HL, .CH, or  .RESPAG  reset  the  environment  to  the  page
|          environment  and discard any active .SAVs.  See the .SAVPAG and .RESPAG
|          commands.
| 
| 
|      .SAVPAG
| 
|          Like  .SAV,  except  .SAVPAG  replaces  the  page  environment.   If no
|          explicit .SAVPAG is done, the environment  at  the  first  .HL  or  .CH
|          command becomes the page environment.
| 
| 
|      .SIG
| 
|          Treat  successive  blank  characters  as  words, and stop all automatic
|          blank placement.  Used in conjunction with .NOJ and .NOF, it permits  a
|          sort  of  "as  is"  mode  in  which,  however,  commands  and flags are
|          recognized.  .NOSIG is the default.
| 
| 
|      .SP n
| 
|          Set  the  spacing  between  lines  forced out by filling to n, where is
|          single spacing, 2 is double spacing, etc.
| 
| 
| 1
| 
| 
|         18                         RNF                           Commands
| 
| 
|      .ST text                                                    (Return)
| 
|          The  text  which  follows the .ST command on the same line is used as a
|          subtitle on the next and succeeding pages.
| 
| 
|      .STD
| 
|          Sets  .F,  .FLAG,  .FLAGCAPS, .NOASCII, .ESC, .PERIOD, .J, .UL, .NOSIG,
|          and automatic returns before the .C,  .TITLE,  .ST,  and  .I  commands.
|          .SIG is the default; .NOSIG does the opposite.
| 
| 
|      .SUP
| 
|          Suppresses  (throws  away) any text already in the current output line,
|          and any text on the same input line as the .SUP command.
| 
| 
|      .T
| 
|          Begin  the  next word at the next tab stop.  See also the .TABS and .RT
|          commands.
| 
| 
|      .TABS t1 t2 ...  t15
| 
|          Set  up  to 15 tab stops in columns t1, t2, etc.  The tab stops must be
|          in ascending order.  Tabbing is done by the .T and .RT commands.
| 
| 
|      .TITLE text                                                 (Return)
| 
|          Sets the text which follows .TITLE on the same line as the title on the
|          next and succeeding pages.
| 
| 
|      .TOP
| 
|          Spaces  to the top of the next page or emits "1" carriage control.  and
|          resets the line counter.
| 
|          .TOP is only to be used when overriding the default page handling.  The
|          .PAGE command is used for ejecting a page normally.
| 
| 
|      .TP n                                                       (Return)
| 
|          Tests whether n lines remain on the current page.  If not, .TP ejects a
|          page.  Note that .TP is affected by spacing in that the  actual  number
|          of lines tested for is n times spacing minus one.
| 
| 1
| 
| 
|         Commands                   RNF                                 19
| 
| 
|      .U
| 
|          Underline the next and succeeding words in the output text.  Terminated
|          by the .NOU command.
| 
| 
|      .UPP
| 
|          Force the next word to be upper case.
| 
| 
|      .UPPER
| 
|          Forces the output into upper case only.  Lower is the default.
| 
| 
|      .USB
| 
|          Underline  significant blanks (that is #) when .U is effective.  .NOUSB
|          causes significant blanks to be not underlined.  .USB is the default.
| 
| 
|      .VAR variablename
| 
|          Declares a variable with the name specified.  Variable names must begin
|          with a $, and otherwise consist of letters, numbers, or  $  characters.
|          The  second  character  of  a  variable  name  may not be a digit.  The
|          variable has the initial value zero.
| 
| 
|      .X
| 
|          Extend  the  preceding word on the output line with the following word.
|          Words joined by .X are output on the same line with no  blanks  between
|          them.   .X is primarily useful for joining text generated by a macro to
|          punctuation on either side of it.
| 1
| 
| 
|         20                         RNF                             Macros
| 
| 
| 
| 
| 
| 
| 
|                                        CHAPTER 3
| 
|                                         MACROS
| 
| 
| 
|         User-defined RNF macros provide a means of:
| 
|            . Extending the set of RNF commands by adding macros  tailored  to  a
|              specific application.
| 
|            . Abbreviating commonly used series of RNF commands.
| 
|            . Abbreviating commonly used phrases or long words.
| 
|         For  example,  the  following macro definitions were used to produce the
|         dotted list above:
| 
|                  .MACRO BDOT = .SAV .P -2 1 5 .LM +5
|                  .MACRO DOT = .PP _.# .X
|                  .MACRO EDOT = .RES .S 1
| 
|         while the following two macros  were  used  to  format  the  above  (and
|         following) examples:
| 
|                  .MACRO EX = .SAV .LM +9 .NOF .NOJ .S 1
|                  .MACRO EEX = .RES .S 1
| 
|         and so on!
| 
|         The following discussion is intended to give the user some insight  into
|         potential  uses  of  macros  while  demonstrating how easy macros are to
|         define and use.
| 
| 
| 
|         3.1  WHAT MACROS ARE
| 
| 
|         Macros have two parts: a name, and some text.  The name is a single word
|         long, while the text may be zero or more words long.
| 
|         The effect of a macro is similiarly easy to describe: wherever the  name
|         of the macro appears RNF removes it and substitutes the text.
| 
| 1
| 
| 
|         Macros                     RNF                                 21
| 
| 
|         For example, if the following macro is defined:
| 
|                  .MACRO CDC = Control Data Corporation
| 
|         whenever .CDC appears in the  input,  RNF  removes  it  and  substitutes
|         Control Data Corporation.
| 
| 
|                                      Note the Dots
| 
|                        The   macro  name  is  defined  without  a
|                        preceding  period  (dot).   But  when  the
|                        macro  is  used, the name must be preceded
|                        by a dot.
| 
| 
| 
| 
| 
|         3.2  HOW TO DEFINE A MACRO
| 
| 
|         The simplest form of macro definition is:
| 
|                  .MACRO name = text
| 
|         where name is the name of the macro, and text represents all the text on
|         the rest of the same line.
| 
|         After the macro definition, wherever .name appears RNF  removes  it  and
|         substitutes the text.
| 
| 
| 
|         3.3  SUB-MACROS
| 
| 
|         All macro expansions are considered to take place on the same input line
|         as  the  "outermost" macro call.  Thus, macros can be parameterized in a
|         simple way by ending a macro expansion with a  command  and  typing  the
|         command argument(s) after the macro call.  For example,
| 
|                  .MACRO RIGHTMARG = .RM
| 
|         which could be used by
| 
|                  .RIGHTMARG 65
| 
|         But,  as  the  example shows, this approach is mostly limited to trivial
|         command replacements.  Sub-macros provide the  ability  to  parameterize
|         macros in a more useful fashion.
| 1
| 
| 
|         22                         RNF                             Macros
| 
| 
|         3.3.1  Defining Parameterized Macros
| 
| 
|         Macros with sub-macros are defined by the formats:
| 
|                  .MACRO name n = text
|                  -or-
|                  .MACRO name * = text
| 
|         The n in the format stands for a number in the range 1  through  7.   It
|         means  that  the  1 through 7 words following the macro call on the same
|         line are dynamically made the values of the sub-macros name1, name2, ...
|         ,name7.
| 
|         Sub-macros have a defined value only when the macro is being expanded.
| 
|         If an asterisk is used instead of a number n,  it  means  that  all  the
|         words  which follow the macro call on the same line are dynamically made
|         the value of the sub-macro name1.
| 
|         For example,
| 
|                  .MACRO Z 2 = I hope you are .Z1 .X ing .Z2 .X !
| 
|         When .Z is called, the sub-macros .Z1 and .Z2 are given values equal  to
|         the two words which follow .Z on the same line.  Thus, the call
| 
|                  .Z follow me
| 
|         produces the text
| 
|                  I hope you are following me!
| 
| 
| 
| 
|         3.3.2  Sub-macro Semantics
| 
|         Since the parameters of a macro are defined as macros  themselves,  they
|         may  be  used  in any macro called while the sub-macros are defined, and
|         need not be "passed down" from macro to macro.
| 
|         If no words or not  enough  words  follow  the  call  of  a  macro  with
|         sub-macros, the sub-macros are given null values.  That is, unless there
|         is actually a word corresponding to a sub-macro, it expands  to  nothing
|         at all.
| 1
| 
| 
|         Variables                  RNF                                 23
| 
| 
| 
| 
| 
| 
| 
|                                        CHAPTER 4
| 
|                                        VARIABLES
| 
| 
| 
| 
|         RNF allows the user to define and  use  numeric  variables.   These  are
|         handy  (and  are  used  internally)  for  keeping track of page numbers,
|         chapter numbers, header levels, etc.
| 
| 
| 
|         4.1  VARIABLE SYNTAX
| 
| 
|         Variables are words which begin with a dollar sign ($), followed by from
|         1 to 9 letters, numbers, or $ characters.  The case of variable names is
|         not significant, e.g., $HILO and $hilo are the same variable.
| 
|         The first character after the leading $ cannot be a number.  This is  so
|         character  combinations  of  the  forms  $<blank> and $<numbers> are not
|         recognized as variables, making a nuisance for the user.
| 
|         Users should not declare variables with two  leading  dollar  signs,  as
|         this is the format used by pre-declared RNF system variables.
| 
|         For example, the following are valid variable names:
| 
|                  $A
| 
|                  $VARIABLE
| 
|                  $n$
| 
|                  $L23
| 
|         while the following are invalid:
| 
| 
|                  $100
| 
|                  $
| 
| 1
| 
| 
|         24                         RNF                          Variables
| 
| 
|         4.2  HOW TO DECLARE VARIABLES
| 
| 
|         Variables are declared by the .VAR command, which has the format:
| 
|                  .VAR $name
| 
|         Note that the variable name is both declared and used with a leading $.
| 
|         The effect of .VAR is to allocate space for a numeric variable, give  it
|         the name specified, and initialize the variable to zero.
| 
|         RNF provides  75  spaces  for  user-defined  variables  in  addition  to
|         predefined variables.
| 
| 
| 
|         4.3  PREDEFINED VARIABLES
| 
| 
|         As a convenience to the  user,  Rnf  makes  use  of  several  predefined
|         variables  while  performing various commands.  The predefined variables
|         are:
| 
|              $$PAGE Current page number.
|              $$CH Current chapter number.
|              $$HL Current  header  level.   Also  defined  are  $$HL[1]  through
|                          $$HL[5],  which  contain  the  current  counts  at each
|                          level.
|              $$LIST Current list level.   Also  defined  are  $$LIST[1]  through
|                          $$LIST[10],  which  contain  the current counts at each
|                          level.
|              $$LM Current left margin, set by .LM.
|              $$RM Current right margin, set by .RM.
|              $$SP Current spacing, set by .SP.
|              $$NMP Page numbering flag, set by .NMP.
| 
|         The values of the predefined variables may be examined or changed by the
|         user  at  any  time.   (Of course, changing these values will affect the
|         operation of the built in RNF features which use them.)
| 
| 
| 
|         4.4  VARIABLE ARRAYS
| 
| 
|         Arrays may be declared by the .ARRAY command, which has the format:
| 
|                  .ARRAY $name n
| 
|         The effect of this declaration is that $name is declared to  be  an  n+1
|         element array, which may be referenced as $name[0] through $name[n].
| 1
| 
| 
|         Variables                  RNF                                 25
| 
| 
|         The subscript may be omitted if the zeroeth  element  of  the  array  is
|         being  referenced.   That  is,  $name[0] and $name are equivalent.  This
|         convention is adopted so that a single declaration can allocate both  an
|         n-element  array  and an index variable associated with the array.  (The
|         predeclared arrays $$HL and $$LIST are used in this fashion.)
| 
|         Note that the array declaration requires n+1 spaces of the  allowed  for
|         user variables.
| 
| 
| 
|         4.5  EXPRESSIONS
| 
| 
|         An extremely useful feature of RNF is the ability to combine  variables,
|         numbers,  and  operators into expressions which compute a numeric value.
|         The values computed by the expressions can  in  turn  index  arrays,  be
|         assigned to variables, or become a part of the output text.
| 
| 
| 
|         4.5.1  Expression Syntax
| 
| 
|         An expression is defined as follows:
| 
|                  expr      ::= term < relop term >
| 
|                  relop     ::= .EQ. × .NE. × .LT. × .LE. × .GT. × .GE.
| 
|                  term      ::= item < < + × - > item >...
| 
|                  item      ::= < + × - × # > element
| 
|                  element   ::= ( term) × var × integer
| 
|                  var       ::= $id < [ term ] > < = term >
| 
| 
|         The angle brackets < and > in the syntax  expressions  enclose  optional
|         parts.  The construction
| 
|                  < stuff >...
| 
| 
|         indicates that stuff is allowed to appear zero or more times.  Note that
|         angle  brackets  are used to describe expressions; they do not appear in
|         expressions.
| 
|         The # character in an expression represents  a  logical  NOT  operation.
|         The  expression  #x  has  the value 1 if x equals , otherwise it has the
|         value 0.
| 1
| 
| 
|         26                         RNF                          Variables
| 
| 
|         The blanks in the syntax expressions are not  significant  and  in  fact
|         blanks  are  not permitted in expressions.  That is, and expression must
|         be a single word.
| 
|         Some examples of valid expressions are:
| 
|                  $A.GR.5
| 
|                  $HL[$HL+1]=0
| 
|                  2+$$PAGE
| 
|                  $X[$X=$X+1]=$X[$X]+1
| 
|                  $A=$B=$C
| 
| 
| 
| 
|         4.5.2  Expression Evaluation
| 
| 
|         Expressions are evaluated from left to right,  except  that  assignments
|         (indicated by the = sign) at the same level are done from right to left.
| 
|         In the examples above, $X[$X=$X+1]=$X[$X]+1 is equivalent to the  series
|         of  expressions  $X=$X+1  $X[$X]=$X[$X]+1.   (Recall  that  the  zeroeth
|         element of an array can be referenced without subscripts.)  On the other
|         hand, the expression $A=$B=$C is equivalent to $B=$C $A=$B.
| 
| 
| 
|         4.5.3  Where Expressions Are Used
| 
| 
|         An expression can always be used as  an  argument  to  a  command  which
|         requires a numeric value.
| 
|         An expression can also appear in text.  RNF decides whether to  evaluate
|         an  expression  in text or not based on whether the first character is a
|         $.  If it is, RNF evaluates the expression; otherwise the expression  is
|         treated like any other text word.
| 
|         For example, the expression $A+2 will be evaluated, while 2+$A will not.
|         If  $A  has  the  value  3, the former will appear in the output as "5",
|         while the latter will appear as "2+$A".
| 
|         For the few cases when it is not convenient to begin an expression to be
|         evaluated with a variable name, the syntax:
| 
|                  $(expr)
| 
| 1
| 
| 
|         Variables                  RNF                                 27
| 
| 
|         will cause expr to be evaluated.
| 
| 
| 
|         4.5.4  Suppressed Expressions
| 
| 
|         Frequently, one wishes to compute a value and assign it to a variable --
|         that  is,  evaluate  an expression -- without placing anything at all in
|         the output text.  This is done by  terminating  the  expression  with  a
|         semicolon.
| 
|         For example, the words:
| 
| 
|                           .VAR $A See $A=$A+1; only $A of these.
| 
|                  are output as
| 
|                           See only 1 of these.
| 
| 1
| 
| 
|         28                         RNF                          Variables
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
| 
|                               This page intentionally left blank.
| +                             ____ ____ _____________ ____ ______
| 1
| 
| 
|         Examples                   RNF                                 29
| 
| 
| 
| 
| 
| 
| 
|                                        CHAPTER 5
| 
|                                        EXAMPLES
| 
| 
| 
| 
|         This chapter contains a number of short examples  demonstrating  various
|         frequently used RNF features.
| 
|         The examples are intended  to  be  self-explanatory  and  are  presented
|         without  accompanying text.  All but one of the examples was prepared in
|         NORMAL mode (RNF default input).
| 1
| 
| 
|         30                         RNF                           Examples
| 
| 
|         5.1  INPUT TEXT EXAMPLE
| 
|         .C <RNO
|         .C ^INPUT ^TEXT
| 
|         ^INPUT TEXT TO <RNO CONSISTS OF A SEQUENCE OF WORDS AND COMMANDS
|         SEPARATED BY BLANKS.  ^A COMMAND IS ANY WORD WHICH BEGINS WITH
|         A PERIOD FOLLOWED BY A NON-DIGIT, WHILE A WORD IS ANY
|         SEQUENCE OF CHARACTERS WHICH
|         DOES NOT CONTAIN A BLANK.  ^THE FOLLOWING ARE CONSIDERED WORDS:
| 
|         .I 5 ^THIS
|         .BR .I 5 .^B
|         .BR .I 5 ^W^O^RD#^W^I^T^H#^S^I^G^N^I^F^I^C^A^N^T#^B^L^
|         .BR .I 5 .234
|         .B ^OF THE ABOVE WORDS, ONLY .^B IS A COMMAND.
|         .B <RNO GATHERS WORDS INTO LINES.  ^BY DEFAULT, THE FIRST WORD IN
|         A LINE BEGINS AT THE LEFT MARGIN, AND THE LAST WORD ENDS AT
|         OR BEFORE THE RIGHT MARGIN.  ^THAT IS, LINES ARE LEFT JUSTIFIED.
| 
|         ^IN THE OUTPUT,
|         AT LEAST ONE BLANK APPEARS BETWEEN WORDS; TWO BLANKS FOLLOW A
|         PERIOD OR QUESTION MARK WHICH END A WORD.
| 1
| 
| 
|         Examples                   RNF                                 31
| 
| 
|                                           RNO
|                                       Input Text
| 
|         Input text to RNO consists of a sequence of words and commands separated
|         by blanks.  A command is any word which begins with a period followed by
|         a non-digit, while a word is any sequence of characters which  does  not
|         contain a blank.  The following are considered words:
| 
|      This
|      .B
|      WORD#WITH#SIGNIFICANT#BLANKS
|      .234
| 
|         Of the above words, only .B is a command.
| 
|         RNO  gathers  words  into  lines.   By default, the first word in a line
|         begins at the left margin, and the last word ends at or before the right
|         margin.  That is, lines are left justified.
| 
|         In the output, at least one blank  appears  between  words;  two  blanks
|         follow a period or question mark which end a word.
| 1
| 
| 
|         32                         RNF                           Examples
| 
| 
|         5.2  PARAGRAPHING
| 
|         .C ^PARAGRAPHING
|         .P +5 1 5
|         .PP ^THE PARAGRAPHING FACILITY IN <RNO ENABLES FAST, CONVENIENT
|         TEXT ENTRY IN A NATURAL FORMAT.
|         .PP ^PARAGRAPHING IS SET UP BY THE .<P COMMAND, WHICH HAS THE
|         FORMAT:
|         .B .I 9 .<P INDENT SPACING TEST
|         .PP ^INDENT IS THE COLUMN AT WHICH THE FIRST LINE OF EACH
|         PARAGRAPH IS TO BEGIN, SPECIFIED EITHER AS AN UNSIGNED COLUMN
|         NUMBER OR AS A POSITIVE OR NEGATIVE OFFSET FROM THE CURRENT
|         LEFT MARGIN.  ^SPACING SPECIFIES THE NUMBER OF SPACES BETWEEN
|         PARAGRAPHS, WHERE 1 IS THE EQUIVALENT OF A <.S 1 COMMAND,
|         IS THE EQUIVALENT OF A <.S2 COMMAND, ETC.  ^TEST
|         SPECIFIES THE NUMBER OF LINES WHICH
|         MUST REMAIN ON THE CURRENT PAGE, OR THE PARAGRAPH IS BEGUN
|         ON THE NEXT PAGE.
|         .PP ^THE DEFAULT IS:
|         .B .I 9 .<P +0 1 3
|         .PP ^THE .<PP COMMAND DENOTES THE BEGINNING OF A NEW PARAGRAPH.
|         .AP
|          ^AS AN ALTERNATIVE (OR IN ADDITION) TO THE <.PP COMMAND, THE USER
|         CAN SELECT AUTOPARAGRAPH MODE BY MEANS OF THE <.AP COMMAND.
|         ^IF <.AP IS IN EFFECT, A BLANK AT THE BEGINNING OF ANY LINE
|         (OR A BLANK LINE)
|         IS TAKEN TO BE A <.PP COMMAND.
| 
|         (^NOTE THAT A BLANK LINE IN <.NOAP MODE IS TAKEN TO BE A <.B
|         COMMAND.)
| 
|         ^THE AUTOPARAGRAPH CONVENTIONS ALLOW A TYPIST TO ENTER AND WORK
|         WITH ALL TEXT IN A READABLE FORMAT WHICH IS CONVENIENT FOR
|         COMPUTER EDITING (FOR EXAMPLE, SINGLE SPACED WITH SINGLE CHARACTER
|         INDENTS), YET PRODUCE THE DRAFT AND FINAL COPIES OF WORK
|         IN WHATEVER STYLE IS REQUIRED.
| 1
| 
| 
|         Examples                   RNF                                 33
| 
| 
|                                      Paragraphing
| 
|              The paragraphing facility in  RNO  enables  fast,  convenient  text
|         entry in a natural format.
| 
|              Paragraphing is set up by the .P command, which has the format:
| 
|          .P indent spacing test
| 
|              Indent is the column at which the first line of each  paragraph  is
|         to begin, specified either as an unsigned column number or as a positive
|         or negative offset from the current left margin.  Spacing specifies  the
|         number of spaces between paragraphs, where 1 is the equivalent of a .S 1
|         command, is the equivalent of a .S2 command, etc.   Test  specifies  the
|         number  of lines which must remain on the current page, or the paragraph
|         is begun on the next page.
| 
|              The default is:
| 
|          .P +0 1 3
| 
|              The .PP command denotes the beginning of a new paragraph.
| 
|              As an alternative (or in addition) to the .PP command, the user can
|         select  autoparagraph  mode  by  means of the .AP command.  If .AP is in
|         effect, a blank at the beginning of any line (or a blank line) is  taken
|         to be a .PP command.
| 
|              (Note that a blank line in .NOAP mode is taken to be a .B command.)
| 
|              The autoparagraph conventions allow a typist to enter and work with
|         all  text  in a readable format which is convenient for computer editing
|         (for example, single spaced with single character indents), yet  produce
|         the draft and final copies of work in whatever style is required.
| 1
| 
| 
|         34                         RNF                           Examples
| 
| 
|         5.3  HEADER LEVEL EXAMPLES
| 
|         .AP
|         .HL 2 <HOW <TO <USE <HEADER <LEVELS
|          ^THE .<HL COMMAND ENABLES THE TYPIST TO ORGANIZE TEXT INTO
|         SECTIONS, AND SECTIONS WITHIN SECTIONS, WITH SEQUENTIAL NUMBERS
|         WHICH ARE CHANGED BY THE COMPUTER IF SECTIONS ARE ADDED OR
|         DELETED.
|         .HL 3 ^FORMAT
|          ^THE FORMAT OF THE .<HL COMMAND IS:
|         .S 1 .I 9 .<HL NUMBER TEXT
|          ^THE NUMBER IS THE LEVEL NUMBER, WHERE 1 IS THE OUTERMOST
|         LEVEL, 2 IS THE NEXT INNER LEVEL, ETC.  ^THE TEXT IS THE
|         TITLE OF THE SECTION.
|         .HL 3 ^EFFECT OF THE ^COMMAND
|          ^THE .<HL COMMAND STARTS A SECTION AT THE LEVEL SPECIFIED AND
|         USES TEXT AS THE HEADER.  ^THE NUMBER CAN BE IN THE RANGE
|         FROM 1 TO 5. ^THE SECTION NUMBER OUTPUT IS IN THE FORM
|         I.J.K.L.M.  ^IF THE DOCUMENT IS CHAPTER ORIENTED, I IS THE
|         CHAPTER NUMBER; OTHERWISE IT IS THE NUMBER OF .<HL 1 COMMANDS
|         SINCE THE BEGINNING OF THE INPUT TEXT.
|          ^THE COMMAND DOES A RETURN, A TEST PAGE 9, AND PRECEDES THE
|         SECTION IDENTIFIER WITH 3 BLANK LINES.
|         ^THE MARGINS AND OTHER ENVIRONMENT ARE RESET TO THE VALUES
|         THEY HAD BEFORE THE FIRST .<HL COMMAND (IN THE CHAPTER).
|         ^THE SECTION NUMBER BEGINS AT THE LEFT MARGIN, FOLLOWED
|         BY TWO SPACES, FOLLOWED BY THE TEXT, IF ANY.
|          ^A SINGLE BLANK LINE IS INSERTED AFTER THE HEADER.
|         .HL 2 <INCREMENTING
|          ^SECTION NUMBERS ARE INCREMENTED BY 1 AT THE LEVEL OF THE
|         CURRENT .<HL COMMAND.
|          ^EACH TIME LEVELS ARE NESTED (FOR EXAMPLE, .<HL 1 FOLLOWED
|         BY .<HL 2), THE NUMBERING IS RESTARTED AT 1 FOR THE HIGHER
|         NUMBERED LEVEL.
| 1
| 
| 
|         Examples                   RNF                                 35
| 
| 
|         5.3.1  HOW TO USE HEADER LEVELS
| 
| 
|         The .HL command enables the typist to organize text into  sections,  and
|         sections  within  sections, with sequential numbers which are changed by
|         the computer if sections are added or deleted.
| 
| 
| 
|         5.3.1.1  Format
| 
| 
|         The format of the .HL command is:
| 
|          .HL number text
| 
|         The number is the level number, where 1 is the outermost level, 2 is the
|         next inner level, etc.  The text is the title of the section.
| 
| 
| 
|         5.3.1.2  Effect of the Command
| 
| 
|         The .HL command starts a section at the level specified and uses text as
|         the  header.   The  number can be in the range from 1 to 5.  The section
|         number output is in the form i.j.k.l.m.   If  the  document  is  chapter
|         oriented,  i  is the chapter number; otherwise it is the number of .HL 1
|         commands since the beginning of the input text.
| 
|         The command does a return, a test  page  9,  and  precedes  the  section
|         identifier  with  3  blank lines.  The margins and other environment are
|         reset to the values they had  before  the  first  .HL  command  (in  the
|         chapter).  The section number begins at the left margin, followed by two
|         spaces, followed by the text, if any.
| 
|         A single blank line is inserted after the header.
| 
| 
| 
|         5.3.2  INCREMENTING
| 
| 
|         Section numbers are incremented by 1 at the level  of  the  current  .HL
|         command.
| 
|         Each time levels are nested (for example, .HL 1 followed by .HL 2),  the
|         numbering is restarted at 1 for the higher numbered level.
| 1
| 
| 
|         36                         RNF                           Examples
| 
| 
|         5.4  EXAMPLES of LISTS
| 
|         .C ^USING ^LISTS
|         .AP
|          ^AUTOMATICALLY NUMBERED LISTS CAN BE GENERATED BY THE <.LIST,
|         <.LE, AND <.ELIST COMMANDS.  ^THE <.LIST COMMAND HAS THE FORMAT:
|          .I 9 <.LIST SPACING
|          WHERE SPACING IS A NUMBER IN THE RANGE 1 THROUGH 5 WHICH
|         SPECIFIES THE SPACING TO BE USED WITHIN THE LIST.
|          ^THE LIST IS GENERATED AS FOLLOWS:
|         .LIST 1
|         .LE ^EACH LIST ELEMENT IS PRECEDED BY THE <.LE COMMAND.
|         .LE ^LIST ELEMENTS ARE SEPARATED BY "SPACING" BLANK LINES.
|         .LE ^EACH ELEMENT IS AUTOMATICALLY NUMBERED BEGINNING AT
|         BY 1.
|         .LE ^THE LIST IS TERMINATED BY THE <.ELIST COMMAND (WHICH
|         ALSO RESETS THE MARGINS AND SPACING).
|         .LE ^LISTS CAN BE NESTED WITHIN LISTS.  ^THIS IS HANDLED
|         AS FOLLOWS:
|         .LIST 1
|         .LE ^THE LEFT MARGIN IS SET 9 COLUMNS TO THE RIGHT FOR
|         THE OUTERMOST LIST, AND 4 COLUMNS TO THE RIGHT FOR EACH
|         INNER LIST.
|         .LE ^EACH <.LIST MUST BE TERMINATED BY A MATCHING <.ELIST.
|         ^THE <.ELIST RESETS THE MARGINS AND SPACING AS THEY WERE
|         BEFORE THE <.LIST COMMAND.
|         .LE ^FOR USERS OF AUTOPARAGRAPHING, THE PARAGRAPH MARGIN
|         IS SET TO COINCIDE WITH THE LEFT MARGIN, AND PARAGRAPH
|         SPACING IS SET TO THE LIST SPACING PLUS 1.
|          ^THIS MEANS THAT AUTOPARAGRAPHING CAN BE CONVENIENTLY
|         USED AT ANY LIST LEVEL.
|          ^THE PARAGRAPH VALUES ARE RESET BY THE <.ELIST COMMAND.
|         .ELIST
|         .LE ^LISTS CAN BE NESTED UP TO 5 LEVELS.
|         .ELIST
|          ^THE LIST FACILITY CAN BE A SIGNIFICANT CONVENIENCE FOR
|         THE TYPIST.
| 1
| 
| 
|         Examples                   RNF                                 37
| 
| 
|                                       Using Lists
| 
|         Automatically numbered lists can be generated by  the  .LIST,  .LE,  and
|         .ELIST commands.  The .LIST command has the format:
| 
|          .LIST spacing
| 
|         where spacing is a number in the range 1 through 5 which  specifies  the
|         spacing to be used within the list.
| 
|         The list is generated as follows:
| 
|              1.  Each list element is preceded by the .LE command.
| 
|              2.  List elements are separated by "spacing" blank lines.
| 
|              3.  Each element is automatically numbered beginning at by 1.
| 
|              4.  The list is terminated by the .ELIST command (which also resets
|                  the margins and spacing).
| 
|              5.  Lists can be nested within lists.  This is handled as follows:
| 
|                  1.  The  left  margin  is  set  9  columns to the right for the
|                      outermost list, and 4 columns to the right for  each  inner
|                      list.
| 
|                  2.  Each .LIST must be terminated by a  matching  .ELIST.   The
|                      .ELIST  resets  the margins and spacing as they were before
|                      the .LIST command.
| 
|                  3.  For  users of autoparagraphing, the paragraph margin is set
|                      to coincide with the left margin, and paragraph spacing  is
|                      set to the list spacing plus 1.
| 
| 
|                      This means that autoparagraphing can be  conveniently  used
|                      at any list level.
| 
| 
|                      The paragraph values are reset by the .ELIST command.
| 
|              6.  Lists can be nested up to 5 levels.
| 
|         The list facility can be a significant convenience for the typist.
| 1
| 
| 
|         38                         RNF                           Examples
| 
| 
|         5.5  CHANGE BAR EXAMPLES
| 
|         .BAR .AP
|         .C ^USING ^CHANGE ^BARS
|         .B
|          ^CHANGE BARS ARE USED TO FLAG TEXT WHICH HAS BEEN
|         ALTERED SINCE THE LAST VERSION OF A DOCUMENT, AND ARE
|         COMMONLY FOUND ONLY IN TECHNICAL WRITING,
|         .BB WHERE THE READER MUST BE ALTERTED TO NEW FEATURES. .EB
|          ^THE <.BAR COMMAND ENABLES CHANGE BARS, AND HAS THE IMMEDIATE
|         EFFECT OF SHIFTING ALL OUTPUT TEXT RIGHT
|         .BB THREE .EB
|         SPACES.
|         ^THE <.NOBAR COMMAND DISABLES CHANGE BARS.  ^USUALLY, THE .BAR COMMAND
|         APPEARS BEFORE ANY TEXT IN A DOCUMENT, SO THE LEFT MARGIN IN THE OUTPUT
|         IS UNIFORM.
|          ^THE <.BB (^BEGIN ^BAR) COMMAND TURNS ON CHANGE BARS.  ^THAT IS,
|         <.BB CAUSES A ! TO APPEAR AT THE LEFT MARGIN FOR ANY LINES WHICH
|         ARE OUTPUT AFTER THE <.BB
|         .BB (INCLUDING BLANK LINES WHICH ARE A PART OF THE TEXT). .EB
|          ^THE <.EB (^END ^BAR) COMMAND SIGNIFIES THE END OF THE CHANGE
|         BEGUN BY <.BB, AND TURNS OFF CHANGE BARS.
|          .BB ^SPACES CAUSED BY THE <.RIGHT COMMAND APPEAR TO THE LEFT OF
|         THE THREE EXTRA COLUMNS USED BY THE <.BAR FEATURE.
|          ^BLANK LINES WHICH APPEAR AS A PART OF CHANGED TEXT ARE
|         ALSO FLAGGED BY A BAR.
| 1
| 
| 
|         Examples                   RNF                                 39
| 
| 
|  ×                                    Using Change Bars
|  ×
|  ×
|  ×         Change bars are used to flag text which has been altered since the  l
|  ×         version of a document, and are commonly found only in technical writi
|  ×         where the reader must be alterted to new features.
| 
|            The .BAR command enables change bars, and has the  immediate  effect
|  ×         shifting  all  output  text  right  three  spaces.   The  .NOBAR comm
|            disables change bars.  Usually, the command appears before any text i
|            document, so the left margin in the output is uniform.
| 
|            The .BB (Begin Bar) command turns on change bars.  That is, .BB cause
|            !  to appear at the left margin for any lines which are output after
|  ×         .BB (including blank lines which are a part of the text).
| 
|            The .EB (End Bar) command signifies the end of the change begun by  .
|            and turns off change bars.
| 
|  ×         Spaces caused by the .RIGHT command appear to  the  left  of  the  th
|  ×         extra columns used by the .BAR feature.
|  ×
|  ×         Blank lines which appear as a part of changed text are also flagged b
|  ×         bar.
| 1
| 
| 
|         40                         RNF                           Examples
| 
| 
|         5.6  TAB EXAMPLES
| 
|         .ASCII
|         .c Using <rno Tabs
|         .ap
|          <rno tab stops are set by the <.tabs command.  The format is:
|          .i 9 <.tabs c1 c2 <... c15
|          where c1 through c15 are character positions, in ascending order,
|         where the tab stops are to be set.
|         (Character positions are numbered beginning at 1). To work
|         correctly, tab stops must not be set beyond the right margin.
|          Tabs are used by the <.t command, which means "begin the next
|         word at the next tab stop".
|          For example, the following
|          .i 9 <.tabs 10 20 30 40
|         .br .i 9 Line <.t this <.t up <.t in <.t columns
|          produces
|         .tabs 19 29 39 49
|          .i 9 Line .t this .t up .t in .t columns
|          The following features should be noted:
|         .tab 30 .p -21 2 5 .lm 30
|          Justification .t Having tabs in a line does not suppress
|         justification.  Only the text after the last tab in a line is blank
|         padded.  This permits convenient use of "hanging" titles and
|         indentation.
|          Left/Right .t Tabs produced by <.t cause the following
|         word to begin at the next tab stop.  The <.rt
|         command causes the following word to end at the
|         next tab stop.  This permits creating tables of numeric
|         data.
| 1
| 
| 
|         Examples                   RNF                                 41
| 
| 
|                                     Using RNO Tabs
| 
|         RNO tab stops are set by the .TABS command.  The format is:
| 
|          .TABS c1 c2 ...  c15
| 
|         where c1 through c15 are character positions, in ascending order,  where
|         the  tab  stops  are  to  be  set.   (Character  positions  are numbered
|         beginning at 1).  To work correctly, tab stops must not  be  set  beyond
|         the right margin.
| 
|         Tabs are used by the .T command, which means "begin the next word at the
|         next tab stop".
| 
|         For example, the following
| 
|          .TABS 10 20 30 40
|          Line .T this .T up .T in .T columns
| 
|         produces
| 
|          Line      this      up        in        columns
| 
|         The following features should be noted:
| 
|          Justification        Having  tabs  in  a   line   does   not   suppress
|                               justification.   Only  the text after the last tab
|                               in  a  line  is  blank   padded.    This   permits
|                               convenient    use    of   "hanging"   titles   and
|                               indentation.
| 
|          Left/Right           Tabs produced by .T cause the  following  word  to
|                               begin  at  the  next  tab  stop.   The .RT command
|                               causes the following word to end at the  next  tab
|                               stop.   This  permits  creating  tables of numeric
|                               data.
| 1
| 
| 
|         42                         RNF                           Examples
| 
| 
|         5.7  MACRO EXAMPLES
| 
|         .MACRO BBCB 1 = .B .B .C .BBCB1 .B
|         .MACRO NOTE * = .SAV .TP 8 .SP 1 .LM +15 .RM -15 .P +0 1 5 .BBCB .NOTE1
|         .MACRO ENOTE = .B .B .RES
|         .AP
|         .C ^THE <NOTE ^COMMAND
|          ^THIS EXAMPLE SHOWS THE DEFINITION OF A USEFUL COMMAND VIA THE <.MACRO
|         FACILITY.
|         .NOTE ^WARNING
|         ^THIS COMMAND CAN BE HABIT-FORMING.  ^USE IT SPARINGLY.
|         .ENOTE
|         ^TRY IT, YOU'LL LIKE IT!
| 1
| 
| 
|         Examples                   RNF                                 43
| 
| 
|                                    The NOTE Command
| 
|         This example shows the definition of a useful  command  via  the  .MACRO
|         facility.
| 
| 
|                                         Warning
| 
|                        This command can be habit-forming.  Use it
|                        sparingly.
| 
| 
|         Try it, you'll like it!
| 1
| 
| 
|         44                         RNF                     How To Run RNF
| 
| 
| 
| 
| 
| 
| 
|                                        CHAPTER 6
| 
|                                     HOW TO RUN RNF
| 
| 
| 
|         This is implementation dependent information!
| 
|         The following jcl may be used to run RNF:
| 
|         //RNF EXEC PGM=RUNOFF,REGION=90K,PARM='/IOBUF=16K',TIME=(2,00)
|         //OUTPUT DD SYSOUT=(G,,0721),DCB=(LRECL=133,BLKSIZE=133,RECFM=FBA)
|         //QRR DD SYSOUT=A,DCB=(LRECL=90,BLKSIZE=90,RECFM=FB)
|         //INPUT DD *
|            runoff text
|         /*
| 
| 
|         NOTES:
| 
|         If  you  do not wish to see the input printed, specify DUMMY, instead of
|         SYSOUT=A on the QRR DD card.
| 
|         Adjust  REGION=90K  if BLKSIZE parameters are too large, but this should
|         be sufficient for the normal case.
| 
|         Be sure to specify the proper OUTPUT DD sysout class and form.
| 
|         Be sure to specify the correct library in the //STEPLIB or  //JOBLIB  DD
|         card.
| 1
| 
| 
| 
| 
| 
| 
| 
| 
| 
|                                    TABLE OF CONTENTS
| +                                  _____ __ ________
| 
| 
|              Section     Title and Page
| +            _______     _____ ___ ____
| 
|                          CHAPTER 1 -- INTRODUCTION   1
|              .1           FEATURES  1
|              .2           INPUT TEXT  2
|              .2.1         NORMAL Input  2
|              .2.2         ASCII Input  2
|              .3           WORDS  3
|              .4           LINES  3
|              .5           SPACING  4
|              .6           PARAGRAPHS  4
|              .7           PAGES  5
|              .7.1         Explicit Paging Control  5
|              .7.2         Page Format  5
| 
|              2           CHAPTER 2 -- COMMANDS   7
|                           .AP  7
|                           .ARRAY  7
|                           .ASCII  8
|                           .ASIS  8
|                           .ATITLE  8
|                           .AUTOCAP  8
|                           .B  8
|                           .BAR  9
|                           .BB  9
|                           .BOT  9
|                           .BR  9
|                           .C  9
|                           .CH  9
|                           .CR  10
|                           .DEBUG1  10
|                           .DEBUG2  10
|                           .DEC  10
|                           .DELMAC  10
|                           .DOT  10
|                           .EB  10
|                           .ELIST  10
|                           .ESC  11
|                           .F  11
|                           .FIG  11
|                           .FLAG  11
|                           .FLAGCAPS  11
| 
| 
| 
| 
| 
|                                            i
| 1
| 
| 
| 
| 
| 
| 
| 
| 
| 
|                              TABLE OF CONTENTS (Continued)
| +                            _____ __ ________ ___________
| 
| 
|              Section     Title and Page
| +            _______     _____ ___ ____
| 
|                           .FLAGOVER  11
|                           .FLAGSIG  12
|                           .FRCPAGE  12
|                           .FMT  12
|                           .HL  13
|                           .I  13
|                           .IF  13
|                           .INC  13
|                           .J  14
|                           .LE  14
|                           .LINES  14
|                           .LIST  14
|                           .LPT  14
|                           .LM  14
|                           .LOWER  14
|                           .MACRO  14
|                           .MID  15
|                           .NMP  15
|                           .P  15
|                           .PAGE  15
|                           .PERIOD  15
|                           .PNO  16
|                           .PP  16
|                           .PS  16
|                           .REM  16
|                           .RES  16
|                           .RESPAG  16
|                           .RIGHT  16
|                           .RM  16
|                           .RT  17
|                           .S  17
|                           .SAV  17
|                           .SAVPAG  17
|                           .SIG  17
|                           .SP  17
|                           .ST  18
|                           .STD  18
|                           .SUP  18
|                           .T  18
|                           .TABS  18
| 
| 
| 
| 
| 
|                                           ii
| 1
| 
| 
| 
| 
| 
| 
| 
| 
| 
|                              TABLE OF CONTENTS (Continued)
| +                            _____ __ ________ ___________
| 
| 
|              Section     Title and Page
| +            _______     _____ ___ ____
| 
|                           .TITLE  18
|                           .TOP  18
|                           .TP  18
|                           .U  19
|                           .UPP  19
|                           .UPPER  19
|                           .USB  19
|                           .VAR  19
|                           .X  19
| 
|              3           CHAPTER 3 -- MACROS   21
|              .1           WHAT MACROS ARE  21
|              .2           HOW TO DEFINE A MACRO  22
|              .3           SUB-MACROS  22
|              .3.1         Defining Parameterized Macros  23
|              .3.2         Sub-macro Semantics  23
| 
|              4           CHAPTER 4 -- VARIABLES   24
|              .1           VARIABLE SYNTAX  24
|              .2           HOW TO DECLARE VARIABLES  25
|              .3           PREDEFINED VARIABLES  25
|              .4           VARIABLE ARRAYS  25
|              .5           EXPRESSIONS  26
|              .5.1         Expression Syntax  26
|              .5.2         Expression Evaluation  27
|              .5.3         Where Expressions Are Used  27
|              .5.4         Suppressed Expressions  28
| 
|              5           CHAPTER 5 -- EXAMPLES   30
|              .1           INPUT TEXT EXAMPLE  31
|              .2           PARAGRAPHING  33
|              .3           HEADER LEVEL EXAMPLES  35
|              .4           EXAMPLES OF LISTS  37
|              .5           CHANGE BAR EXAMPLES  39
|              .6           TAB EXAMPLES  41
|              .7           MACRO EXAMPLES  43
| 
|              6           CHAPTER 6 -- HOW TO RUN RNF   45
| 
| 
| 
| 
| 
| 
| 
|                                           iii
| 1
> Member RNFDOCIN
| .LM +7 .RM +7
| .REM .RIGHT 10
| .MACRO INPAG   = .SAV .RESPAG .S 3
| .MACRO OUTPAG  = .S 2 .RES
| .MACRO LPAG    = .IF $LP $$PAGE=$$PAGE+1 .T <RNF .RT .CHTTL
| .MACRO RPAG    = .IF #$LP .CHTTL .T <RNF .RT $$PAGE=$$PAGE+1
| .MACRO CH *    = .PAGE .RESPAG .BR # .BR .S 4 .CHA .B .CHB .S 3 $$HL=0;
| .MACRO CHA     = .C <CHAPTER $$CH=$$CH+1 .BR
| .MACRO CHB     = .C .CH1 .BR
| .MACRO BDOT = .SAV .P -2 1 5 .LM +5
| .MACRO DOT = .PP _.# .X
| .MACRO EDOT = .RES .S 1
| .VAR $LP
| .TAB 35 72 .SP 1 .SAVPAG
| .PS 58 72 .LINES 66
| .AP .P +0 1 4
| .NONMP
| .FIG 20
| .C .U <RNF
| .B
| .C ^TEXT ^PROCESSOR .NOU
| .B .B
| .C ^REFERENCE ^GUIDE
| $$PAGE=0;
| .MACRO FRCPAGE = .TOP .INPAG .LPAG .RPAG .OUTPAG .MID $LP=#$LP;
| .MACRO CHTTL   = ^INTRODUCTION
| .CH <INTRODUCTION
|  <RNF IS A TEXT FORMATTING PROGRAM FOR THE ^CYBER SIMILIAR TO THE
| <RUNOFF PROGRAM AVAILABLE ON THE <DEC<SYSTEM-10.
|  <RNF ACCEPTS (MOSTLY) FREE-FORMAT TEXT WHICH HAS BEEN PUT IN
| A FILE AND EDITED BY <BOSS, AND PRODUCES OUTPUT SUITABLE FOR
| A LINE PRINTER OR A TYPEWRITER-LIKE TERMINAL DEVICE.
| .HL 1 ^FEATURES
|  <RNF DOES ANY OR ALL OF THE FOLLOWING FOR THE USER:
| .SAV .P -16 1 3 .LM 25 .TABS 25
|  ^PAGINATION .T <RNF AUTOMATICALLY BREAKS TEXT UP INTO
| PAGES, AND BY DEFAULT NUMBERS THEM SEQUENTIALLY.
|  ^FILL .T ^USING THE MARGINS SET BY THE USER, <RNF
| AUTOMATICALLY "FILLS" EACH LINE OF THE OUTPUT WITH AS MANY WORDS
| AS IT CAN HOLD WITHOUT EXCEEDING THE RIGHT MARGIN.  ^FILLING
| STOPS AT THE END OF A PARAGRAPH, ETC.
|  ^JUSTIFICATION .T <RNF WILL OPTIONALLY JUSTIFY FILLED LINES
| ON THE RIGHT, SO THAT THE RIGHT MARGIN "LINES UP" EVENLY.
|  ^CHAPTERING .T <RNF WILL FORMAT CHAPTER TITLES, AND
| NUMBER CHAPTERS SEQUENTIALLY.
|  ^SECTIONING .T <RNF WILL FORMAT SECTION HEADERS AND NUMBER
| SECTIONS AND SUBSECTIONS SEQUENTIALLY.
|  ^LISTS .T <RNF WILL FORMAT AND NUMBER LISTS AND
| SUBLISTS.
| .RES
|  ^IN ADDITION TO THE FEATURES WHICH ARE BUILT IN,
| <RNF PROVIDES AN EASY TO USE MACRO FACILITY WHICH PERMITS
| THE USER TO DEFINE COMMANDS WHICH ARE CUSTOMIZED TO A PARTICULAR
| APPLICATION.
| .HL 1 ^INPUT ^TEXT
|  ^THE INPUT TO <RNF MAY BE PREPARED EITHER ON AN UPPER CASE ONLY
| DEVICE LIKE A ^TELETYPE OR PUNCHED CARDS, OR ON AN UPPER/LOWER
| CASE TERMINAL.  ^THESE ARE CALLED <NORMAL AND <ASCII DEVICES,
| RESPECTIVELY.
|  ^REGARDLESS OF THE INPUT MEDIUM, OUTPUT FROM <RNF IS IN UPPER/LOWER
| CASE.  ^THIS IS ACCOMPLISHED BY THE FOLLOWING CONVENTIONS:
| .HL 2 <NORMAL ^INPUT
|  ^BY CONVENTION, <RNF INVERTS THE CASE OF ALPHABETIC CHARACTERS IN
| THE INPUT.
| ^UPPER CASE CHARACTERS ARE INDICATED BY A PRECEDING _^.  ^FOR
| EXAMPLE, THE FOLLOWING <NORMAL INPUT
| .ASCII
|  .I 9 _^THIS IS AN _^U_^P_^P_^E_^R/LOWER CASE LINE.
| .NOASCII
|  IS OUTPUT BY <RNF AS
|  .I 9 ^THIS IS AN <UPPER/<LOWER CASE LINE.
|  ^AS A CONVENIENCE, THE _< CHARACTER WILL INVERT THE CASE OF ALL
| ALPHABETIC CHARACTERS WHICH FOLLOW IT IN THE SAME WORD.
| ^FOR EXAMPLE,
| .ASCII
|  .I 9 _^SOME _<UPPER _<CASE AND SOME LOWER CASE.
|  .I 9 SOME_<OF_<BOTH
| .NOASCII
|  ARE OUTPUT AS
|  .I 9 ^SOME <UPPER <CASE AND SOME LOWER CASE.
|  .I 9 SOME<OF<BOTH
|  ^IN EXCHANGE FOR THIS CONVENIENCE, THE CHARACTERS _^ AND _@ MUST
| BE REPRESENTED IN <NORMAL INPUT AS _@^B AND _@^A, RESPECTIVELY.
| .HL 2 <ASCII ^INPUT
|  ^UPPER/LOWER CASE TEXT CAN BE ENTERED IN A FILE BY USING <ASCII
| MODE IN <BOSS.  ^WHEN SUBMITTED TO <RNF, THIS TEXT MUST BE PRECEDED
| BY AN <.ASCII COMMAND.
| ^THE _< CHARACTER WORKS THE SAME.
| .HL 1 <WORDS
|  <RNF INPUT IS A SERIES OF WORDS, WHERE A WORD IS ANY SEQUENCE
| OF NON-BLANK CHARACTERS.
|  ^BLANKS IN THE INPUT TEXT ARE NOT (USUALLY) SIGNIFICANT TO
| <RNF, EXCEPT THAT THEY DELIMIT WORDS.  <RNF INSERTS ONE
| BLANK BETWEEN EACH WORD, AND TWO BLANKS AFTER WORDS WHICH
| END SENTENCES.
|  ^IF A SEQUENCE OF BLANKS MUST APPEAR IN THE OUTPUT, THE
| SIGNIFICANT BLANK CHARACTER _# IS USED.  ^FOR EXAMPLE,
| BE_#_#_#_#TWEEN IS OUTPUT AS BE####TWEEN.
| .HL 1 <LINES
|  ^IN DEFAULT MODE, WORDS ARE
| PICKED FROM THE INPUT ONE BY ONE AND PLACED INTO AN OUTPUT
| LINE.  ^WHEN AN OUTPUT LINE IS FULL, IT IS WRITTEN INTO THE
| OUTPUT FILE.
|  ^THE USER SETS THE LEFT AND RIGHT MARGINS OF THE OUTPUT PAGE
| BY THE <.LM AND <.RM COMMANDS, RESPECTIVELY.
| ^TEXT ON THE OUTPUT LINE IS WRITTEN BEGINNING AT THE LEFT MARGIN
| AND NOT PAST THE RIGHT MARGIN.
|  ^FILLING MEANS THAT (UNLESS THE USER SPECIFICALLY DIRECTS OTHERWISE)
| AS MANY WORDS AS POSSIBLE ARE USED TO FILL EACH OUTPUT LINE.
|  ^JUSTIFICATION MEANS THAT BLANK CHARACTERS ARE ADDED BETWEEN
| WORDS SO THAT THE LAST CHARACTER ON EACH LINE IS EXACTLY ON THE
| RIGHT MARGIN.
|  ^THE <.F AND <.J COMMANDS CONTROL FILLING AND JUSTIFICATION.
|  ^THE DEFAULT LEFT MARGIN IS 1 AND THE DEFAULT RIGHT MARGIN IS
| 72.  ^FOR ^ELITE TYPE (12 CHARACTERS PER INCH) THIS PRODUCES
| A 6-INCH WIDE LINE, WHICH ALLOWS 1 AND 1/4 INCH MARGINS ON
| STANDARD 8 AND 1/2 INCH PAPER.  ^FOR ^PICA TYPE (10 CHARACTERS
| PER INCH) <.LM 1 AND <.RM 60 PROVIDE THE SAME SIZE LINE.
|  ^FOR MOST PURPOSES, IT IS RECOMMENDED THAT THE LEFT MARGIN BE
| INITIALLY SET TO 1, AS THIS IS EASY TO WORK WITH AND REMEMBER.
| ^IF THE TEXT MUST BE SHIFTED TO THE RIGHT FOR OUTPUT ON A
| TYPEWRITER PAGE, THE <.RIGHT COMMAND MAY BE USED.
| .HL 1 <SPACING
|  ^THE INPUT TO <RNF IS SINGLE SPACED.  ^THE OUTPUT MAY BE SINGLE
| SPACED, DOUBLE SPACED, OR TRIPLE SPACED AS THE USER CHOOSES.
|  ^SPACING IS SET BY THE <.SP COMMAND,.
| ^ONCE SET, <RNF WILL AUTOMATICALLY
| CONTROL SPACING WITHOUT REQUIRING ANY FURTHER ACTION
| ON THE PART OF THE USER.  ^IF EXTRA SPACES OR NON-STANDARD SPACING
| IS DESIRED, HOWEVER, <RNF PROVIDES COMMANDS FOR THESE, TOO.
|  ^THE <.CR COMMAND PROVIDES THE EQUIVALENT OF A CARRIAGE RETURN
| KEY ON AN ELECTRIC TYPEWRITER.  ^THE <.CR ENDS THE CURRENT LINE
| AND SPACES AS SET BY <.SP.  ^THAT IS, IF SINGLE SPACING IS
| SELECTED (<.SP 1), THE <.CR "RETURNS THE CARRIAGE" TO THE NEXT
| LINE; IF DOUBLE SPACING IS SELECTED (<.SP 2), THE <.CR LEAVES
| A SINGLE BLANK LINE AFTER THE CURRENT LINE, AND SO ON.  ^THROUGHOUT
| THIS MANUAL, THE ACTION OF THE <.CR IS REFERRED TO AS A "RETURN".
| ^MANY COMMANDS CAUSE A RETURN AS A PRELUDE TO FURTHER ACTION.
|  ^THE <.S COMMAND CAUSES A RETURN, FOLLOWED BY ANY NUMBER OF EXTRA
| RETURNS.
| <.S AND <.S#1 MEAN THE SAME, I.E., A RETURN AND ONE EXTRA RETURN.
| <.S#2 PROVIDES TWO EXTRA RETURNS, AND SO ON.
|  <.CR AND <.S ALWAYS HONOR THE SPACING SET BY <.SP.  ^THE USER
| CAN ESCAPE SPACING BY MEANS OF THE <.BR AND <.B COMMANDS.
|  <.BR PROVIDES A "BREAK"; IT RETURNS THE CARRIAGE AND PROCEEDS
| ON THE NEXT LINE, REGARDLESS OF SPACING.  <.B CAUSES ANY NUMBER
| OF BLANK LINES AFTER THE CURRENT LINE.  <.B AND <.B#1 MEAN THE
| SAME: BREAK AND LEAVE ONE BLANK LINE AFTER THE CURRENT LINE.
| <.B#2 LEAVES TWO BLANK LINES, AND SO ON.
|  ^THUS, THE USER CAN CREATE SPACING INDEPENDENT TEXT BY USING
| ONLY <.CR AND <.S COMMANDS FOR SPACING.  <.BR AND <.B ARE USED
| WHEN SPACING IS TO BE FIXED REGARDLESS OF THE <.SP SETTING.
| .HL 1 <PARAGRAPHS
|  <RNF PROVIDES BOTH EXPLICIT AND AUTOMATIC PARAGRAPHING FACILITIES.
| ^THE <.P COMMAND CONTROLS THE INDENTATION, SPACING, AND LOCATION
| OF EACH PARAGRAPH.  ^THE <.PP COMMAND BEGINS A NEW PARAGRAPH.
|  ^AUTOPARAGRAPHING, CONTROLLED BY THE <.AP COMMAND, CAUSES AN
| IMPLICIT <.PP COMMAND EACH TIME EITHER A BLANK LINE OR A LINE
| BEGINNING WITH BLANK IS ENCOUNTERED IN THE INPUT TEXT.
| ^THIS IS A CONVENIENT FORMAT FOR TEXT ENTRY, AND ALLOWS
| EASY MODIFICATION.
| ^BY USE OF THE <.SP (^S^PACING) AND <.P COMMANDS, THE SAME INPUT
| TEXT CAN BE USED FOR PRODUCING BOTH DOUBLE (OR TRIPLE) SPACED DRAFTS
| AND SINGLE SPACED FINAL COPY.
|  ^PARAGRAPHING IS SUFFICIENTLY FLEXIBLE TO BE USED FOR
| "HANGING INDENTS".
| ^IN ADDITION, THE FACT THAT PARAGRAPH INDENTATION CAN BE
| SPECIFIED RELATIVE TO THE LEFT MARGIN (EVEN IF IT IS LATER
| CHANGED) ALLOWS PARAGRAPHING TO BE CONVENIENTLY USED IN
| INDENTED TEXT.
| .HL 1 <PAGES
|  ^LINES ARE AUTOMATICALLY SEPARATED INTO PAGES BY <RNF.
| ^TWO COMMANDS CONTROL THE SIZE OF <RNF PAGES: <.PS (^PAGE ^SIZE)
| AND <.LINES.
|  ^THE FIRST ARGUMENT OF <.PS SPECIFIES THE NUMBER OF LINES WHICH
| ARE ALLOWED ON A PAGE BEFORE AN AUTOMATIC PAGE THROW IS DONE.
| ^THIS NUMBER INCLUDES THE LINES IN THE HEADER AT THE TOP OF EACH
| PAGE, AND THE NORMAL TEXT ON THE PAGE, BUT DOES NOT INCLUDE THE
| LINES IN THE FOOTER (IF ANY) AT THE BOTTOM OF THE PAGE.
| ^THE <.LINES COMMAND SPECIFIES THE NUMBER OF LINES ON THE
| ENTIRE PAGE.  ^THIS NUMBER IS USED WHEN SIMULATING PAGE EJECTS
| ON TERMINALS WITH CONTINUOUS FORMS.
|  ^THE DEFAULT <.PS FIRST ARGUMENT AND <.LINES ARE 58 AND 66,
| RESPECTIVELY.  ^THIS ALLOWS AT LEAST A 1 AND 1/3 INCH BOTTOM
| MARGIN WITH 6 LINE PER INCH PRINTING, AND A 1 INCH MARGIN WITH
| LINE PER INCH PRINTING ON STANDARD <CSO REDUCED FORMS.
|  ^SOME TERMINALS USE REDUCED FORMS BUT PRINT 6 LINES PER INCH.
| ^THIS MEANS THERE ARE 51 LINES ON EACH PAGE; A <.PS FIRST ARGUMENT
| OF 44 WILL ALLOW A 1 INCH BOTTOM MARGIN.
| .HL 2 ^EXPLICIT PAGING CONTROL
|  ^THE <.PAGE COMMAND ALLOWS THE USER TO ADVANCE TO THE NEXT PAGE
| EXPLICITLY.  ^THE <.NMP AND <.PNO COMMANDS CONTROL PAGE NUMBERING,
| AND THE <.TITLE, <.ST, AND <.ATITLE COMMANDS PROVIDE FOR PRINTING
| TITLES AT THE TOP OF EACH PAGE.
| .HL 2 ^PAGE ^FORMAT
|  ^A PAGE IS DIVIDED INTO THREE AREAS:
| .BDOT .DOT ^THE TOP, WHICH CONTAINS THE UPPER MARGIN AND OPTIONAL
| TITLES AND PAGE NUMBER.
| .DOT ^THE MIDDLE, WHICH CONTAINS THE TEXT OF THE DOCUMENT.
| .DOT ^THE BOTTOM, WHICH MAY CONTAIN A FOOTER.  (^BY DEFAULT, NO
| FOOTER IS PRINTED.)
| .EDOT
|  ^THE DEFAULT HEADER CONSISTS OF AN OPTIONAL TITLE ON THE LEFT AND
| THE PAGE NUMBER AS AN ^ARABIC NUMBER ON THE RIGHT OF THE FOURTH
| LINE ON THE PAGE.
| ^THE SUBTITLE, IF ANY, IS BELOW THE TITLE ON THE FOLLOWING LINE.
| ^TWO BLANK LINES ARE LEFT BELOW THE HEADER.
|  ^IF THIS DEFAULT FORMAT IS NOT SATISFACTORY FOR A SPECIFIC
| DOCUMENT, THE USER MAY SUBSTITUTE ANY ARBITRARY HEADER AND
| FOOTER TEXT BY MEANS OF A <.FRCPAGE MACRO DEFINITION (SEE ^CHAPTER 3)
| AND USE OF THE PAGING INTRINSICS <.TOP, <.MID, AND <.BOT.
|  ^THE PAGE NUMBER USED BY <RNF MAY BE ACCESSED DIRECTLY THROUGH
| THE PREDEFINED VARIABLE <$$PAGE (SEE ^CHAPTER 4).
| .MACRO CHTTL = ^COMMANDS
| .CH <COMMANDS
|  ^ANY SEQUENCE OF NON-BLANK CHARACTERS BEGINNING WITH A PERIOD
| (.) ARE TAKEN BY <RNF TO BE A COMMAND.  ^IF THE COMMAND IS NOT
| RECOGNIZED, AN ERROR MESSAGE IS PRODUCED.
|  ^MANY COMMANDS REQUIRE ARGUMENTS, I.E., WORDS WHICH FOLLOW
| THE COMMAND AND MODIFY ITS ACTION IN SOME WAY.
| ^THE ONLY COMMANDS WHICH PERMIT A VARIABLE NUMBER OF ARGUMENTS
| ARE <.TAB (OR <.TABS), <.B, AND <.S.
| IF ANY OTHER COMMAND REQUIRES AN ARGUMENT, IT MUST BE SPECIFIED.
|  ^COMMANDS MAY BE FREELY INTERSPERSED WITH TEXT.  ^SOME COMMANDS
| CAUSE A "RETURN" (THAT IS, ACT AS IF THEY WERE PRECEDED BY A
| <.CR COMMAND) AS A PART OF THEIR ACTION.  ^IF A COMMAND CAUSES
| A RETURN, THIS IS INDICATED IN PARENTHESIS AFTER THE COMMAND
| FORMAT.
| ^OTHER COMMANDS CAUSE A "BREAK" (THAT IS, ACT AS IF THEY WERE
| PRECEDED BY A <.BR COMMAND) AS A PART OF THEIR ACTION.
| ^THESE ARE INDICATED BY (^BREAK) IN PARENTHESIS.
|  ^NOTE THAT A BLANK MUST FOLLOW A COMMAND IF THERE IS MORE TEXT ON
| THE SAME LINE.  ^FOR EXAMPLE, THE SEQUENCE "<.B.I#5" IS IN ERROR;
| IT MUST BE WRITTEN AS "<.B#.I#5".
| .LM 9
| .TAB 72
| .P -4 2 4
|  <.AP
| .B ^ANY BLANK LINE OR ANY LINE BEGINNING WITH A BLANK CHARACTER
| BEGINS A NEW PARAGRAPH.  ^SEE THE <.P AND THE <.PP COMMANDS.
| <.NOAP TURNS AUTOPARAGRAPHING OFF AND IS THE DEFAULT.
|  <.ARRAY VARIABLENAME N
| .B ^THIS COMMAND DECLARES AN ARRAY VARIABLE WITH THE NAME SPECIFIED
| AND N+1 ELEMENTS.  ^AN ELEMENT OF THE ARRAY IS LATER ACCESSED OR
| CHANGED BY A REFERENCE OF THE FORM:
| .B .I 9 VARIABLENAME[EXPRESSION]
| .B WHERE EXPRESSION MAY BE IN THE RANGE 0 THROUGH N.
| ^THE ZEROETH ELEMENT OF THE ARRAY MAY BE REFERRED TO WITHOUT
| A [0] SUBSCRIPT, AND IS COMMONLY USED AS AN INDEX INTO THE
| REMAINDER OF THE ARRAY.
| .B ^ALL ARRAY ELEMENTS HAVE THE INITIAL VALUE ZERO. ^ARRAY NAMES
| MUST BE FORMED AS DEFINED FOR THE <.VAR COMMAND.
|  <.ASCII
| .B ^THE INPUT WAS PREPARED IN <ASCII MODE ON AN UPPER/LOWER CASE
| TERMINAL.
| ^WHEN IN <ASCII MODE CAHRACTERS ARE NOT AUTOMATICALLY CASE INVERTED. ^ALSO THE
| EFFECT OF THE _^ CHARACTER IS REVERSED, IN <ASCII MODE _^ LOWERS A CAPITAL
| LETTER AND DOES NOTHING TO A LOWER CASE LETTER.
| ^THE DEFAULT IS <.NOASCII.
|  <.ASIS .RT (^RETURN)
| .B ^TERMINATES THE CURRENT INPUT LINE AND ENTERS AS IS MODE BEGINNING
| WITH THE NEXT INPUT LINE.
| .B ^IN AS IS MODE, INPUT LINES ARE COPIED DIRECTLY TO THE OUTPUT
| (EXCEPT THAT THE LEFT MARGIN, CHANGE BARS, AND <.RIGHT SPACING
| ARE STILL HONORED).
| .B ^AS IS MODE IS TERMINATED BY A LINE WITH AN EXCLAMATION MARK
| (!) IN COLUMN 1.  ^ALL CHARACTERS AFTER THE EXCLAMATION MARK ARE
| IGNORED, AND NORMAL PROCESSING BEGINS WITH THE FOLLOWING LINE.
| .B ^NOTE THAT AS IS TEXT WHICH IS INTENDED TO BE OUTPUT
| AS UPPER/LOWER CASE (<ASCII) MUST BE INPUT IN <ASCII.
| .U ^NO .NOU PROCESSING IS DONE ON AS IS TEXT.
|  <.ATITLE
| .B ^ENABLES AUTOTITLING, WHICH MAKES EACH NEW CHAPTER HEADING
| THE TITLE FOR ALL BUT THE FIRST PAGE OF THE CHAPTER.  ^THE
| DEFAULT IS <.NOATITLE.
|    <.AUTOCAP
| .B ^ENABLES THE AUTO CAPITALIZATION, WHICH MAKES THE CHARACTER FOLLOWING
| A _., _!, _?, REMAIN IN UPPER CASE. ^THIS IS DISABLED IN <ASCII MODE.
| ^IT TAKES EFFECT AFTER THE FIRST PUNCTUATION MARK, SO IT MAY NOT AFFECT
| TITLES OR THE FIRST LINE. <NOAUTOCAP IS THE DEFAULT.
|  <.B .RT (^BREAK)
| .BR .I -4 <.B N .RT (^BREAK)
| .B ^ENDS THE CURRENT LINE AND WRITES IT WITHOUT FURTHER FILLING
| OR JUSTIFICATION (CAUSES A BREAK), THEN WRITES N BLANK LINES.
| <.B AND <.B#1 ARE EQUIVALENT.
|  <.BAR
| .B ^ENABLES CHANGE BARS.  ^ALL TEXT FOLLOWING THE <.BAR COMMAND
| IS SHIFTED RIGHT THREE SPACES.  ^SEE THE <.BB AND <.EB COMMANDS.
| ^THE DEFAULT IS <.NOBAR.
|  <.BB
| .B ^BEGIN PLACING CHANGE BARS (VERTICAL BARS) IN THE MARGIN
| CREATED BY THE <.BAR COMMAND BEGINNING WITH THE LINE WHICH
| CONTAINS THE FIRST WORD IN THE TEXT FOLLOWING THE <.BB COMMAND.
| ^SEE THE <.EB COMMAND.
|  <.BOT
| .B ^SETS THE BEGINNING OF USER TEXT (ON THE PAGE) TO THE CURRENT OUTPUT LINE
| NUMBER
| AND RESTORES ANY OUTPUT LINES WHICH MIGHT HAVE
| BEEN SAVED ON A FORCED PAGE EJECT (SEE <.FRCPAGE).
| ^IF ANY DEFERRED TEXT IS PENDING (SEE THE <.FIG COMMAND), AS MUCH OF IT
| AS POSSIBLE IS OUTPUT BY <.BOT.  ^IF AS IS MODE WAS IN EFFECT AT THE TIME OF
| THE LAST <.FRCPAGE, IT IS RESTORED.
| .B ^THE <.BOT
| COMMAND IS TO BE USED ONLY WHEN OVERRIDING THE DEFAULT
| HEADER FORMAT VIA MACROS.
| .B ^THE <.B AND <.S COMMANDS HAVE NO EFFECT AT THE BEGINNING
| OF USER TEXT ON A PAGE.  ^THIS PREVENTS SPURIOUS BLANK LINES AT THE TOP
| OF A TEXT PAGE.
|  <.BR .RT (^BREAK)
| .B ^ENDS THE CURRENT OUTTPUT LINE AND WRITES IT WITHOUT FURTHER
| FILLING OR JUSTIFICATION.  ^NO EXTRA BLANK LINES ARE LEFT BY
| <.BR, REGARDLESS OF SPACING.
|  <.C TEXT .RT (^RETURN)
| .B ^CENTERS THE TEXT WHICH FOLLOWS THE <.C COMMAND ON THE
| SAME LINE.  ^CENTERING IS BETWEEN THE CURRENT LEFT AND RIGHT
| MARGINS.
|  <.CH TITLE .RT (^RETURN)
| .B ^BEGINS A NEW CHAPTER WITH THE TITLE WHICH FOLLOWS ON THE
| SAME LINE.  ^A NEW PAGE IS BEGIN, TITLES AND SUBTITLES ARE
| CLEARED, A <.FIG 12 IS DONE, FOLLOWED BY THE WORD <CHAPTER
| CENTERED, A <.B, FOLLOWED BY THE TITLE CENTERED.  ^PAGE NUMBERING
| IS NOT AFFECTED.  ^IF <.ATITLE IS ON, THE CHAPTER TITLE IS
| SET AS THE <.TITLE FOR SUCCEEDING PAGES.
|  <.CR .RT (^RETURN)
| .B ^CAUSES A CARRIAGE RETURN, WHICH IS A <.BR FOLLOWED BY
| SPACING MINUS ONE BLANK LINES.
| .B ^NOTE THAT <.CR IS IMPLIED BEFORE ANY COMMAND FOR WHICH
| (^RETURN) IS INDICATED.
|  <.DEBUG1
| .B ^CAUSES ALL FOLLOWING LINES TO BE PREFIXED WITH THE RELATIVE
| LINE NUMBER OF THE PAGE. ^THIS PRECEDES THE CARRIAGE CONTROL, IF ANY.
| <.DEBUG1 ALSO INCLUDES <.DEBUG2. <.NODEBUG1 IS THE DEFAULT. ^THIS
| IS USEFUL FOR FINDING PROBLEMS WHEN CREATING A DOCUMENT WITH MANY PAGE EJECTS.
|  <.DEBUG2
| .B ^CAUSES ALL FOLLOWING LINES TO BE TRAILED BY THE INPUT LINE NUMBER ON THE
| EXTREME RIGHT MARGIN (NOT NECESARILY THE MARGIN SET BY <.RM). ^THIS IS
| VERY USEFUL FOR DOCUMENT PREPARATION, TO CORRELATE A PROBLEM TO THE INPUT LINE
| CAUSING IT. <.NODEBUG2 IS THE DEFAULT.
|  <.DEC VARIABLENAME
| .B ^DECREMENT THE VARIABLENAME.
|  <.DELMAC MACRONAME
| .B ^DELETES THE MACRO NAME, SO THAT IT MAY BE REUSED.
|  <.DOT
| .B ^CAUSES ALL FOLLOWING <.T OR <.RT COMMANDS TO FILL WITH DOTS (PERIODS)
| INSTEAD OF SPACES.  ^A BLANK IS ALWAYS LEFT BEFORE AND AFTER
| THE STRING OF DOTS.
| <.NODOTS RETURNS TO FILLING TABS WITH SPACES.
|  <.EB
| .B ^END CHANGE BARS.  ^THE LAST LINE FLAGGED IS THE ONE WHICH
| CONTAINS THE WORD JUST PRECEDING THE <.EB COMMAND.
|  <.ELIST
| .B ^END LIST.  ^TERMINATES THE INNERMOST ACTIVE LIST.  ^SEE
| THE <.LIST COMMAND.
|  <.ESC
| .B ^ENABLES THE ESCAPE CHARACTER __ (BACKARROW OR UNDERLINE).
| ^WHEN ENABLED, THE ESCAPE CHARACTER CAUSES THE CHARACTER WHICH
| FOLLOWS IT TO BE COPIED TO THE OUTPUT TEXT WITHOUT SPECIAL
| ACTION. ^FOR EXAMPLE, 23__. CAUSES 23_. TO BE TYPED WITHOUT
| AN EXTRA TRAILING BLANK.  ^THE DEFAULT IS <.ESC.
|  <.F
| .B ^FILLS EACH OUTPUT LINE WITH AS MANY WORDS FROM THE INPUT
| AS POSSIBLE WITHOUT EXCEEDING THE RIGHT MARGIN.
| ^BLANKS ARE REMOVED FROM THE INPUT.  ^EACH WORD OF THE OUTPUT
| IS FOLLOWED BY AT LEAST ONE BLANK, WHILE WORDS WHICH END IN
| _., _!, OR _? ARE FOLLOWED BY AT LEAST TWO BLANKS.
| <.NOF SUPPRESSES FILL.
|  <.FIG N
| .B ^RESERVES N LINES FOR A FIGURE.  ^IF THE LINES WILL FIT ON THE
| CURRENT PAGE, <.FIG CAUSES A RETURN AND LEAVES N BLANK LINES.
| ^IF NOT, N BLANK LINES ARE LEFT AT THE BEGINNING OF THE NEXT
| PAGE.
|  <.FLAG
| .B ^CAUSES _^ AND _@ TO BE RECOGNIZED AS FLAG CHARACTERS.
| <.FLAG IS THE DEFAULT; <.NOFLAG SUPPRESSES RECOGNITION.
|  <.FLAGCAPS
| .B ^CAUSES THE _< CHARACTER TO INVERT THE CASE OF ANY LETTERS
| IN A WORD WHICH FOLLOW IT.  ^FOR EXAMPLE, <_<UP_<AND_<THEN_<DOWN
| IS OUTPUT AS <UP<AND<THEN<DOWN.
| <.NOFLAG SUPPRESSES SPECIAL ACTION FOR THE _< CHARACTER.
| <.FLAG IS THE DEFAULT.
|  <.FLAGOVER
| .B ^THE <.FLAGOVER COMMAND ENABLES RECOGNITION OF _\ (BACKSLASH)
| AS THE STRIKEOVER CHARACTER.  ^THE STRIKEOVER CHARACTER
| IS WRITTEN BETWEEN THE CHARACTER TO BE OVERSTRUCK AND THE CHARACTER
| WHICH IS TO OVERSTRIKE IT.  ^FOR EXAMPLE, <STRIKEO_\/VER IS
| OUTPUT AS <STRIKEO\/VER.
| .B ^UNDERLINING COUNTS AS ONE OVERSTRIKE.  ^ANY CHARACTER MAY BE
| OVERSTRUCK UP TO THREE TIMES.  ^OVERSTRIKING MAY BE USED ONLY
| WITHIN A WORD; THE OVERSTRIKE CHARACTER HAS NO MEANING BY ITSELF
| OR BEGINNING A WORD.
| .B <.FLAGOVER IS THE DEFAULT.  <.NOFLAGOVER TURNS IT OFF.
|  <.FLAGSIG
| .B ^THE <.FLAGSIG COMMAND ENABLES RECOGNITION OF _# (SHARP)
| AS THE SIGNIFICANT BLANK CHARACTER.  <.FLAGSIG IS THE DEFAULT.
| <.NOFLAGSIG TURNS IT OFF.
|  <.FRCPAGE
| .B ^THIS COMMAND IS USED INTERNALLY BY <RNF TO FORCE A PAGE
| EJECT.  ^THAT IS, IF A LINE IS ABOUT TO BE WRITTEN WHICH WOULD
| EXCEED THE PAGE SIZE, THE LINE IS SAVED, AND A <.FRCPAGE COMMAND
| IS EXECUTED AS THOUGH IT HAD BEEN ENCOUNTERED IN THE INPUT
| TEXT.
|  .B ^THE <.FRCPAGE COMMAND ITSELF INVOKES THE EQUIVALENT OF
| <.TOP, PRINTS THE NEXT PAGE HEADER, AND INVOKES THE EQUIVALENT
| OF <.MID.
| .B ^THE USER MAY ADD A FOOTER OR REFORMAT THE PAGE HEADER BY
| DEFINING A MACRO WITH THE NAME <.FRCPAGE.  ^THIS REPLACES THE
| <.FRCPAGE COMMAND, AND MUST INVOKE THE <.TOP AND <.MID COMMANDS
| (AND OPTIONALLY THE <.BOT COMMAND) EXPLICITLY.  ^FOR CORRECT
| OPERATION, THE .U FIRST .NOU WORD IN THE <.FRCPAGE MACRO MUST
| BE EITHER <.BOT OR <.TOP, AND THE LAST WORD SHOULD BE <.MID.
| .B ^NOTE THAT <.FRCPAGE DOES NOT RETURN, NOR CAN IT, SINCE A
| RETURN CAN CAUSE A PAGE EJECT, WHICH WILL CAUSE A <.FRCPAGE
| TO BE INVOKED RECURSIVELY.
| ^THE <.PAGE COMMAND DOES RETURN, AND IN FACT IS DEFINED AS
| <.BR <.FRCPAGE.
|  <.FMT N1 N2
| .B ^FORMATS THE VALUE OF N2 ACCORDING TO THE FORMAT CODE SPECIFIED
| BY N1.  ^N1 AND N2 MAY BE EXPRESSIONS (SEE ^CHAPTER 4).  ^N1 MUST
| BE IN THE RANGE 0 THROUGH 5, AND HAS A MEANING AS FOLLOWS:
| .SAV .LM +11 .TAB 20 .P -7 1 5
| .B
| .I -11 .U ^VALUE .T ^FORMATS#N2#AS... .NOU
|  0 .T ^ARABIC NUMBERS.  ^THAT IS, <.FMT 0 IS A NO-OP EXCEPT
| THAT IT FORCES OUTPUT OF N2.
|  1 .T ^UPPER CASE ALPHABETIC CHARACTERS, WHERE N2=1 PRODUCES
| THE CHARACTER <A, N2=2 PRODUCES <B, ETC.  (^NOTE THAT IN FACT
| N2=N PRODUCES THE NTH CHARACTER IN THE ALPHABET, WHERE
| N IS TAKEN MODULO 26.)
|  2 .T ^LOWER CASE ALPHABETIC CHARACTERS, WHERE N2=1 PRODUCES
| THE CHARACTER A, ETC.  (^THE ACTION IS THE SAME AS THAT OF FORMAT
| EXCEPT THAT THE CHARACTER IS LOWER CASE.)
|  3 .T ^UPPER CASE ^ROMAN NUMERALS.  (^THE NUMERALS PRODUCED
| ONLY MAKE USE OF THE CHARACTERS <M, <D, <C, <L, <X, <V, AND <I.)
|  4 .T ^LOWER CASE ^ROMAN NUMERALS.  (^THE NUMERALS PRODUCED
| ONLY MAKE USE OF THE CHARACTERS M, D, C, L, X, V, AND I.)
|  5 .T ^THE ^N2TH CHARACTER OF THE CHARACTER SET. ^THIS IS USEFUL FOR PRINTING
| CHARACTERS NOT AVAILABLE ON THE ENTRY DEVICE.
| .RES
|  <.HL N HEADING .RT (^RETURN)
| .B ^BEGINS A NEW SECTION WITH THE HEADING SPECIFIED AND AUTOMATICALLY
| NUMBERS IT.  ^THE N IN THE <.HL COMMAND MUST BE IN THE RANGE 1 THROUGH
| 5. ^SECTION NUMBERS HAVE THE FORM I.J.K.L.M.
| ^IF A <.CH COMMAND PRECEEDED THE <.HL COMMAND, I IS THE CHAPTER NUMBER;
| OTHERWISE IT IS THE NUMBER OF <.HL 1 COMMANDS.
| ^WITHIN ^CHAPTER 2, THE SEQUENCE <.HL#1, <.HL#2, <.HL#3, <.HL#3, <.HL#2,
| <.HL#1 PRODUCES SECTIONS NUMBERED 2.1, 2.1.1, 2.1.1.1, 2.1.1.2, 2.1.2,
| AND 2.2.
| .B ^THREE BLANK LINES ARE LEFT BEFORE EACH SECTION, AND TWO BLANK
| LINES FOLLOW THE SECTION HEADER.
|  <.I #N .RT (^RETURN)
| .BR .I -4 <.I +N .RT (^RETURN)
| .BR .I -4 <.I -N .RT (^RETURN)
| .B ^INDENT THE FOLLOWING LINE.  ^IF N IS SPEC^IFIED, IT INDICATES THE
| COLUMN NUMBER AT WHICH THE LINE IS TO BEGIN.  ^IF +N OR -N ARE SPECIFIED,
| THE INDENT IS PLUS OR MINUS N CHARACTERS FROM THE LEFT MARGIN.
|  <.IF EXPRESSION TEXT
| .B ^THE <.IF COMMAND TESTS THE VALUE OF THE EXPRESSION. ^IF IT
| IS ZERO, THE TEXT ON THE REMAINDER OF THE LINE IS SKIPPED; OTHERWISE
| THE TEXT IS SCANNED NORMALLY.  <.IF PROVIDES A SINGLE LINE CONDITIONAL
| CAPABILITY.
| .B ^FOR A DEFINITION OF EXPRESSIONS ACCEPTABLE TO <.IF, SEE
| ^CHAPTER 4, <VARIABLES.
|  <.INC VARIABLENAME
| .B INCREMENT THE FOLLOWING VARIABLE.
|  <.J
| .B ^JUSTIFY TEXT AT THE RIGHT MARGIN.  ^THIS IS THE DEFAULT.
| ^JUSTIFICATION IS ACCOMPLISHED BY INSERTING EXTRA BLANKS BETWEEN
| WORDS WHEN NECESSARY.  (^NOTE THAT A SIGNIFICANT BLANK, THE
| _# CHARACTER, IS NEVER EXPANDED.)# <.NOJ TURNS JUSTIFICATION OFF.
|  <.LE .RT (^RETURN)
| .B ^BEGINS A LIST ELEMENT.  ^THE ELEMENT IS AUTOMATICALLY NUMBERED
| AND INDENTED.  ^SEE THE <.LIST AND <.ELIST COMMANDS.
|  <.LINES N
| .B ^SETS THE NUMBER OF LINES IN THE OUTPUT PAGE,
| INCLUDING THE TOP AND BOTTOM MARGINS.  <DEFAULT N IS 66.  ^THE
| CORRECT SETTING FOR 6 LINE PER INCH DEVICES USING 8 LINE PER INCH
| PAPER (LIKE <CSO'S <DEC<WRITERS) IS 51.
|  <.LIST N .RT (^RETURN)
| .B ^BEGINS A LIST WITH N SPACING.  ^EACH ELEMENT OF THE LIST
| IS AUTOMATICALLY NUMBERED BEGINNING AT 1.  ^LISTS MAY BE NESTED
| WITHIN LISTS, FOR UP TO 5 LEVELS.  ^A LIST IS TERMINATED BY
| A <.ELIST COMMAND.  ^EACH LIST IS INDENTED ON THE RIGHT; THE
| OUTERMOST LIST IS INDENTED 9 CHARACTERS, AND EACH INNER LIST
| IS INDENTED 4 MORE.
|  <.LOWER .B ^FORMATS THE OUTPUT IN UPPER/LOWER CASE. ^LOWER IS THE DEFAULT.
|  <.LPT
| .B ^PREPARE OUTPUT FOR A LINE PRINTER, WITH CARRIAGE CONTROL IN
| THE FIRST CHARACTER POSITION OF EACH LINE.  ^THE DEFAULT IS <.LPT.
| <.NOLPT PREPARES OUTPUT FOR AN INTERACTIVE TERMINAL.
|  <.LM N
| .B ^SET THE LEFT MARGIN TO N.
| ^N MUST BE IN THE RANGE 1 THROUGH 136 (IN PARTICULAR, <.LM 0
| IS FLAGGED AS AN ERROR).
| ^SEE <.RM ALSO.
|  <.MACRO NAME ##= TEXT
| .BR .I -4 <.MACRO NAME N = TEXT
| .BR .I -4 <.MACRO NAME * = TEXT
| .B ^DEFINES A MACRO WITH THE NAME SPECIFIED EQUAL TO THE TEXT ON THE
| REMAINDER OF THE SAME LINE.  ^WHEN _.NAME IS ENCOUNTERED LATER, THE TEXT
| IS SUBSTITUTED FOR IT.
| .B ^IF N, AN INTEGER FROM 1 TO 7, IS SPECIFIED, IT INDICATES THE MACRO
| HAS N ARGUMENTS.  ^THIS IMPLICITLY DEFINES MACROS NAME1,NAME2...NAMEN,
| WHICH HAVE A TEXT VALUE EQUAL TO THE N WORDS WHICH FOLLOW THE MACRO WHEN
| IT IS INVOKED.
| .B ^IF * IS SPECIFIED, IT INDICATES THAT THE MACRO HAS ONE ARGUMENT.
| ^THE ARGUMENT IS THE IMPLICITLY DEFINED MACRO NAME1, AND HAS A TEXT
| VALUE EQUAL TO THE ENTIRE REST OF THE LINE ON WHICH THE MACRO IS
| INVOKED.
| .B ^FOR AN EXTENDED DISCUSSION AND EXAMPLES, SEE ^CHAPTER 3, <MACROS.
|  <.MID .RT (^RETURN)
| .B ^THE <.MID COMMAND ENDS A USER-DEFINED <.FRCPAGE MACRO.
| <.MID OUTPUTS ANY DEFERRED TEXT, FOLLOWED BY ANY LINES SAVED
| PRIOR TO <.FRCPAGE, THEN SETS THE BEGINNING OF USER TEXT
| TO THE CURRENT LINE.  ^THIS LATTER SUPPRESSES BLANK LINES
| AT THE "TOP OF THE PAGE" CAUSED BY EITHER <.S OR <.B.
|  <.NMP
| .B ^NUMBER PAGES.  ^THIS IS THE DEFAULT; <.NONMP TURNS IT OFF.
|  <.P #N S T
| .BR .I -4 <.P +N S T
| .BR .I -4 <.P -N S T
| .B ^SETS PARAGRAPHING CONVENTIONS.  ^N, S AND T ARE NUMBERS.
| ^N SETS THE PARAGRAPH INDENT AND WORKS LIKE THE <.I COMMAND.
| ^S SETS THE SPACING BETWEEN PARAGRAPHS, WHERE 1 IS SINGLE SPACED,
| IS DOUBLE SPACED, ETC.  ^T SETS AN AUTOMATIC <.TP T BEFORE
| EACH PARAGRAPH.  ^SEE ALSO THE <.PP AND <.AP COMMANDS.
|  <.PAGE .RT (^RETURN)
| .B ^BEGINS A NEW PAGE.
|  <.PERIOD
| .B ^LEAVE AN EXTRA BLANK AFTER _., _!, OR _?.  ^THIS IS THE DEFAULT.
| ^IT MAY BE SUPPRESSED BY <.NOPERIOD.
|  <.PNO N
| .B ^NUMBER THE NEXT PAGE N.
|  <.PP .RT  (^RETURN)
| .B ^BEGIN A NEW PARAGRAPH.
|  <.PS L R
| .B ^SETS THE PAGE SIZE TO L LINES OF TEXT, NOT COUNTING THE LINES
| AT THE TOP MARGIN, AND THE PAGE NUMBER RIGHT MARGIN TO R.
| ^SEE ALSO THE <.LINES COMMAND.
|  <.REM TEXT
| .B ^THE <.REM COMMAND AND ALL TEXT WHICH FOLLOWS IT ON THE SAME
| INPUT LINE IS TREATED AS A REMARK (COMMENT).  ^THE TEXT IS
| NOT COPIED TO THE OUTPUT.
|  <.RES .RT (^BREAK)
| .B ^RESTORES THE MARGINS, FILL AND JUSTIFY MODES, PARAGRAPH
| SETTINGS, SPACING, AND TAB STOPS TO THEIR STATE AS OF THE
| LAST <.SAV COMMAND.
|  <.RESPAG .RT (^RETURN)
| .B ^LIKE <.RES; REPLACES THE MARGINS, FILL AND JUSTIFY MODES,
| PARAGRAPH SETTINGS, SPACING, AND TAB STOPS TO THEIR STATE
| AS OF THE LAST <.SAVPAG COMMAND.  ^RESTORES THE PAGE ENVIRONMENT,
| WHICH IS USED TO ALIGN TITLES AND PAGE NUMBERS.
|  <.RIGHT N .RT (^RETURN)
| .B ^SHIFT OUTPUT TEXT RIGHT N SPACES.  THE <.RIGHT SPACES PRECEDE
| THOSE CAUSED BY THE <.BAR COMMAND.
|  <.RM N
| .B ^SETS THE RIGHT MARGIN TO COLUMN N.
|  <.RT
| .B ^RIGHT TAB.  ^CAUSES THE FOLLOWING WORD TO BE RIGHT JUSTIFIED
| (END IN) THE NEXT TAB STOP.  ^SEE THE <.TABS AND <.T COMMANDS.
| ^THIS IS USEFUL FOR TABLES OF NUMERIC DATA.
|  <.S .RT (^RETURN)
| .BR .I -4 <.S N .RT (^RETURN)
| .B ^LEAVE N+1 TIMES SPACING BLANK LINES, WHERE SPACING IS SET BY THE
| <.SP COMMAND.  <.S DOES NOTHING AT THE BEGINNING OF A PAGE.
| <.S AND <.S#1 ARE EQUIVALENT.
|  <.SAV
| .B ^SAVE THE CURRENT MARGINS, FILL AND JUSTIFY MODES, PARAGRAPH
| SETTINGS, SPACING, AND TAB STOPS -- WHICH ARE COLLECTIVELY
| CALLED THE "ENVIRONMENT".  ^THE ENVIRONMENT IS RESTORED BY
| THE <.RES COMMAND.  <.SAV AND <.RES CAN BE NESTED.
| .B ^FOR MOST TEXT, THERE ARE TWO ACTIVE ENVIRONMENTS: THE
| CURRENT VALUE AND THE "PAGE ENVIRONMENT".  ^THE LATTER CONTROLS
| THE PRINTING OF TITLES AND PAGE NUMBERS AT THE HEAD OF EACH
| PAGE.
| .B
| ^NOTE THAT <.HL, <.CH, OR <.RESPAG RESET THE ENVIRONMENT TO
| THE PAGE ENVIRONMENT AND DISCARD ANY ACTIVE <.SAV<S.  ^SEE THE
| <.SAVPAG AND <.RESPAG COMMANDS.
|  <.SAVPAG
| .B ^LIKE <.SAV, EXCEPT <.SAVPAG REPLACES THE PAGE ENVIRONMENT.
| ^IF NO EXPLICIT <.SAVPAG IS DONE, THE ENVIRONMENT AT THE
| FIRST <.HL OR <.CH COMMAND BECOMES THE PAGE ENVIRONMENT.
|  <.SIG
| .B ^TREAT SUCCESSIVE BLANK CHARACTERS AS WORDS, AND STOP ALL AUTOMATIC
| BLANK PLACEMENT.  ^USED IN CONJUNCTION WITH <.NOJ AND <.NOF, IT
| PERMITS A SORT OF "AS IS" MODE IN WHICH, HOWEVER, COMMANDS AND FLAGS
| ARE RECOGNIZED.
| <.NOSIG IS THE DEFAULT.
|  <.SP N
| .B ^SET THE SPACING BETWEEN LINES FORCED OUT BY FILLING TO N, WHERE
| IS SINGLE SPACING, 2 IS DOUBLE SPACING, ETC.
|  <.ST TEXT .RT (^RETURN)
| .B ^THE TEXT WHICH FOLLOWS THE <.ST COMMAND ON THE SAME LINE IS USED
| AS A SUBTITLE ON THE NEXT AND SUCCEEDING PAGES.
|  <.STD
| .B ^SETS <.F, <.FLAG, <.FLAGCAPS, <.NOASCII, <.ESC, <.PERIOD, <.J,
| <.UL, <.NOSIG, AND AUTOMATIC RETURNS BEFORE THE <.C, <.TITLE, <.ST,
| AND <.I COMMANDS.  <.SIG IS THE DEFAULT; <.NOSIG DOES THE OPPOSITE.
|  <.SUP
| .B ^SUPPRESSES (THROWS AWAY) ANY TEXT ALREADY IN THE CURRENT OUTPUT
| LINE, AND ANY TEXT ON THE SAME INPUT LINE AS THE <.SUP COMMAND.
|  <.T
| .B ^BEGIN THE NEXT WORD AT THE NEXT TAB STOP.  ^SEE ALSO THE <.TABS
| AND <.RT COMMANDS.
|  <.TABS T1 T2 _... T15
| .B ^SET UP TO 15 TAB STOPS IN COLUMNS T1, T2, ETC.  ^THE TAB STOPS
| MUST BE IN ASCENDING ORDER.  ^TABBING IS DONE BY THE <.T AND <.RT
| COMMANDS.
|  <.TITLE TEXT .RT (^RETURN)
| .B ^SETS THE TEXT WHICH FOLLOWS <.TITLE ON THE SAME LINE AS THE
| TITLE ON THE NEXT AND SUCCEEDING PAGES.
|  <.TOP
| .B ^SPACES TO THE TOP OF THE NEXT PAGE OR EMITS "1" CARRIAGE CONTROL.
| AND RESETS THE LINE COUNTER.
| .B <.TOP IS ONLY TO BE USED WHEN OVERRIDING THE DEFAULT PAGE
| HANDLING.  ^THE <.PAGE COMMAND IS USED FOR EJECTING A PAGE NORMALLY.
|  <.TP N .RT (^RETURN)
| .B ^TESTS WHETHER N LINES REMAIN ON THE CURRENT PAGE.  ^IF NOT,
| <.TP EJECTS A PAGE.  ^NOTE THAT <.TP IS AFFECTED BY SPACING
| IN THAT THE ACTUAL NUMBER OF LINES TESTED FOR IS N TIMES
| SPACING MINUS ONE.
|  <.U
| .B ^UNDERLINE THE NEXT AND SUCCEEDING WORDS IN THE OUTPUT TEXT.
| ^TERMINATED BY THE <.NOU COMMAND.
|  <.UPP
| .B ^FORCE THE NEXT WORD TO BE UPPER CASE.
|  <.UPPER .B ^FORCES THE OUTPUT INTO UPPER CASE ONLY. ^LOWER IS THE DEFAULT.
|  <.USB
| .B ^UNDERLINE SIGNIFICANT BLANKS (THAT IS _#) WHEN <.U IS EFFECTIVE.
| <.NOUSB CAUSES SIGNIFICANT BLANKS TO BE NOT UNDERLINED. <.USB IS THE DEFAULT.
|  <.VAR VARIABLENAME
| .B ^DECLARES A VARIABLE WITH THE NAME SPECIFIED.
| ^VARIABLE NAMES MUST BEGIN WITH A _$, AND OTHERWISE CONSIST OF
| LETTERS, NUMBERS, OR _$ CHARACTERS.  ^THE SECOND CHARACTER
| OF A VARIABLE NAME MAY NOT BE A DIGIT.  ^THE VARIABLE HAS THE
| INITIAL VALUE ZERO.
|  <.X
| .B ^EXTEND THE PRECEDING WORD ON THE OUTPUT LINE WITH THE FOLLOWING
| WORD.  ^WORDS JOINED BY <.X ARE OUTPUT ON THE SAME LINE WITH NO
| BLANKS BETWEEN THEM.  <.X IS PRIMARILY USEFUL FOR JOINING TEXT
| GENERATED BY A MACRO TO PUNCTUATION ON EITHER SIDE OF IT.
| .MACRO CHTTL = ^MACROS
| .CH <MACROS
| ^USER-DEFINED <RNF MACROS PROVIDE A MEANS OF:
| .BDOT
| .DOT ^EXTENDING THE SET OF <RNF COMMANDS BY ADDING MACROS TAILORED
| TO A SPECIFIC APPLICATION.
| .DOT ^ABBREVIATING COMMONLY USED SERIES OF <RNF COMMANDS.
| .DOT ^ABBREVIATING COMMONLY USED PHRASES OR LONG WORDS.
| .EDOT
| ^FOR EXAMPLE, THE FOLLOWING MACRO DEFINITIONS WERE USED TO PRODUCE
| THE DOTTED LIST ABOVE:
| .MACRO EX = .SAV .LM +9 .NOF .NOJ .S 1
| .MACRO EEX = .RES .S 1
| .EX <.MACRO <BDOT = <.SAV <.P -2 1 5 <.LM +5
| <.MACRO <DOT = <.PP __._# <.X
| <.MACRO <EDOT = <.RES <.S 1
| .EEX
| WHILE THE FOLLOWING TWO MACROS WERE USED TO FORMAT THE ABOVE
| (AND FOLLOWING) EXAMPLES:
| .EX <.MACRO <EX = <.SAV <.LM +9 <.NOF <.NOJ <.S 1
| <.MACRO <EEX = <.RES <.S 1
| .EEX
| AND SO ON!
|  ^THE FOLLOWING DISCUSSION IS INTENDED TO GIVE THE USER SOME
| INSIGHT INTO POTENTIAL USES OF MACROS WHILE
| DEMONSTRATING HOW EASY MACROS ARE TO DEFINE AND USE.
| .HL 1 <WHAT <MACROS <ARE
|  ^MACROS HAVE TWO PARTS: A NAME, AND SOME TEXT.  ^THE NAME IS
| A SINGLE WORD LONG, WHILE THE TEXT MAY BE ZERO OR MORE WORDS LONG.
|  ^THE EFFECT OF A MACRO IS SIMILIARLY EASY TO DESCRIBE: WHEREVER
| THE NAME OF THE MACRO APPEARS <RNF REMOVES IT AND SUBSTITUTES
| THE TEXT.
|  ^FOR EXAMPLE, IF THE FOLLOWING MACRO IS DEFINED:
| .EX <.MACRO <CDC = ^CONTROL ^DATA ^CORPORATION
| .EEX
| WHENEVER <.CDC APPEARS IN THE INPUT, <RNF REMOVES IT AND SUBSTITUTES
| ^CONTROL ^DATA ^CORPORATION.
| .MACRO NOTE * = .SAV .S 2 .LM +15 .RM -15 .P +0 1 5 .C .NOTE1 .S 1
| .MACRO ENOTE = .RES .S 2
| .NOTE ^NOTE THE ^DOTS
| ^THE MACRO NAME IS DEFINED WITHOUT A PRECEDING PERIOD (DOT).
| ^BUT WHEN THE MACRO IS USED, THE NAME MUST BE PRECEDED BY A DOT.
| .ENOTE
| .HL 1 <HOW <TO <DEFINE <A <MACRO
|  ^THE SIMPLEST FORM OF MACRO DEFINITION IS:
| .EX <.MACRO NAME = TEXT
| .EEX
| WHERE NAME IS THE NAME OF THE MACRO, AND TEXT REPRESENTS ALL THE
| TEXT ON THE REST OF THE SAME LINE.
|  ^AFTER THE MACRO DEFINITION, WHEREVER _.NAME APPEARS <RNF REMOVES
| IT AND SUBSTITUTES THE TEXT.
| .HL 1 <SUB-MACROS
|  ^ALL MACRO EXPANSIONS ARE CONSIDERED TO TAKE PLACE ON THE SAME INPUT
| LINE AS THE "OUTERMOST" MACRO CALL.  ^THUS, MACROS CAN BE PARAMETERIZED
| IN A SIMPLE WAY BY ENDING A MACRO EXPANSION WITH A COMMAND
| AND TYPING THE COMMAND ARGUMENT(S) AFTER THE MACRO CALL.  ^FOR EXAMPLE,
| .EX <.MACRO <RIGHTMARG = <.RM
| .EEX
| WHICH COULD BE USED BY
| .EX <.RIGHTMARG 65
| .EEX
| ^BUT, AS THE EXAMPLE SHOWS, THIS APPROACH IS MOSTLY LIMITED TO TRIVIAL
| COMMAND REPLACEMENTS.
| ^SUB-MACROS PROVIDE THE ABILITY TO PARAMETERIZE MACROS IN A MORE USEFUL
| FASHION.
| .HL 2 ^DEFINING ^PARAMETERIZED ^MACROS
|  ^MACROS WITH SUB-MACROS ARE DEFINED BY THE FORMATS:
| .EX <.MACRO NAME N = TEXT
| -OR-
| <.MACRO NAME * = TEXT
| .EEX
| ^THE N IN THE FORMAT STANDS FOR A NUMBER IN THE RANGE 1 THROUGH 7.
| ^IT MEANS THAT THE 1 THROUGH 7 WORDS FOLLOWING THE MACRO CALL ON THE
| SAME LINE ARE DYNAMICALLY MADE THE VALUES OF THE SUB-MACROS NAME1,
| NAME2, _... ,NAME7.
|  ^SUB-MACROS HAVE A DEFINED VALUE ONLY WHEN THE MACRO IS BEING
| EXPANDED.
|  ^IF AN ASTERISK IS USED INSTEAD OF A NUMBER N, IT MEANS THAT ALL
| THE WORDS WHICH FOLLOW THE MACRO CALL ON THE SAME LINE ARE DYNAMICALLY
| MADE THE VALUE OF THE SUB-MACRO NAME1.
|  ^FOR EXAMPLE,
| .EX <.MACRO <Z 2 = ^I HOPE YOU ARE <.Z1 <.X ING <.Z2 <.X ! .EEX
| ^WHEN <.Z IS CALLED, THE SUB-MACROS <.Z1 AND <.Z2 ARE GIVEN
| VALUES EQUAL TO THE TWO WORDS WHICH FOLLOW <.Z ON THE SAME LINE.
| ^THUS, THE CALL
| .EX <.Z FOLLOW ME .EEX
| PRODUCES THE TEXT
| .EX ^I HOPE YOU ARE FOLLOWING ME! .EEX
| .HL 2 ^SUB-MACRO ^SEMANTICS
| ^SINCE THE PARAMETERS OF A MACRO ARE DEFINED AS MACROS THEMSELVES,
| THEY MAY BE USED IN ANY MACRO CALLED WHILE THE SUB-MACROS ARE
| DEFINED, AND NEED NOT BE "PASSED DOWN" FROM MACRO TO MACRO.
|  ^IF NO WORDS OR NOT ENOUGH WORDS FOLLOW THE CALL OF A MACRO
| WITH SUB-MACROS, THE SUB-MACROS ARE GIVEN NULL VALUES.  ^THAT
| IS, UNLESS THERE IS ACTUALLY A WORD CORRESPONDING TO A SUB-MACRO,
| IT EXPANDS TO NOTHING AT ALL.
| .MACRO CHTTL = ^VARIABLES
| .CH <VARIABLES
|  <RNF ALLOWS THE USER TO DEFINE AND USE NUMERIC VARIABLES.
| ^THESE ARE HANDY (AND ARE USED INTERNALLY) FOR KEEPING TRACK OF
| PAGE NUMBERS, CHAPTER NUMBERS, HEADER LEVELS, ETC.
| .HL 1 <VARIABLE <SYNTAX
|  ^VARIABLES ARE WORDS WHICH BEGIN WITH A DOLLAR SIGN ($),
| FOLLOWED BY FROM 1 TO 9 LETTERS, NUMBERS, OR _$ CHARACTERS.
| ^THE CASE OF VARIABLE NAMES IS NOT SIGNIFICANT, E.G., <$HILO AND <$<HILO
| ARE THE SAME VARIABLE.
|  ^THE FIRST CHARACTER AFTER THE LEADING _$ CANNOT BE A NUMBER.
| ^THIS IS SO CHARACTER COMBINATIONS OF THE FORMS _$_<BLANK> AND
| _$_<NUMBERS> ARE NOT RECOGNIZED AS VARIABLES, MAKING A NUISANCE
| FOR THE USER.
|  ^USERS SHOULD NOT DECLARE VARIABLES WITH TWO LEADING DOLLAR
| SIGNS, AS THIS IS THE FORMAT USED BY PRE-DECLARED <RNF SYSTEM
| VARIABLES.
|  ^FOR EXAMPLE, THE FOLLOWING ARE VALID VARIABLE NAMES:
| .TP 8
| .EX <$A
|  <$VARIABLE
|  <$<N$
|  <$L23
| .EEX
| WHILE THE FOLLOWING ARE INVALID:
|  .EX <$100
|  <$
| .EEX
| .HL 1 <HOW <TO <DECLARE <VARIABLES
|  ^VARIABLES ARE DECLARED BY THE <.VAR COMMAND, WHICH HAS THE FORMAT:
| .EX <.VAR _$NAME
| .EEX
| ^NOTE THAT THE VARIABLE NAME IS BOTH DECLARED AND USED WITH A
| LEADING _$.
|  ^THE EFFECT OF <.VAR IS TO ALLOCATE SPACE FOR A NUMERIC VARIABLE,
| GIVE IT THE NAME SPECIFIED, AND INITIALIZE THE VARIABLE TO ZERO.
|  <RNF PROVIDES 75 SPACES FOR USER-DEFINED VARIABLES IN ADDITION
| TO PREDEFINED VARIABLES.
| .HL 1 <PREDEFINED <VARIABLES
|  ^AS A CONVENIENCE TO THE USER, ^RNF MAKES USE OF SEVERAL PREDEFINED
| VARIABLES WHILE PERFORMING VARIOUS COMMANDS.  ^THE PREDEFINED
| VARIABLES ARE:
| .SAV .LM +17 .P -12 0 1 .TAB 18
| .B
|  <$$PAGE .T ^CURRENT PAGE NUMBER.
|  <$$CH .T ^CURRENT CHAPTER NUMBER.
|  <$$HL .T ^CURRENT HEADER LEVEL.  ^ALSO DEFINED ARE <$$HL[1] THROUGH
| <$$HL[5], WHICH CONTAIN THE CURRENT COUNTS AT EACH LEVEL.
|  <$$LIST .T ^CURRENT LIST LEVEL.  ^ALSO DEFINED ARE <$$LIST[1]
| THROUGH <$$LIST[10], WHICH CONTAIN THE CURRENT COUNTS AT EACH
| LEVEL.
|  <$$LM .T ^CURRENT LEFT MARGIN, SET BY <.LM.
|  <$$RM .T ^CURRENT RIGHT MARGIN, SET BY <.RM.
|  <$$SP .T ^CURRENT SPACING, SET BY <.SP.
|  <$$NMP .T ^PAGE NUMBERING FLAG, SET BY <.NMP.
| .RES
|  ^THE VALUES OF THE PREDEFINED VARIABLES MAY BE EXAMINED OR
| CHANGED BY THE USER AT ANY TIME. (^OF COURSE, CHANGING THESE
| VALUES WILL AFFECT THE OPERATION OF THE BUILT IN <RNF FEATURES
| WHICH USE THEM.)
| .HL 1 <VARIABLE <ARRAYS
|  ^ARRAYS MAY BE DECLARED BY THE <.ARRAY COMMAND, WHICH HAS THE
| FORMAT:
| .EX <.ARRAY _$NAME N .EEX
| ^THE EFFECT OF THIS DECLARATION IS THAT _$NAME IS DECLARED TO
| BE AN N+1 ELEMENT ARRAY, WHICH MAY BE REFERENCED AS _$NAME[0]
| THROUGH _$NAME[N].
|  ^THE SUBSCRIPT MAY BE OMITTED IF THE ZEROETH ELEMENT OF THE
| ARRAY IS BEING REFERENCED.  ^THAT IS, _$NAME[0] AND _$NAME
| ARE EQUIVALENT.  ^THIS CONVENTION IS ADOPTED SO THAT A SINGLE
| DECLARATION CAN ALLOCATE BOTH AN N-ELEMENT ARRAY AND AN
| INDEX VARIABLE ASSOCIATED WITH THE ARRAY.
| (^THE PREDECLARED ARRAYS <$$HL AND <$$LIST ARE USED IN THIS FASHION.)
|  ^NOTE THAT THE ARRAY DECLARATION REQUIRES N+1 SPACES OF THE
| ALLOWED FOR USER VARIABLES.
| .HL 1 <EXPRESSIONS
|  ^AN EXTREMELY USEFUL FEATURE OF <RNF IS THE ABILITY TO COMBINE
| VARIABLES, NUMBERS, AND OPERATORS INTO EXPRESSIONS WHICH COMPUTE
| A NUMERIC VALUE.
| ^THE VALUES COMPUTED BY THE EXPRESSIONS CAN IN TURN INDEX ARRAYS,
| BE ASSIGNED TO VARIABLES, OR BECOME A PART OF THE OUTPUT TEXT.
| .HL 2 ^EXPRESSION ^SYNTAX
|  ^AN EXPRESSION IS DEFINED AS FOLLOWS:
| .TAB 20 27
| .EX EXPR .T ::= .T TERM _< RELOP TERM >
| .NOPERIOD
|  RELOP .T ::= .T <.EQ. × <.NE. × <.LT. × <.LE. × <.GT. × <.GE.
| .PERIOD
|  TERM .T ::= .T ITEM _< _< + × - > ITEM >...
|  ITEM .T ::= .T _< + × - × _# > ELEMENT
|  ELEMENT .T ::= .T ( TERM) × VAR × INTEGER
|  VAR .T ::= .T _$ID _< [ TERM ] > _< = TERM >
| .EEX
|  ^THE ANGLE BRACKETS _< AND > IN THE SYNTAX EXPRESSIONS ENCLOSE
| OPTIONAL PARTS.  ^THE CONSTRUCTION
| .EX _< STUFF >...
| .EEX
|  INDICATES THAT STUFF IS ALLOWED TO APPEAR ZERO OR MORE TIMES.
| ^NOTE THAT ANGLE BRACKETS ARE USED TO DESCRIBE EXPRESSIONS; THEY
| DO NOT APPEAR IN EXPRESSIONS.
|  ^THE _# CHARACTER IN AN EXPRESSION REPRESENTS A LOGICAL <NOT
| OPERATION.  ^THE EXPRESSION _#X HAS THE VALUE 1 IF X EQUALS
| , OTHERWISE IT HAS THE VALUE 0.
|  ^THE BLANKS IN THE SYNTAX EXPRESSIONS ARE NOT SIGNIFICANT AND IN FACT
| BLANKS ARE NOT PERMITTED IN EXPRESSIONS.  ^THAT IS, AND EXPRESSION MUST
| BE A SINGLE WORD.
|  ^SOME EXAMPLES OF VALID EXPRESSIONS ARE:
| .EX <$A.GR.5
|  <$HL[$HL+1]=0
|  <2+$$PAGE
|  <$X[$X=$X+1]=$X[$X]+1
|  <$A=$B=$C
| .EEX
| .HL 2 ^EXPRESSION ^EVALUATION
|  ^EXPRESSIONS ARE EVALUATED FROM LEFT TO RIGHT, EXCEPT THAT
| ASSIGNMENTS (INDICATED BY THE = SIGN) AT THE SAME LEVEL ARE
| DONE FROM RIGHT TO LEFT.
|  ^IN THE EXAMPLES ABOVE, <$X[$X=$X+1]=$X[$X]+1 IS EQUIVALENT
| TO THE SERIES OF EXPRESSIONS <$X=$X+1 <$X[$X]=$X[$X]+1.
| (^RECALL THAT THE ZEROETH ELEMENT OF AN ARRAY CAN BE REFERENCED
| WITHOUT SUBSCRIPTS.)#  ^ON THE OTHER HAND, THE EXPRESSION
| <$A=$B=$C IS EQUIVALENT TO <$B=$C <$A=$B.
| .HL 2 ^WHERE ^EXPRESSIONS ^ARE ^USED
|  ^AN EXPRESSION CAN ALWAYS BE USED AS AN ARGUMENT TO A COMMAND
| WHICH REQUIRES A NUMERIC VALUE.
|  ^AN EXPRESSION CAN ALSO APPEAR IN TEXT.  <RNF DECIDES WHETHER
| TO EVALUATE AN EXPRESSION IN TEXT OR NOT BASED ON WHETHER THE
| FIRST CHARACTER IS A _$.  ^IF IT IS, <RNF EVALUATES THE EXPRESSION;
| OTHERWISE THE EXPRESSION IS TREATED LIKE ANY OTHER TEXT WORD.
|  ^FOR EXAMPLE, THE EXPRESSION <$A+2 WILL BE EVALUATED, WHILE
| <2+$A WILL NOT.
| ^IF <$A HAS THE VALUE 3, THE FORMER WILL APPEAR IN THE OUTPUT
| AS "5", WHILE THE LATTER WILL APPEAR AS <"2+$A".
|  ^FOR THE FEW CASES WHEN IT IS NOT CONVENIENT TO BEGIN AN EXPRESSION
| TO BE EVALUATED WITH A VARIABLE NAME, THE SYNTAX:
| .EX <$(<EXPR)
| .EEX
| WILL CAUSE EXPR TO BE EVALUATED.
| .HL 2 ^SUPPRESSED ^EXPRESSIONS
|  ^FREQUENTLY, ONE WISHES TO COMPUTE A VALUE AND ASSIGN IT TO
| A VARIABLE -- THAT IS, EVALUATE AN EXPRESSION -- WITHOUT
| PLACING ANYTHING AT ALL IN THE OUTPUT TEXT.  ^THIS IS DONE
| BY TERMINATING THE EXPRESSION WITH A SEMICOLON.
|  ^FOR EXAMPLE, THE WORDS:
| .EX
| .EX <.VAR <$A ^SEE <$A=$A+1; ONLY <$A OF THESE.
| .EEX
| ARE OUTPUT AS
| .EX ^SEE ONLY 1 OF THESE.
| .EEX
| .PAGE
| .FIG 20
| .C .U ^THIS PAGE INTENTIONALLY LEFT BLANK. .NOU
| .MACRO CHTTL = ^EXAMPLES
| .CH <EXAMPLES
|  ^THIS CHAPTER CONTAINS A NUMBER OF SHORT EXAMPLES DEMONSTRATING
| VARIOUS FREQUENTLY USED <RNF FEATURES.
|  ^THE EXAMPLES ARE INTENDED TO BE SELF-EXPLANATORY AND ARE PRESENTED
| WITHOUT ACCOMPANYING TEXT.
| ^ALL BUT ONE OF THE EXAMPLES WAS PREPARED IN <NORMAL MODE (<RNF DEFAULT
| INPUT).
| .PAGE
| .HL 1 <INPUT <TEXT <EXAMPLE
| .ASIS
| .C <RNO
| .C ^INPUT ^TEXT
| 
| ^INPUT TEXT TO <RNO CONSISTS OF A SEQUENCE OF WORDS AND COMMANDS
| SEPARATED BY BLANKS.  ^A COMMAND IS ANY WORD WHICH BEGINS WITH
| A PERIOD FOLLOWED BY A NON-DIGIT, WHILE A WORD IS ANY
| SEQUENCE OF CHARACTERS WHICH
| DOES NOT CONTAIN A BLANK.  ^THE FOLLOWING ARE CONSIDERED WORDS:
| 
| .I 5 ^THIS
| .BR .I 5 .^B
| .BR .I 5 ^W^O^RD#^W^I^T^H#^S^I^G^N^I^F^I^C^A^N^T#^B^L^
| .BR .I 5 .234
| .B ^OF THE ABOVE WORDS, ONLY .^B IS A COMMAND.
| .B <RNO GATHERS WORDS INTO LINES.  ^BY DEFAULT, THE FIRST WORD IN
| A LINE BEGINS AT THE LEFT MARGIN, AND THE LAST WORD ENDS AT
| OR BEFORE THE RIGHT MARGIN.  ^THAT IS, LINES ARE LEFT JUSTIFIED.
| 
| ^IN THE OUTPUT,
| AT LEAST ONE BLANK APPEARS BETWEEN WORDS; TWO BLANKS FOLLOW A
| PERIOD OR QUESTION MARK WHICH END A WORD.
| !.PAGE
| .C <RNO
| .C ^INPUT ^TEXT
| 
| ^INPUT TEXT TO <RNO CONSISTS OF A SEQUENCE OF WORDS AND COMMANDS
| SEPARATED BY BLANKS.  ^A COMMAND IS ANY WORD WHICH BEGINS WITH
| A PERIOD FOLLOWED BY A NON-DIGIT, WHILE A WORD IS ANY
| SEQUENCE OF CHARACTERS WHICH
| DOES NOT CONTAIN A BLANK.  ^THE FOLLOWING ARE CONSIDERED WORDS:
| 
| .I 5 ^THIS
| .BR .I 5 _.^B
| .BR .I 5 ^W^O^R^D_#^W^I^T^H_#^S^I^G^N^I^F^I^C^A^N^T_#^B^L^A^N^K^S
| .BR .I 5 .234
| .B ^OF THE ABOVE WORDS, ONLY _.^B IS A COMMAND.
| .B <RNO GATHERS WORDS INTO LINES.  ^BY DEFAULT, THE FIRST WORD IN
| A LINE BEGINS AT THE LEFT MARGIN, AND THE LAST WORD ENDS AT
| OR BEFORE THE RIGHT MARGIN.  ^THAT IS, LINES ARE LEFT JUSTIFIED.
| 
| ^IN THE OUTPUT,
| AT LEAST ONE BLANK APPEARS BETWEEN WORDS; TWO BLANKS FOLLOW A
| PERIOD OR QUESTION MARK WHICH END A WORD.
| .PAGE
| .HL 1 <PARAGRAPHING
| .ASIS
| .C ^PARAGRAPHING
| .P +5 1 5
| .PP ^THE PARAGRAPHING FACILITY IN <RNO ENABLES FAST, CONVENIENT
| TEXT ENTRY IN A NATURAL FORMAT.
| .PP ^PARAGRAPHING IS SET UP BY THE .<P COMMAND, WHICH HAS THE
| FORMAT:
| .B .I 9 .<P INDENT SPACING TEST
| .PP ^INDENT IS THE COLUMN AT WHICH THE FIRST LINE OF EACH
| PARAGRAPH IS TO BEGIN, SPECIFIED EITHER AS AN UNSIGNED COLUMN
| NUMBER OR AS A POSITIVE OR NEGATIVE OFFSET FROM THE CURRENT
| LEFT MARGIN.  ^SPACING SPECIFIES THE NUMBER OF SPACES BETWEEN
| PARAGRAPHS, WHERE 1 IS THE EQUIVALENT OF A <.S 1 COMMAND,
| IS THE EQUIVALENT OF A <.S2 COMMAND, ETC.  ^TEST
| SPECIFIES THE NUMBER OF LINES WHICH
| MUST REMAIN ON THE CURRENT PAGE, OR THE PARAGRAPH IS BEGUN
| ON THE NEXT PAGE.
| .PP ^THE DEFAULT IS:
| .B .I 9 .<P +0 1 3
| .PP ^THE .<PP COMMAND DENOTES THE BEGINNING OF A NEW PARAGRAPH.
| .AP
|  ^AS AN ALTERNATIVE (OR IN ADDITION) TO THE <.PP COMMAND, THE USER
| CAN SELECT AUTOPARAGRAPH MODE BY MEANS OF THE <.AP COMMAND.
| ^IF <.AP IS IN EFFECT, A BLANK AT THE BEGINNING OF ANY LINE
| (OR A BLANK LINE)
| IS TAKEN TO BE A <.PP COMMAND.
| 
| (^NOTE THAT A BLANK LINE IN <.NOAP MODE IS TAKEN TO BE A <.B
| COMMAND.)
| 
| ^THE AUTOPARAGRAPH CONVENTIONS ALLOW A TYPIST TO ENTER AND WORK
| WITH ALL TEXT IN A READABLE FORMAT WHICH IS CONVENIENT FOR
| COMPUTER EDITING (FOR EXAMPLE, SINGLE SPACED WITH SINGLE CHARACTER
| INDENTS), YET PRODUCE THE DRAFT AND FINAL COPIES OF WORK
| IN WHATEVER STYLE IS REQUIRED.
| !.PAGE
| .C ^PARAGRAPHING
| .P +5 1 5
| .PP ^THE PARAGRAPHING FACILITY IN <RNO ENABLES FAST, CONVENIENT
| TEXT ENTRY IN A NATURAL FORMAT.
| .PP ^PARAGRAPHING IS SET UP BY THE _.<P COMMAND, WHICH HAS THE
| FORMAT:
| .B .I 9 _.<P INDENT SPACING TEST
| .PP ^INDENT IS THE COLUMN AT WHICH THE FIRST LINE OF EACH
| PARAGRAPH IS TO BEGIN, SPECIFIED EITHER AS AN UNSIGNED COLUMN
| NUMBER OR AS A POSITIVE OR NEGATIVE OFFSET FROM THE CURRENT
| LEFT MARGIN.  ^SPACING SPECIFIES THE NUMBER OF SPACES BETWEEN
| PARAGRAPHS, WHERE 1 IS THE EQUIVALENT OF A <.S 1 COMMAND,
| IS THE EQUIVALENT OF A <.S2 COMMAND, ETC.  ^TEST
| SPECIFIES THE NUMBER OF LINES WHICH
| MUST REMAIN ON THE CURRENT PAGE, OR THE PARAGRAPH IS BEGUN
| ON THE NEXT PAGE.
| .PP ^THE DEFAULT IS:
| .B .I 9 _.<P +0 1 3
| .PP ^THE _.<PP COMMAND DENOTES THE BEGINNING OF A NEW PARAGRAPH.
| .AP
|  ^AS AN ALTERNATIVE (OR IN ADDITION) TO THE _.<PP COMMAND, THE USER
| CAN SELECT AUTOPARAGRAPH MODE BY MEANS OF THE _.<AP COMMAND.
| ^IF _.<AP IS IN EFFECT, A BLANK AT THE BEGINNING OF ANY LINE
| (OR A BLANK LINE)
| IS TAKEN TO BE A _.<PP COMMAND.
| 
| (^NOTE THAT A BLANK LINE IN _.<NOAP MODE IS TAKEN TO BE A _.<B
| COMMAND.)
| 
| ^THE AUTOPARAGRAPH CONVENTIONS ALLOW A TYPIST TO ENTER AND WORK
| WITH ALL TEXT IN A READABLE FORMAT WHICH IS CONVENIENT FOR
| COMPUTER EDITING (FOR EXAMPLE, SINGLE SPACED WITH SINGLE CHARACTER
| INDENTS), YET PRODUCE THE DRAFT AND FINAL COPIES OF WORK
| IN WHATEVER STYLE IS REQUIRED.
| .PAGE
| .HL 1 <HEADER <LEVEL <EXAMPLES
| .ASIS
| .AP
| .HL 2 <HOW <TO <USE <HEADER <LEVELS
|  ^THE .<HL COMMAND ENABLES THE TYPIST TO ORGANIZE TEXT INTO
| SECTIONS, AND SECTIONS WITHIN SECTIONS, WITH SEQUENTIAL NUMBERS
| WHICH ARE CHANGED BY THE COMPUTER IF SECTIONS ARE ADDED OR
| DELETED.
| .HL 3 ^FORMAT
|  ^THE FORMAT OF THE .<HL COMMAND IS:
| .S 1 .I 9 .<HL NUMBER TEXT
|  ^THE NUMBER IS THE LEVEL NUMBER, WHERE 1 IS THE OUTERMOST
| LEVEL, 2 IS THE NEXT INNER LEVEL, ETC.  ^THE TEXT IS THE
| TITLE OF THE SECTION.
| .HL 3 ^EFFECT OF THE ^COMMAND
|  ^THE .<HL COMMAND STARTS A SECTION AT THE LEVEL SPECIFIED AND
| USES TEXT AS THE HEADER.  ^THE NUMBER CAN BE IN THE RANGE
| FROM 1 TO 5. ^THE SECTION NUMBER OUTPUT IS IN THE FORM
| I.J.K.L.M.  ^IF THE DOCUMENT IS CHAPTER ORIENTED, I IS THE
| CHAPTER NUMBER; OTHERWISE IT IS THE NUMBER OF .<HL 1 COMMANDS
| SINCE THE BEGINNING OF THE INPUT TEXT.
|  ^THE COMMAND DOES A RETURN, A TEST PAGE 9, AND PRECEDES THE
| SECTION IDENTIFIER WITH 3 BLANK LINES.
| ^THE MARGINS AND OTHER ENVIRONMENT ARE RESET TO THE VALUES
| THEY HAD BEFORE THE FIRST .<HL COMMAND (IN THE CHAPTER).
| ^THE SECTION NUMBER BEGINS AT THE LEFT MARGIN, FOLLOWED
| BY TWO SPACES, FOLLOWED BY THE TEXT, IF ANY.
|  ^A SINGLE BLANK LINE IS INSERTED AFTER THE HEADER.
| .HL 2 <INCREMENTING
|  ^SECTION NUMBERS ARE INCREMENTED BY 1 AT THE LEVEL OF THE
| CURRENT .<HL COMMAND.
|  ^EACH TIME LEVELS ARE NESTED (FOR EXAMPLE, .<HL 1 FOLLOWED
| BY .<HL 2), THE NUMBERING IS RESTARTED AT 1 FOR THE HIGHER
| NUMBERED LEVEL.
| !.PAGE
| .AP
| .HL 2 <HOW <TO <USE <HEADER <LEVELS
|  ^THE _.<HL COMMAND ENABLES THE TYPIST TO ORGANIZE TEXT INTO
| SECTIONS, AND SECTIONS WITHIN SECTIONS, WITH SEQUENTIAL NUMBERS
| WHICH ARE CHANGED BY THE COMPUTER IF SECTIONS ARE ADDED OR
| DELETED.
| .HL 3 ^FORMAT
|  ^THE FORMAT OF THE _.<HL COMMAND IS:
| .S 1 .I 9 _.<HL NUMBER TEXT
|  ^THE NUMBER IS THE LEVEL NUMBER, WHERE 1 IS THE OUTERMOST
| LEVEL, 2 IS THE NEXT INNER LEVEL, ETC.  ^THE TEXT IS THE
| TITLE OF THE SECTION.
| .HL 3 ^EFFECT OF THE ^COMMAND
|  ^THE _.<HL COMMAND STARTS A SECTION AT THE LEVEL SPECIFIED AND
| USES TEXT AS THE HEADER.  ^THE NUMBER CAN BE IN THE RANGE
| FROM 1 TO 5. ^THE SECTION NUMBER OUTPUT IS IN THE FORM
| I.J.K.L.M.  ^IF THE DOCUMENT IS CHAPTER ORIENTED, I IS THE
| CHAPTER NUMBER; OTHERWISE IT IS THE NUMBER OF _.<HL 1 COMMANDS
| SINCE THE BEGINNING OF THE INPUT TEXT.
|  ^THE COMMAND DOES A RETURN, A TEST PAGE 9, AND PRECEDES THE
| SECTION IDENTIFIER WITH 3 BLANK LINES.
| ^THE MARGINS AND OTHER ENVIRONMENT ARE RESET TO THE VALUES
| THEY HAD BEFORE THE FIRST _.<HL COMMAND (IN THE CHAPTER).
| ^THE SECTION NUMBER BEGINS AT THE LEFT MARGIN, FOLLOWED
| BY TWO SPACES, FOLLOWED BY THE TEXT, IF ANY.
|  ^A SINGLE BLANK LINE IS INSERTED AFTER THE HEADER.
| .HL 2 <INCREMENTING
|  ^SECTION NUMBERS ARE INCREMENTED BY 1 AT THE LEVEL OF THE
| CURRENT _.<HL COMMAND.
|  ^EACH TIME LEVELS ARE NESTED (FOR EXAMPLE, _.<HL 1 FOLLOWED
| BY _.<HL 2), THE NUMBERING IS RESTARTED AT 1 FOR THE HIGHER
| NUMBERED LEVEL.
| .PAGE
| .HL 1 <EXAMPLES OF <LISTS
| .ASIS
| .C ^USING ^LISTS
| .AP
|  ^AUTOMATICALLY NUMBERED LISTS CAN BE GENERATED BY THE <.LIST,
| <.LE, AND <.ELIST COMMANDS.  ^THE <.LIST COMMAND HAS THE FORMAT:
|  .I 9 <.LIST SPACING
|  WHERE SPACING IS A NUMBER IN THE RANGE 1 THROUGH 5 WHICH
| SPECIFIES THE SPACING TO BE USED WITHIN THE LIST.
|  ^THE LIST IS GENERATED AS FOLLOWS:
| .LIST 1
| .LE ^EACH LIST ELEMENT IS PRECEDED BY THE <.LE COMMAND.
| .LE ^LIST ELEMENTS ARE SEPARATED BY "SPACING" BLANK LINES.
| .LE ^EACH ELEMENT IS AUTOMATICALLY NUMBERED BEGINNING AT
| BY 1.
| .LE ^THE LIST IS TERMINATED BY THE <.ELIST COMMAND (WHICH
| ALSO RESETS THE MARGINS AND SPACING).
| .LE ^LISTS CAN BE NESTED WITHIN LISTS.  ^THIS IS HANDLED
| AS FOLLOWS:
| .LIST 1
| .LE ^THE LEFT MARGIN IS SET 9 COLUMNS TO THE RIGHT FOR
| THE OUTERMOST LIST, AND 4 COLUMNS TO THE RIGHT FOR EACH
| INNER LIST.
| .LE ^EACH <.LIST MUST BE TERMINATED BY A MATCHING <.ELIST.
| ^THE <.ELIST RESETS THE MARGINS AND SPACING AS THEY WERE
| BEFORE THE <.LIST COMMAND.
| .LE ^FOR USERS OF AUTOPARAGRAPHING, THE PARAGRAPH MARGIN
| IS SET TO COINCIDE WITH THE LEFT MARGIN, AND PARAGRAPH
| SPACING IS SET TO THE LIST SPACING PLUS 1.
|  ^THIS MEANS THAT AUTOPARAGRAPHING CAN BE CONVENIENTLY
| USED AT ANY LIST LEVEL.
|  ^THE PARAGRAPH VALUES ARE RESET BY THE <.ELIST COMMAND.
| .ELIST
| .LE ^LISTS CAN BE NESTED UP TO 5 LEVELS.
| .ELIST
|  ^THE LIST FACILITY CAN BE A SIGNIFICANT CONVENIENCE FOR
| THE TYPIST.
| !.PAGE
| .C ^USING ^LISTS
| .AP
|  ^AUTOMATICALLY NUMBERED LISTS CAN BE GENERATED BY THE <.LIST,
| <.LE, AND <.ELIST COMMANDS.  ^THE <.LIST COMMAND HAS THE FORMAT:
|  .I 9 <.LIST SPACING
|  WHERE SPACING IS A NUMBER IN THE RANGE 1 THROUGH 5 WHICH
| SPECIFIES THE SPACING TO BE USED WITHIN THE LIST.
|  ^THE LIST IS GENERATED AS FOLLOWS:
| .LIST 1
| .LE ^EACH LIST ELEMENT IS PRECEDED BY THE <.LE COMMAND.
| .LE ^LIST ELEMENTS ARE SEPARATED BY "SPACING" BLANK LINES.
| .LE ^EACH ELEMENT IS AUTOMATICALLY NUMBERED BEGINNING AT
| BY 1.
| .LE ^THE LIST IS TERMINATED BY THE <.ELIST COMMAND (WHICH
| ALSO RESETS THE MARGINS AND SPACING).
| .LE ^LISTS CAN BE NESTED WITHIN LISTS.  ^THIS IS HANDLED
| AS FOLLOWS:
| .LIST 1
| .LE ^THE LEFT MARGIN IS SET 9 COLUMNS TO THE RIGHT FOR
| THE OUTERMOST LIST, AND 4 COLUMNS TO THE RIGHT FOR EACH
| INNER LIST.
| .LE ^EACH <.LIST MUST BE TERMINATED BY A MATCHING <.ELIST.
| ^THE <.ELIST RESETS THE MARGINS AND SPACING AS THEY WERE
| BEFORE THE <.LIST COMMAND.
| .LE ^FOR USERS OF AUTOPARAGRAPHING, THE PARAGRAPH MARGIN
| IS SET TO COINCIDE WITH THE LEFT MARGIN, AND PARAGRAPH
| SPACING IS SET TO THE LIST SPACING PLUS 1.
|  ^THIS MEANS THAT AUTOPARAGRAPHING CAN BE CONVENIENTLY
| USED AT ANY LIST LEVEL.
|  ^THE PARAGRAPH VALUES ARE RESET BY THE <.ELIST COMMAND.
| .ELIST
| .LE ^LISTS CAN BE NESTED UP TO 5 LEVELS.
| .ELIST
|  ^THE LIST FACILITY CAN BE A SIGNIFICANT CONVENIENCE FOR
| THE TYPIST.
| .PAGE
| .HL 1 <CHANGE <BAR <EXAMPLES
| .ASIS
| .BAR .AP
| .C ^USING ^CHANGE ^BARS
| .B
|  ^CHANGE BARS ARE USED TO FLAG TEXT WHICH HAS BEEN
| ALTERED SINCE THE LAST VERSION OF A DOCUMENT, AND ARE
| COMMONLY FOUND ONLY IN TECHNICAL WRITING,
| .BB WHERE THE READER MUST BE ALTERTED TO NEW FEATURES. .EB
|  ^THE <.BAR COMMAND ENABLES CHANGE BARS, AND HAS THE IMMEDIATE
| EFFECT OF SHIFTING ALL OUTPUT TEXT RIGHT
| .BB THREE .EB
| SPACES.
| ^THE <.NOBAR COMMAND DISABLES CHANGE BARS.  ^USUALLY, THE .BAR COMMAND
| APPEARS BEFORE ANY TEXT IN A DOCUMENT, SO THE LEFT MARGIN IN THE OUTPUT
| IS UNIFORM.
|  ^THE <.BB (^BEGIN ^BAR) COMMAND TURNS ON CHANGE BARS.  ^THAT IS,
| <.BB CAUSES A ! TO APPEAR AT THE LEFT MARGIN FOR ANY LINES WHICH
| ARE OUTPUT AFTER THE <.BB
| .BB (INCLUDING BLANK LINES WHICH ARE A PART OF THE TEXT). .EB
|  ^THE <.EB (^END ^BAR) COMMAND SIGNIFIES THE END OF THE CHANGE
| BEGUN BY <.BB, AND TURNS OFF CHANGE BARS.
|  .BB ^SPACES CAUSED BY THE <.RIGHT COMMAND APPEAR TO THE LEFT OF
| THE THREE EXTRA COLUMNS USED BY THE <.BAR FEATURE.
|  ^BLANK LINES WHICH APPEAR AS A PART OF CHANGED TEXT ARE
| ALSO FLAGGED BY A BAR.
| !.PAGE
| .BAR .AP
| .C ^USING ^CHANGE ^BARS
| .B
|  ^CHANGE BARS ARE USED TO FLAG TEXT WHICH HAS BEEN
| ALTERED SINCE THE LAST VERSION OF A DOCUMENT, AND ARE
| COMMONLY FOUND ONLY IN TECHNICAL WRITING,
| .BB WHERE THE READER MUST BE ALTERTED TO NEW FEATURES. .EB
|  ^THE <.BAR COMMAND ENABLES CHANGE BARS, AND HAS THE IMMEDIATE
| EFFECT OF SHIFTING ALL OUTPUT TEXT RIGHT
| .BB THREE .EB
| SPACES.
| ^THE <.NOBAR COMMAND DISABLES CHANGE BARS.  ^USUALLY, THE .BAR COMMAND
| APPEARS BEFORE ANY TEXT IN A DOCUMENT, SO THE LEFT MARGIN IN THE OUTPUT
| IS UNIFORM.
|  ^THE <.BB (^BEGIN ^BAR) COMMAND TURNS ON CHANGE BARS.  ^THAT IS,
| <.BB CAUSES A _! TO APPEAR AT THE LEFT MARGIN FOR ANY LINES WHICH
| ARE OUTPUT AFTER THE <.BB
| .BB (INCLUDING BLANK LINES WHICH ARE A PART OF THE TEXT). .EB
|  ^THE <.EB (^END ^BAR) COMMAND SIGNIFIES THE END OF THE CHANGE
| BEGUN BY <.BB, AND TURNS OFF CHANGE BARS.
|  .BB ^SPACES CAUSED BY THE <.RIGHT COMMAND APPEAR TO THE LEFT OF
| THE THREE EXTRA COLUMNS USED BY THE <.BAR FEATURE.
|  ^BLANK LINES WHICH APPEAR AS A PART OF CHANGED TEXT ARE
| ALSO FLAGGED BY A BAR.
| .BR .EB
| .EB
| .NOBAR .PAGE
| .HL 1 <TAB <EXAMPLES
| .ASIS
| .ASCII
| .c Using <rno Tabs
| .ap
|  <rno tab stops are set by the <.tabs command.  The format is:
|  .i 9 <.tabs c1 c2 <... c15
|  where c1 through c15 are character positions, in ascending order,
| where the tab stops are to be set.
| (Character positions are numbered beginning at 1). To work
| correctly, tab stops must not be set beyond the right margin.
|  Tabs are used by the <.t command, which means "begin the next
| word at the next tab stop".
|  For example, the following
|  .i 9 <.tabs 10 20 30 40
| .br .i 9 Line <.t this <.t up <.t in <.t columns
|  produces
| .tabs 19 29 39 49
|  .i 9 Line .t this .t up .t in .t columns
|  The following features should be noted:
| .tab 30 .p -21 2 5 .lm 30
|  Justification .t Having tabs in a line does not suppress
| justification.  Only the text after the last tab in a line is blank
| padded.  This permits convenient use of "hanging" titles and
| indentation.
|  Left/Right .t Tabs produced by <.t cause the following
| word to begin at the next tab stop.  The <.rt
| command causes the following word to end at the
| next tab stop.  This permits creating tables of numeric
| data.
| !.PAGE
| .C ^USING <RNO ^TABS
| .AP
|  <RNO TAB STOPS ARE SET BY THE <.TABS COMMAND.  ^THE FORMAT IS:
|  .I 9 <.TABS C1 C2 <... C15
|  WHERE C1 THROUGH C15 ARE CHARACTER POSITIONS, IN ASCENDING ORDER,
| WHERE THE TAB STOPS ARE TO BE SET.
| (^CHARACTER POSITIONS ARE NUMBERED BEGINNING AT 1). ^TO WORK
| CORRECTLY, TAB STOPS MUST NOT BE SET BEYOND THE RIGHT MARGIN.
|  ^TABS ARE USED BY THE <.T COMMAND, WHICH MEANS "BEGIN THE NEXT
| WORD AT THE NEXT TAB STOP".
|  ^FOR EXAMPLE, THE FOLLOWING
|  .I 9 <.TABS 10 20 30 40
| .BR .I 9 ^LINE <.T THIS <.T UP <.T IN <.T COLUMNS
|  PRODUCES
| .TABS 19 29 39 49
|  .I 9 ^LINE .T THIS .T UP .T IN .T COLUMNS
|  ^THE FOLLOWING FEATURES SHOULD BE NOTED:
| .TAB 30 .P -21 1 5 .LM 30
|  ^JUSTIFICATION .T ^HAVING TABS IN A LINE DOES NOT SUPPRESS
| JUSTIFICATION.  ^ONLY THE TEXT AFTER THE LAST TAB IN A LINE IS BLANK
| PADDED.  ^THIS PERMITS CONVENIENT USE OF "HANGING" TITLES AND
| INDENTATION.
|  ^LEFT/^RIGHT .T ^TABS PRODUCED BY <.T CAUSE THE FOLLOWING
| WORD TO BEGIN AT THE NEXT TAB STOP.  ^THE <.RT
| COMMAND CAUSES THE FOLLOWING WORD TO END AT THE
| NEXT TAB STOP.  ^THIS PERMITS CREATING TABLES OF NUMERIC
| DATA.
| .PAGE
| .HL 1 <MACRO <EXAMPLES
| .ASIS
| .MACRO BBCB 1 = .B .B .C .BBCB1 .B
| .MACRO NOTE * = .SAV .TP 8 .SP 1 .LM +15 .RM -15 .P +0 1 5 .BBCB .NOTE1
| .MACRO ENOTE = .B .B .RES
| .AP
| .C ^THE <NOTE ^COMMAND
|  ^THIS EXAMPLE SHOWS THE DEFINITION OF A USEFUL COMMAND VIA THE <.MACRO
| FACILITY.
| .NOTE ^WARNING
| ^THIS COMMAND CAN BE HABIT-FORMING.  ^USE IT SPARINGLY.
| .ENOTE
| ^TRY IT, YOU'LL LIKE IT!
| !.PAGE
| .MACRO BBCB 1 = .B .B .C .BBCB1 .B
| .MACRO NOTE * = .SAV .TP 8 .SP 1 .LM +15 .RM -15 .P +0 1 5 .BBCB .NOTE1
| .MACRO ENOTE = .B .B .RES
| .AP
| .C ^THE <NOTE ^COMMAND
|  ^THIS EXAMPLE SHOWS THE DEFINITION OF A USEFUL COMMAND VIA THE <.MACRO
| FACILITY.
| .NOTE ^WARNING
| ^THIS COMMAND CAN BE HABIT-FORMING.  ^USE IT SPARINGLY.
| .ENOTE
| ^TRY IT, YOU'LL LIKE IT!
| .MACRO CHTTL = ^HOW#^TO#^RUN#<RNF
| .CH <HOW <TO <RUN <RNF
| ^THIS IS IMPLEMENTATION DEPENDENT INFORMATION!
|  ^THE FOLLOWING JCL MAY BE USED TO RUN <RNF:    .NOF .NOJ .B
| <//RNF <EXEC <PGM=RUNOFF,REGION=90K,PARM='/IOBUF=16K',TIME=(2,00)
| <//OUTPUT  <DD <SYSOUT=(G,,0721),DCB=(LRECL=133,BLKSIZE=133,RECFM=FBA)
| <//QRR     <DD <SYSOUT=A,DCB=(LRECL=90,BLKSIZE=90,RECFM=FB)
| <//INPUT <DD *
| _ #RUNOFF TEXT
| _/*       .F .J .B
|  <NOTES:
| .B ^IF YOU DO NOT WISH TO SEE THE INPUT PRINTED, SPECIFY <DUMMY, INSTEAD
| OF <SYSOUT=A ON THE <QRR <DD CARD.
| .B ^ADJUST <REGION=90K IF <BLKSIZE PARAMETERS ARE TOO LARGE, BUT THIS
| SHOULD BE SUFFICIENT FOR THE NORMAL CASE.
| .B ^BE SURE TO SPECIFY THE PROPER <OUTPUT <DD SYSOUT CLASS AND FORM.
| .B ^BE SURE TO SPECIFY THE CORRECT LIBRARY IN THE <//STEPLIB OR <//JOBLIB
| <DD CARD.
| .REM
| .REM      TABLE OF CONTENTS
| .REM
| .TAB 25 .PS 55 72 .LM +5 .RM -5
| .MACRO FRCPAGE = .TCA .TOP .B 10 .U .TCB .B 2 .TCC .NOU .B .MID
| .MACRO TCA =
| .MACRO TCB = .C <TABLE <OF <CONTENTS .TCBA .BR
| .MACRO TCBA =
| .MACRO TCC = ^SECTION .T ^TITLE AND ^PAGE .BR
| .PAGE
| $$PAGE=0;
| .MACRO TCA = .BOT .B 5 .C .FMT 4 $$PAGE=$$PAGE+1 .BR
| .MACRO TCBA = (^CONTINUED)
| .B 2 .NOF .NOJ
| .T <CHAPTER 1 -- <INTRODUCTION ##1
| .1 .T #<FEATURES #1
| .2 .T #<INPUT <TEXT #2
| .2.1 .T #<NORMAL ^INPUT #2
| .2.2 .T #<ASCII ^INPUT #2
| .3 .T #<WORDS #3
| .4 .T #<LINES #3
| .5 .T #<SPACING #4
| .6 .T #<PARAGRAPHS #4
| .7 .T #<PAGES #5
| .7.1 .T #^EXPLICIT ^PAGING ^CONTROL #5
| .7.2 .T #^PAGE ^FORMAT #5
| .B
| .TP 3 2 .T <CHAPTER 2 -- <COMMANDS ##7
| .T #<.AP #7
| .T #<.ARRAY #7
| .T #<.ASCII #8
| .T #<.ASIS #8
| .T #<.ATITLE #8
| .T #<.AUTOCAP #8
| .T #<.B #8
| .T #<.BAR #9
| .T #<.BB #9
| .T #<.BOT #9
| .T #<.BR #9
| .T #<.C #9
| .T #<.CH #9
| .T #<.CR #10
| .T #<.DEBUG1  #10
| .T #<.DEBUG2 #10
| .T #<.DEC #10
| .T #<.DELMAC #10
| .T #<.DOT #10
| .T #<.EB #10
| .T #<.ELIST #10
| .T #<.ESC #11
| .T #<.F #11
| .T #<.FIG #11
| .T #<.FLAG #11
| .T #<.FLAGCAPS #11
| .T #<.FLAGOVER #11
| .T #<.FLAGSIG #12
| .T #<.FRCPAGE #12
| .T #<.FMT #12
| .T #<.HL #13
| .T #<.I #13
| .T #<.IF #13
| .T #<.INC #13
| .T #<.J #14
| .T #<.LE #14
| .T #<.LINES #14
| .T #<.LIST #14
| .T #<.LPT #14
| .T #<.LM #14
| .T #<.LOWER #14
| .T #<.MACRO #14
| .T #<.MID #15
| .T #<.NMP #15
| .T #<.P #15
| .T #<.PAGE #15
| .T #<.PERIOD #15
| .T #<.PNO #16
| .T #<.PP #16
| .T #<.PS #16
| .T #<.REM #16
| .T #<.RES #16
| .T #<.RESPAG #16
| .T #<.RIGHT #16
| .T #<.RM #16
| .T #<.RT #17
| .T #<.S #17
| .T #<.SAV #17
| .T #<.SAVPAG #17
| .T #<.SIG #17
| .T #<.SP #17
| .T #<.ST #18
| .T #<.STD #18
| .T #<.SUP #18
| .T #<.T #18
| .T #<.TABS #18
| .T #<.TITLE #18
| .T #<.TOP #18
| .T #<.TP #18
| .T #<.U #19
| .T #<.UPP #19
| .T #<.UPPER #19
| .T #<.USB #19
| .T #<.VAR #19
| .T #<.X #19
| .B .TP 3 3 .T <CHAPTER 3 -- <MACROS ##21
| .1 .T #<WHAT <MACROS <ARE #21
| .2 .T #<HOW <TO <DEFINE <A <MACRO #22
| .3 .T #<SUB-MACROS #22
| .3.1 .T #^DEFINING ^PARAMETERIZED ^MACROS #23
| .3.2 .T #^SUB-MACRO ^SEMANTICS #23
| .B .TP 3 4 .T <CHAPTER 4 -- <VARIABLES ##24
| .1 .T #<VARIABLE <SYNTAX #24
| .2 .T #<HOW <TO <DECLARE <VARIABLES #25
| .3 .T #<PREDEFINED <VARIABLES #25
| .4 .T #<VARIABLE <ARRAYS #25
| .5 .T #<EXPRESSIONS #26
| .5.1 .T #^EXPRESSION ^SYNTAX #26
| .5.2 .T #^EXPRESSION ^EVALUATION #27
| .5.3 .T #^WHERE ^EXPRESSIONS ^ARE ^USED #27
| .5.4 .T #^SUPPRESSED ^EXPRESSIONS #28
| .B .TP 3 5 .T <CHAPTER 5 -- <EXAMPLES ##30
| .1 .T #<INPUT <TEXT <EXAMPLE #31
| .2 .T #<PARAGRAPHING #33
| .3 .T #<HEADER <LEVEL <EXAMPLES #35
| .4 .T #<EXAMPLES <OF <LISTS #37
| .5 .T #<CHANGE <BAR <EXAMPLES #39
| .6 .T #<TAB <EXAMPLES #41
| .7 .T #<MACRO <EXAMPLES #43
| .B .TP 3 6 .T <CHAPTER 6 -- <HOW <TO <RUN <RNF ##45
| .MACRO FRCPAGE = .TCA
| .PAGE
> Member SNAPSHOT
| (*$D-,X+*)
| (*******************************************************************
| *
| *             SNAPSHOT AND POST MORTEM DUMP UTILITY
| *
| *     THIS PROGRAM PRINTS OUT THE CURRENT STACK ENVIRONMENT FOR A
| *     PASCAL PROGRAM RUNNING ON THE S.L.A.C. TRIPLEX SYSTEM (IBM 370)
| *     SNAPSHOT TRACES BACK THROUGH THE STACK FRAMES OF THE PROGRAM
| *     AND FOR EACH STACK FRAME PRINTS 1) THE NAME OF THE PROCEDURE
| *     WHICH 'OWNS' THAT FRAME, 2) THE NAME OF THE PROCEDURE WHICH
| *     CALLED THE OWNING PROCEDURE AND THE SOURCE LINE NUMBER FROM
| *     WHICH THE CALL WAS MADE, 3) THE VALUES OF THE PROCEDURE'S
| *     PARAMETERS AND LOCAL VARIABLES.
| *
| *     THIS PROGRAM IS CLOSELY AWARE OF THE RUN-TIME ENVIRONMENT OF
| *     'PASCAL' PROGRAMS AND USES 'CASE VARIANT' RECORDS TO INTERPRET
| *     THE CONTENTS OF MEMORY LOCATIONS DIFFERENTLY AS NEEDED. FOR
| *     THIS REASON, IT SHOULD NOT BE COMPILED WITH THE 'D+' OPTION.
| *
| *  AUTHOR:  EARL WALDIN
| *
| *           COMPUTATION RESEARCH GROUP
| *           STANFORD LINEAR ACCELERATOR CENTER
| *           STANFORD, CA. 94305
| *
| *
| *                                          UPDATED: 12-05-78  (SZH)
| *                                          UPDATED: 08-09-79  (SZH)
| *
| *
| ******************************************************************)
| 
| 
| PROGRAM DUMP(QRD,OUTPUT);
| 
| 
| 
| PROCEDURE SNAPSHOT(LEVEL,DMPKIND:INTEGER);
| 
| 
|    (* VALUES FOR DMPKIND WHEN CALLED BY A USER PROCEDURE ARE:
| 
|       0 - FULL LISTING EXCEPT THAT FOR ARRAYS, ONLY THE FIRST
|            AND LAST FEW  ENTRIES ARE PRINTED. (DEFAULT ON ABEND)
| 
|       1 - TRACE OF PROCEDURE CALLS ONLY (NO VARIABLES).
| 
|      10 - FULL LISTING INCLUDING ALL ENTRIES IN ARRAYS.
| 
|    -----------------------------------------------------------*)
| 
| 
|    CONST
|       HALFW = 65536;   (*2EXP16*)
|       ADDRC = 16777216;    (*2EXP24*)
|       PROCSIZE = 8192;
|       VARLN = 8;
|       PNAMLN = 12;
|       BYL_INT  = 4;  MAL_INT  = 4;
|       BYL_PTR  = 4;  MAL_PTR  = 4;
|       BYL_REAL = 8;  MAL_REAL = 8;
|       BYL_BOOL = 1;  MAL_BOOL = 1;
|       BYL_CHAR = 1;  MAL_CHAR = 1;
|       BYL_SET  = 8;  MAL_SET  = 4;
|       IBFLN    = 300;
|       DEFLEV   = 20;  (* DEFAULT MAX LEVEL OF STACK TO TRACE *)
| #     ARRLMT   = 3 ;  (* Default # of array elements printed *)
| #     STRLMT   = 140; (* LIMIT ON STRING (ARRAY OF CHAR) SIZE *)
|       UNDFINT  = -2122219135 ;    (* HEX '81818181' *)
|       UNDFBYTE = 129 ;            (* HEX '81'       *)
| 
|    TYPE
| 
|       ABNDP = @ABNDAREA;
| 
|       ABNDAREA = RECORD
|                   ABCODE:INTEGER;
|                   ABADDR:INTEGER;
|                   ABSPC1:INTEGER;
|                   ABLOWR:INTEGER;
|                   ABUPPR:INTEGER;
|                   ABCVAL:INTEGER;
| #                 ABEMSG:@ MSGTYPE;
|                   ABMSGL: 1..100;
|                   ABREGS: ARRAY[5..12] OF INTEGER;
|                END;
| 
|       MSGTYPE = ARRAY[1..100] OF CHAR;
| 
|       FUNCC = RECORD CASE INTEGER OF
|                1:(C:(FULL,STKTRACE));
|                2:(P:ABNDP);
|                3:(I:INTEGER);
|             END;
| 
|       MXSET  = SET OF 0..63 ;
|       PROCNAME = ARRAY(/1..PNAMLN/) OF CHAR;
| 
|       PROC_PTR = @PROC_HEAD;    PROCTPTR = @PROC_TAIL;
|       FRM_PTR = @STK_FRM;
|       STK_FRM = RECORD
|            CASE INTEGER OF
| 
|                   (* STACK FRAME MARK AREA *)
|               1:(SPC1:INTEGER;
|                  BAK_LNK:FRM_PTR;
|                  FOR_LNK:FRM_PTR;
|                  RET:INTEGER;
|                  EPA:PROC_PTR;
|                  GPR0_12:ARRAY(/0..12/) OF INTEGER;
|                  SPC2,SPC3:INTEGER;
|                  FPRS:ARRAY(/1..4/) OF REAL);
| 
|                   (* STACK FRAME VARIABLE OVERLAYS *)
|               2:(CASE INTEGER OF
|                     1:(INT_VA:ARRAY(/0..10000/) OF INTEGER);
|                     2:(BOOL_VA:ARRAY(/0..10000/) OF BOOLEAN);
|                     3:(CHR_VA:ARRAY(/0..10000/) OF CHAR);
|                     4:(REAL_VA:ARRAY(/0..10000/) OF REAL);
|                     5:(SETE:ARRAY(/0..10000/) OF MXSET);
|                     6:(SPCI:INTEGER;
|                            SETO:ARRAY(/0..10000/) OF MXSET) );
| 
|                   (* GLOBAL STACK AREA *)
|               3:(SPCB:ARRAY(/1..18/) OF INTEGER;
|                   CURNTNP:INTEGER;
|                   ENDNP0:INTEGER)
|            END;
| 
|       PROC_HEAD  = RECORD
|             SPC1:INTEGER;
|             SPNAME:ARRAY(/0..5/) OF CHAR;
|             PROCLN:ARRAY(/0..1/) OF CHAR;
|             END;
| 
|       PROC_TAIL = RECORD
|             PROCID:ARRAY(/0..1/) OF CHAR;
|             SLINNO:ARRAY(/0..1/) OF CHAR;
|             FPNAME:ARRAY(/1..PNAMLN/) OF CHAR;
|             LINARY:ARRAY(/1..100000/) OF CHAR;
|             END;
| 
|       VARTYPE = (INT,RL,BOL,CHA,PTR,REC,PSET,ARY,SCL,FIL,UNK);
| 
| 
|    VAR
|       DMARRAY:ARRAY(/0..1/) OF FRM_PTR;
|       VARTARY:ARRAY(/0..40/) OF VARTYPE;
|       DEPTH,MAXDEPTH,I,J,UID,PLEN:INTEGER;
|       CH:CHAR ;
|       DONE: BOOLEAN ;
|       TOPSTK,BOTSTK,TMPSTK:FRM_PTR;
|       CPROCN:PROCNAME;
|       IBF:ARRAY(/1..IBFLN/) OF CHAR;
|       PAR2:FUNCC;
|       ARRYLSTF:BOOLEAN;
| 
| 
|    PROCEDURE $WRADDR(X:INTEGER);
| 
|       VAR   Z0,Z9,ZA:INTEGER; H:ARRAY(/1..6/) OF CHAR;
| 
|       BEGIN
|       Z0 := ORD('0');  Z9 := ORD('9');  ZA := ORD('A');
|        IF (BOTSTK@.CURNTNP <= X) AND (X <= BOTSTK@.ENDNP0)
|          THEN BEGIN
|             I := 6;
| #              REPEAT
| #              J := X MOD 16 ;  X := X DIV 16;
| #              IF J >= 10 THEN   H(/I/) := CHR(ZA+(J-10))
| #              ELSE  H(/I/) := CHR(Z0+J) ;
| #              I := I-1 ;
| #              UNTIL I = 0;
| #
| #           WRITE(OUTPUT, H, 'H') ;
| 
|             END
| 
|          ELSE IF X=-1 THEN WRITE(OUTPUT, 'NIL')
|             ELSE WRITE(OUTPUT, 'UNDEF. (pointer)');
| 
|       END; (*WRADDR*)
| 
| 
| #  FUNCTION $IDLEN(NAME : PROCNAME): INTEGER ;
| #     VAR I : INTEGER ;
| #
| #     BEGIN  I := 0 ;
| #
| #     REPEAT I := I+1 UNTIL  (NAME(/I/) = ' ') OR ( I >= PNAMLN) ;
| #
| #     $IDLEN := I-1 ;
| #     END ;
| 
| 
|    PROCEDURE $GETPNAME(P:PROC_PTR; VAR PID,LEN:INTEGER;
|                        VAR NAME:PROCNAME);
| 
|       VAR
|         TP:RECORD  CASE INTEGER OF
|            1:(I:INTEGER);
|            2:(P:PROCTPTR)
|            END;
|         I:INTEGER;
| 
|       BEGIN
|       LEN := ORD(P@.PROCLN(/0/))*256 + ORD(P@.PROCLN(/1/));
|      "FOR I := 1 TO PNAMLN DO NAME(/I/) := ' ';"
|       NAME := '            ' ;
|       PID := 0;
| 
|       IF (LEN = 0) OR (LEN > PROCSIZE)
|          THEN FOR I := 1 TO 7 DO
|             NAME(/I/) := P@.SPNAME(/I/)
| 
|          ELSE BEGIN
|          TP.I := ORD(P) + LEN;
|          FOR I := 1 TO PNAMLN DO
|             NAME(/I/) := TP.P@.FPNAME(/I/);
|          PID := ORD(TP.P@.PROCID(/0/))*256 + ORD(TP.P@.PROCID(/1/));
|          END;
|       END;  (* $GETPNAME *)
| 
| 
| 
| 
|    PROCEDURE $PRNTVAR(STKP:FRM_PTR; PNAME:PROCNAME; PID:INTEGER);
| 
|       CONST   INDENT6=6;
| 
|       TYPE   CMPCODE = (PROCESS, SUCC, TYPERR, IDERR, SYNERR,
|                         NUMERR, EOFERR, BUFERR, ADDERR);
| 
|          CNTRL = (YES,NO);
| 
|       VAR
| #        MAXI,I,VADDR,ALNFCT: INTEGER;  TPROCN: PROCNAME;  ERR: CMPCODE;
|          INDRCT:BOOLEAN;
| 
|          SB:RECORD CASE INTEGER OF
|                1:(I:INTEGER);
|                2:(P:FRM_PTR)
|                END;
| 
| #
| #     PROCEDURE $ALIGN(VAR OFFSET: INTEGER; ALN: INTEGER);
| #
| #        (* $ALIGNS POSITIVE 'OFFSET' ON AN 'ALN' BYTE BOUNDARY *)
| #
| #        BEGIN
| #        OFFSET := ((OFFSET+ALN-1) DIV ALN)*ALN;
| #        END (*ALIGN*);
| #
|       PROCEDURE $ERRMSG(ECODE:CMPCODE; INDX:INTEGER);
| 
|          VAR   J,K:INTEGER;
| 
|          BEGIN
|          WRITELN(OUTPUT) ;
|          WRITE(OUTPUT, '0    ****  ERROR IN SYMBOL TABLE  ****');
|          CASE ECODE OF
|             TYPERR:  WRITELN(OUTPUT, '    ILLEGAL TYPE.');
|             IDERR:   WRITELN(OUTPUT, '    ILLEGAL IDENTIFIER.');
|             SYNERR:  WRITELN(OUTPUT, '    SYNTAX ERROR.');
|             NUMERR:  WRITELN(OUTPUT, '    IMPROPER NUMBER.');
|             EOFERR:  WRITELN(OUTPUT, '    PREMATURE END OF FILE.');
|             BUFERR:  WRITELN(OUTPUT, '    INTERNAL BUFFER EXCEEDED.');
|             ADDERR:  WRITELN(OUTPUT, '    ADDRESS EXPECTED.');
|             END;
| 
|          J := 1;
|          WHILE J <= INDX DO BEGIN
|             WRITELN(OUTPUT);   WRITE(OUTPUT, ' ');
|             IF (INDX-J+1) < 80 THEN K := INDX-J+1 ELSE K := 80;
|             WHILE K > 0 DO BEGIN WRITE(OUTPUT, IBF(/J/)); J := J+1;
|                   K := K-1; END;
|             END;
|          WRITELN(OUTPUT);
|          END;  (* $ERRMSG *)
| 
| 
|       FUNCTION $TRANSVAR(CH:CHAR):VARTYPE;
| 
|          VAR  I:INTEGER;
| 
|          BEGIN
|          I := ORD(CH) - ORD('A');
|          IF (0 <= I) AND (I <= (ORD('Z')-ORD('A')))
|             THEN $TRANSVAR := VARTARY(/I/)
|             ELSE $TRANSVAR := UNK;
|          END;  (* $TRANSVAR *)
| 
| 
| 
|       PROCEDURE $PRNT(INDNT:INTEGER; VAR INDX,OFFSET:INTEGER;
| #                       BASE:FRM_PTR; IDREQ(*,LIST*):CNTRL);
| 
| #        VAR   M,L,K,J,I,SAVALN:INTEGER;
|                ubnd, lmt, lmt2, lmt3, lmt4: integer;
| 
|                I_R_S :RECORD
|                         CASE INTEGER OF
|                         1: (R : REAL) ;
|                         2: (S : MXSET) ;
|                         3: (I1: INTEGER; I2: INTEGER) ;
|                       END;
| 
|                TBOL:BOOLEAN;   TCH:CHAR;
| 
|          FUNCTION $CNVTNUM(VAR J:INTEGER): INTEGER;
| 
|             VAR  ZERO,NUM:INTEGER;  SIGN:BOOLEAN;
| 
|             BEGIN
|             NUM := 0;  ZERO := ORD('0');  SIGN := TRUE;
|             WHILE IBF(/J/) = ' ' DO J := J+1;
|             IF IBF(/J/) = '-' THEN BEGIN SIGN := FALSE; J := J+1; END;
|             WHILE IBF(/J/) <> ' ' DO
|                BEGIN
|                NUM := 10*NUM + ORD(IBF(/J/)) - ZERO;
|                J := J+1;
|                END;
|             J := J+1;
|             IF SIGN THEN $CNVTNUM := NUM ELSE $CNVTNUM := -NUM;
|             END;
| 
| 
|          BEGIN
|          IF IDREQ=YES
|             THEN BEGIN   I := INDX ;
|             WHILE IBF(/INDX/) <> ' ' DO
|                BEGIN
|               "IF LIST=YES THEN"WRITE(OUTPUT, IBF(/INDX/));
|                INDX := INDX+1
|                END;
|             I := INDX-I ;
| #           IF (I > 0) "AND (LIST=YES)"  THEN
| #              IF I <= 6 THEN  WRITE(OUTPUT, ' ':6-I)
| #              ELSE  BEGIN  WRITE(OUTPUT, ' ':12-I); INDNT := INDNT+INDENT6 END;
|             INDX := INDX+1;
|             END;
| 
|          INDX := INDX+2;
| 
|          CASE $TRANSVAR(IBF(/INDX-2/)) OF
| 
|             INT,SCL:  BEGIN "  I := OFFSET + BYL_INT -1;
|                   OFFSET := I - (I MOD BYL_INT);"
| #                 $ALIGN(OFFSET, BYL_INT);  $ALIGN(ALNFCT, BYL_INT);
|                   I := BASE@.INT_VA(/OFFSET DIV BYL_INT/) ;
| #                "IF LIST=YES THEN"
|                      IF I = UNDFINT
|                              THEN WRITELN(OUTPUT, ' = UNDEF. (integer/scaler)' )
|                              ELSE  WRITELN(OUTPUT, ' = ', I:1);
|                   OFFSET := OFFSET + BYL_INT;
|                   END;
| 
|              RL:  BEGIN    "I := OFFSET + BYL_REAL -1;
|                   OFFSET := I - (I MOD BYL_REAL);"
| #                 $ALIGN(OFFSET, BYL_REAL);  $ALIGN(ALNFCT, BYL_REAL);
|                   I_R_S.R := BASE@.REAL_VA(/OFFSET DIV BYL_REAL/) ;
| #                "IF LIST=YES THEN"
|                      IF (I_R_S.I1 = UNDFINT) AND (I_R_S.I2 = UNDFINT)
|                             THEN WRITELN(OUTPUT, ' = UNDEF. (real)')
|                             ELSE  WRITELN(OUTPUT, ' =', I_R_S.R:10);
|                   OFFSET := OFFSET + BYL_REAL;
|                   END;
| 
|             CHA:  BEGIN     "IF LIST=YES THEN" WRITE(OUTPUT, ' = ''');
|                   (* LENGTH=1 --> NO ALIGNMENT HERE *)
|                   TCH := BASE@.CHR_VA(/OFFSET/);
| #                "IF LIST=YES THEN"
|                      IF (64 <= ORD(TCH)) AND (ORD(TCH) <= 250)
|                             THEN WRITELN(OUTPUT, TCH,'''')
|                             ELSE WRITELN(OUTPUT, '#''');
|                   OFFSET := OFFSET + BYL_CHAR;
|                   END;
| 
|             BOL:  BEGIN
|                   (* LENGTH=1 --> NO ALIGNMENT HERE *)
|                   TBOL := BASE@.BOOL_VA(/OFFSET/) ;
| 
|                   "IF LIST=YES THEN"
|                      IF ORD(TBOL) = UNDFBYTE
|                              THEN WRITELN(OUTPUT, ' = UNDEF. (boolean)')
|                              ELSE  IF TBOL THEN  WRITELN(OUTPUT, ' = TRUE')
|                                 ELSE  WRITELN(OUTPUT, ' = FALSE');
|                   OFFSET := OFFSET + BYL_BOOL;
|                   END;
| 
|             PTR:  BEGIN    "I := OFFSET + BYL_INT -1;
|                   OFFSET := I - (I MOD BYL_INT);"
| #                 $ALIGN(OFFSET, BYL_PTR);  $ALIGN(ALNFCT, BYL_PTR);
|                  "IF LIST=YES THEN"
|                      BEGIN
|                      WRITE(OUTPUT, ' = ');
|                      $WRADDR(BASE@.INT_VA(/ OFFSET DIV BYL_INT/));
|                      WRITELN(OUTPUT);
|                      END;
|                   OFFSET := OFFSET + BYL_INT;
|                   END;
| 
|            PSET:  BEGIN  "  I := OFFSET + MAL_SET -1;
|                   OFFSET := I - (I MOD MAL_SET);"
| #                 $ALIGN(OFFSET, MAL_SET);  $ALIGN(ALNFCT, MAL_SET);
|                   I := OFFSET DIV BYL_SET;
|                   M := OFFSET MOD BYL_SET;
|                   L := $CNVTNUM(INDX);    L := $CNVTNUM(INDX);
|                   J := 0;
| 
|                   IF M=0 THEN  I_R_S.S := BASE@.SETE(/I/)
|                      ELSE  I_R_S.S := BASE@.SETO(/I/);
| 
|                   "IF LIST=YES THEN"
|                      BEGIN
|    ##                WRITELN(OUTPUT, ' = (/0..', L:1, '/)');
|                      WRITE(OUTPUT, ' ':INDNT+INDENT6+3);
|                      IF (I_R_S.I1 = UNDFINT) AND (I_R_S.I2 = UNDFINT)
|                         THEN   WRITE(OUTPUT, ' UNDEF. (set)')
| 
|                         ELSE  REPEAT
|                         IF (J MOD 10) = 0 THEN  WRITE(OUTPUT, ' ');
|                         WRITE(OUTPUT, ORD(J IN I_R_S.S):1) ;
|                         J := J+1;
|                         UNTIL J > L ;
| 
| 
|                      WRITELN(OUTPUT);   WRITELN(OUTPUT);
|                      END;
| #                 OFFSET := OFFSET + BYL_SET;
|                   END;
| 
| #           REC:  BEGIN   "IF LIST=YES THEN" WRITELN(OUTPUT);
|                   INDNT := INDNT+INDENT6;
|                   WHILE IBF(/INDX/) <> ';' DO
|                      BEGIN
| #                   "IF LIST=YES THEN" WRITE(OUTPUT, ' ': INDNT+1);
| #                    $PRNT(INDNT,INDX,OFFSET,BASE,YES(*,LIST*));
|                      END;
|                   WRITELN(OUTPUT);
|                   END;
| 
|             ARY:  BEGIN   K := $CNVTNUM(INDX); M := $CNVTNUM(INDX);
|                   UBND := M-K;
| 
|                   IF ($TRANSVAR(IBF(/INDX/)) = CHA) AND (UBND <= STRLMT)
|                      THEN BEGIN
| 
| #                   "IF LIST=YES THEN"
|                         BEGIN  WRITE(OUTPUT, ' = ''');
|                         FOR I:=0 TO UBND DO
|                            BEGIN
|                            TCH := BASE@.CHR_VA(/OFFSET+I/);
|                            IF (64 <= ORD(TCH)) AND (ORD(TCH) <= 250) THEN
|                               WRITE(OUTPUT, TCH)
|                            ELSE  WRITE(OUTPUT, '#');
|                            END;
| 
|                         WRITELN(OUTPUT, '''');
|                         END ;
| 
|                      INDX := INDX + 2;
|                      OFFSET := OFFSET + BYL_CHAR*(1+UBND);
|                      END
| 
|                   ELSE BEGIN
|                      (* find the range of indices to be printed *)
| #                    lmt := arrlmt;
| #                    if (ubnd >= 500*arrlmt) or (ubnd <= 3*arrlmt) then
|                         lmt := arrlmt*2 ;
| #                       (* short arrays, print the whole thing,  *)
| #                       (* very long arrays, print more elements *)
| #                    lmt4 := ubnd-lmt;  lmt2 := lmt4 div 2;  lmt3 := lmt2+lmt+1;
|                     "IF LIST=YES THEN"  WRITELN(OUTPUT);
| #                    savaln := alnfct;  alnfct := BYL_CHAR;  (*=1*)
| 
|                      FOR i := 0 to ubnd DO
| 
|                         IF (i < lmt) OR ((lmt2 < i) and (i < lmt3)) OR
|                            (i > lmt4) OR arrylstf  THEN
|                            BEGIN
| #                          J := INDX;  l := offset;
| #                         "IF LIST=YES THEN"
| #                             WRITE(OUTPUT, ' ':INDNT, K+I:INDENT6, ']');
| #                          $PRNT(INDNT+"INDENT6"4,J,OFFSET,BASE,NO(*,LIST*));
| #                          $align(offset, alnfct);
| #                          l := offset-l;  (* length of array element *)
| #                          END
| 
|                         ELSE
|                            "IF (ARRLMT <= I) AND (I <= M-K-ARRLMT) THEN "
|                            BEGIN
|                            "IF LIST=YES THEN"
|                               IF (i = lmt) or (i = lmt3) THEN WRITELN(OUTPUT);
|                            J := INDX;
| #                          offset := offset+l;  (* skip over other elements *)
|                            (*PRNT(INDNT+4,J,OFFSET,BASE,NO,"no");*)
|                            END ;
| 
| 
|                      INDX := J-2;
| #                    $align(alnfct, savaln);  (* update alignment factor *)
|                     "IF LIST=YES THEN" WRITELN(OUTPUT) ;
|                      END;
|                   END;
| 
|             FIL:  "IF LIST=YES THEN"
|                      BEGIN
|                      WRITE(OUTPUT, ' @ = ''');
|                      IF OFFSET = 0 THEN WRITE(OUTPUT, BASE@.CHR_VA(/0/))
|                            ELSE WRITE(OUTPUT, BOTSTK@.CHR_VA(/OFFSET/));
|                      WRITELN(OUTPUT, '''');
|                      END;
| 
|             END;
| 
|          INDX := INDX+2;
|          END;  (* $PRNT *)
| 
| 
| 
|       FUNCTION $IVSCAN(VAR INDX:INTEGER; VAR F:TEXT;
|                         IDREQ:CNTRL): CMPCODE;
| 
|          TYPE STATVAR = (GTYP,GNAME,PTYP,COPY,GNUM,GTERM);
| 
|          VAR  CONT:CMPCODE; VTYPE:VARTYPE;  STATE:STATVAR;
|               FIR,LAS:INTEGER;   SWITCH:BOOLEAN;
| 
|          BEGIN
|          CONT := PROCESS;      SWITCH := FALSE;
|          IF IDREQ=YES THEN STATE := GNAME ELSE STATE := GTYP;
| 
|          WHILE (NOT EOF(F)) AND (INDX+1<IBFLN) AND (CONT=PROCESS) DO
|             BEGIN
|             WHILE (F@=' ') AND (NOT EOF(F)) DO GET(F);
| 
|             FIR := INDX+1;
|             IF NOT (EOF(F) OR (STATE=PTYP))
|                THEN IF F@ = ';'
|                       THEN BEGIN  READ(F,IBF(/FIR/));  LAS := FIR;
|                       INDX := LAS+1; IBF(/INDX/) := ' '; END
| 
|                       ELSE BEGIN
|                       WHILE NOT(EOF(F) OR (F@ = ';') OR (F@ = ' '))
|                             AND (INDX+1 < IBFLN)
|                         DO BEGIN
|                         INDX := INDX+1; READ(F,IBF(/INDX/));
|                         END;
| 
|                       IF INDX < IBFLN
|                         THEN BEGIN    LAS := INDX;
|                         INDX := INDX+1;
|                         IBF(/INDX/) := ' '; END
| 
|                         ELSE CONT := BUFERR;
|                       END;
| 
|             IF (NOT EOF(F)) AND (CONT = PROCESS)
|                THEN BEGIN
| 
|                 CASE STATE OF
| 
|                   GNAME:   IF (IBF(/FIR/) <> ';')
|                               AND ((LAS-FIR)>=0)
| 
|                               THEN STATE := GTYP
|                               ELSE CONT := IDERR;
| 
| 
|                   GTYP:   BEGIN    VTYPE := $TRANSVAR(IBF(/FIR/));
|                           IF (VTYPE < UNK) AND ((LAS-FIR)=0)
|                             THEN  STATE := PTYP
|                             ELSE  CONT := TYPERR;
|                           END;
| 
|                   PTYP:  IF (VTYPE <= REC) AND (F@ = ';')
| 
|                             THEN BEGIN     CONT := SUCC;
|                             READ(F,IBF(/INDX+1/)); INDX := INDX+2;
|                             IBF(/INDX/) := ' ';  END
| 
|                             ELSE IF VTYPE <= PTR
|                                   THEN CONT := SYNERR
| 
|                             ELSE  CASE VTYPE OF
| 
|                                   SCL,FIL: STATE := COPY;
| 
| 
|                                   REC: BEGIN
|                                        CONT := $IVSCAN(INDX,F,YES);
|                                        IF CONT=SUCC THEN CONT:=PROCESS;
|                                        END;
| 
|                                   PSET,ARY: STATE := GNUM;
|                                 END;
| 
|                   COPY:  IF IBF(/FIR/) = ';' THEN CONT:=SUCC;
| 
|                   GNUM:  BEGIN
|                          IF IBF(/FIR/) = '-' THEN FIR := FIR+1;
|                          FOR FIR := FIR TO LAS DO
|                            IF NOT ( (ORD(IBF(/FIR/)) - ORD('0'))
|                                      IN (/0..9/) )
|                               THEN CONT := NUMERR;
| 
|                          IF CONT=PROCESS
|                             THEN IF SWITCH
|                                    THEN IF VTYPE = ARY
|                                       THEN CONT := $IVSCAN(INDX,F,NO)
|                                       ELSE STATE := GTERM
|                                     ELSE SWITCH := TRUE;
|                          END;
| 
|                   GTERM: IF IBF(/FIR/) = ';' THEN CONT := SUCC
|                             ELSE CONT := SYNERR;
| 
| 
|                   END;  (* CASE STATE *)
|                END;
|             END;
|          IF EOF(F) AND (CONT=PROCESS) THEN CONT := EOFERR;
|          IF (INDX+2 > IBFLN) AND (CONT=PROCESS) THEN CONT := BUFERR;
|          $IVSCAN := CONT;
| 
|          END;(*IVSCAN*)
| 
| 
|       BEGIN     (* $PRNTVAR *)
| #     WRITELN(OUTPUT) ;
| #     WRITELN(OUTPUT, '0    ****  Variables for ''', PNAME: $IDLEN(PNAME),
|                       ''' are:');
|       WRITELN(OUTPUT) ;
|       RESET(QRD);
|       TPROCN := '            ';   VADDR := -1;
| 
|       WHILE ((PNAME <> TPROCN) OR (PID<>VADDR))   AND (NOT EOF(QRD)) DO
|          BEGIN
|          WHILE (QRD@ <> '%') AND (NOT EOF(QRD)) DO READLN(QRD);
| 
|          IF NOT EOF(QRD)
|             THEN BEGIN
|             GET(QRD);
|             WHILE (QRD@=' ') DO GET(QRD);
| 
|             I := 1;  TPROCN := '            ';
|             WHILE (QRD@ <> ' ') DO IF I <= PNAMLN
|                   THEN BEGIN READ(QRD,TPROCN(/I/));  I:=I+1 END
|                   ELSE GET(QRD);
| 
|             READ(QRD, VADDR);
|             READLN(QRD);
|             END;
| 
| 
|          END;
| 
|       IF (PNAME = TPROCN) AND (PID = VADDR)
| 
|          THEN BEGIN    ERR := SUCC;
|          WHILE (QRD@ = ' ') AND (NOT EOF(QRD)) DO GET(QRD);
|          WHILE    (NOT EOF(QRD)) AND (QRD@<>'%') AND (ERR =SUCC)
|                AND (QRD@ <> '#') DO
|             BEGIN
|             INDRCT := QRD@ = '@';
|             IF INDRCT
|                THEN BEGIN    GET(QRD);
|                WHILE (QRD@=' ') AND (NOT EOF(QRD)) DO GET(QRD);
|                END;
| 
|             IF (ORD(QRD@) - ORD('0')) IN (/0..9/)
|                THEN BEGIN
|                READ(QRD,VADDR);  MAXI := 0;
|                ERR := $IVSCAN(MAXI,QRD,YES);
| 
|                IF ERR = SUCC
|                   THEN BEGIN "FOR I := 0 TO INDENT6 DO WRITE(OUTPUT, ' ');"
| #                 WRITE(OUTPUT, ' ':(INDENT6+1)+4) ;
|                   I := 1;
| 
|                   IF INDRCT
|                      THEN BEGIN
|                      SB.I := STKP@.INT_VA(/VADDR DIV BYL_INT/);
|                      VADDR := 0;
|                      END
| 
|                      ELSE SB.P := STKP;
| 
| #                 alnfct := mal_char;   (* initialize alignment factor *)
| #                 $PRNT(INDENT6+4,I,VADDR,SB.P,YES(*,YES*));
|                   WHILE (NOT EOF(QRD)) AND (QRD@=' ') DO GET(QRD);
|                   END;
| 
|                END
| 
|                ELSE BEGIN ERR := ADDERR; MAXI := 0; END;
|             END;
| 
|          IF ERR <> SUCC THEN $ERRMSG(ERR, MAXI);
|          END
| 
| 
|          ELSE WRITELN(OUTPUT, ' procedure ',PNAME,' not found in symbol_table');
|       END; (*PRNTVAR*)
| 
| 
| 
|    FUNCTION $FROMLIN(P:PROC_PTR; RTNADD:INTEGER):INTEGER;
| 
|       CONST      ESCAPE = 254; (* HEX 'FE' *)
|          ESEND = 255;  (* HEX 'FF' *)
| 
|       VAR
|          NADDR,LIN,I,INDX:INTEGER;
|          TL:RECORD CASE INTEGER OF
|             1:(I:INTEGER);
|             2:(P:PROCTPTR)
|            END;
| 
|       BEGIN
|       I :=  ORD(P@.PROCLN(/0/))*256 + ORD(P@.PROCLN(/1/));
| 
|       IF (I = 0) OR (I > PROCSIZE)  THEN $FROMLIN := 0
|          ELSE BEGIN
|          NADDR := ORD(P);
|          TL.I := ORD(P) + I;
|          LIN := ORD(TL.P@.SLINNO(/0/))*256 + ORD(TL.P@.SLINNO(/1/)) -1;
|          INDX := 1;
| 
|          WITH TL.P@ DO
|             WHILE (RTNADD > NADDR) AND (ORD(LINARY(/INDX/)) <> ESEND) DO
|                BEGIN
|                I := ORD(LINARY(/INDX/));
|                INDX := INDX+1;
|                LIN := LIN+1;
|                IF I <> ESCAPE THEN NADDR := NADDR + 2*I
|                   ELSE BEGIN
|                   NADDR := NADDR + ORD(LINARY(/INDX/))*512
|                            + ORD(LINARY(/INDX+1/))*2;
|                   INDX := INDX+2;
|                   END;
|             END;
| 
|          $FROMLIN := LIN;
|          END;
| 
|       END;  (* $FROMLIN *)
| 
| 
|    PROCEDURE $PRNTLNK(CURSTK,PRESTK:FRM_PTR; VAR PNAME:PROCNAME;
|                       VAR PID,LNGTH:INTEGER);
| 
|       VAR
|          TPROCN:PROCNAME;
|          I,J:INTEGER;
| 
| 
| 
|       BEGIN
|       $GETPNAME(CURSTK@.EPA, PID, LNGTH, PNAME);
|       $GETPNAME(PRESTK@.EPA,J,I,TPROCN);
|       WRITELN(OUTPUT);
|       WRITE(OUTPUT, '0    ****  procedure ''',PNAME: $IDLEN(PNAME),
|              ''' was called by --> ''',TPROCN: $IDLEN(TPROCN), '''');
| 
|       WRITELN(OUTPUT, '  from line: ',
|             $FROMLIN(PRESTK@.EPA,(CURSTK@.RET MOD ADDRC)):1);
| 
|      END; (*PRNTLNK*)
| 
| 
|    PROCEDURE $PRNTSYSD(P:ABNDP; S:PROC_PTR);
| 
|       VAR     I,J:INTEGER;  TPROCN:PROCNAME;    CODE: 0..21;
| 
|       BEGIN
|       WITH P@ DO BEGIN
|          WRITE(OUTPUT, '0    ****  Run Error: ',ABCODE:4);
|          $GETPNAME(S,I,J,TPROCN);
|          IF (0 < J) AND (J < PROCSIZE)
|             THEN WRITE(OUTPUT, '  from line: ',$FROMLIN(S,ABADDR MOD ADDRC):1)
|             ELSE WRITE(OUTPUT, ' at location: ',(ABADDR MOD ADDRC)-
|                                         (ABREGS[10] MOD ADDRC):1);
|          WRITELN(OUTPUT, '  of procedure: ''', TPROCN: $IDLEN(TPROCN), '''');
| 
|          WRITE(OUTPUT, '0    ****  ');
|          IF ABCODE < 2000
|             THEN BEGIN
|             CODE := ABCODE-1000;
|             CASE CODE OF
|                1: WRITE(OUTPUT, 'INDEX VALUE ');
|                2: WRITE(OUTPUT, 'SUBRANGE VALUE ');
|                3: WRITE(OUTPUT, 'ACTUAL PARAMETER ');
|                4: WRITE(OUTPUT, 'SET ELEMENT/MEMBER ');
|                5: WRITE(OUTPUT, 'POINTER VALUE ');
|                6: WRITELN(OUTPUT, 'STACK/HEAP COLLISION.');
|                7: WRITELN(OUTPUT, 'ILLEGAL INPUT/RESET OPERATION.');
|                8: WRITELN(OUTPUT, 'ILLEGAL OUTPUT/REWRITE OPERATION.');
| #              9: WRITELN(OUTPUT, 'SYN. I/O ERROR: ', ABEMSG@:ABMSGL) ;
|               10: WRITELN(OUTPUT, 'PROGRAM RUNNING OUT OF TIME.');
|               11: WRITELN(OUTPUT, 'FILE DEFINITION ERROR.');
|               12: WRITELN(OUTPUT, 'PROGRAM OUT OF STACK SPACE.');
|               13: WRITELN(OUTPUT, 'CALL TO UNDEFINED STNDARD PROC.');
|               14: WRITELN(OUTPUT, 'FILE LINE-LIMIT EXCEEDED.');
|               20: WRITELN(OUTPUT, 'ATTEMPT TO READ PAST END OF FILE.');
|               21: WRITELN(OUTPUT, 'ATTEMPT TO READ BAD BOOLEAN.');
|               22: WRITELN(OUTPUT, 'ATTEMPT TO READ BAD INTEGER.');
|               23: WRITELN(OUTPUT, 'ATTEMPT TO READ REAL.');
|               END;
| 
|             IF CODE <= 5
|                THEN BEGIN
|                WRITELN(OUTPUT, 'OUT OF RANGE.');
|                WRITELN(OUTPUT, '0    ****  The offending value:  ',ABCVAL:1,
|                  '  is not in the range:  ', ABLOWR:1, '..', ABUPPR:1) ;
|                END;
|             END
| 
|             ELSE IF ABCODE < 3000
|                THEN BEGIN
|                CODE := ABCODE-2000;
|                CASE CODE OF
|                   0: WRITE(OUTPUT, 'IMPRECISE');
|                   1: WRITE(OUTPUT, 'OPERATION');
|                   2: WRITE(OUTPUT, 'PRIVILEGED OPERATION');
|                   3: WRITE(OUTPUT, 'EXECUTE');
|                   4: WRITE(OUTPUT, 'PROTECTION');
|                   5: WRITE(OUTPUT, 'ADDRESSING');
|                   8: WRITE(OUTPUT, 'FIXED-POINT OVERFLOW');
|                   9: WRITE(OUTPUT, 'FIXED-POINT DIVIDE');
|                  12: WRITE(OUTPUT, 'EXPONENT OVERFLOW');
|                  13: WRITE(OUTPUT, 'EXPONENT UNDERFLOW');
|                  14: WRITE(OUTPUT, 'SIGNIFICANCE');
|                  15: WRITE(OUTPUT, 'FLOATING-POINT DIVIDE');
|                  END;
| 
|                WRITELN(OUTPUT, ' EXCEPTION.');
|                END
| 
|             ELSE IF ABCODE = 3001
| #              THEN WRITELN(OUTPUT, 'EXTERNAL ERROR: ', ABEMSG@:ABMSGL);
| 
|          END;   (* WITH P@ DO *)
|       END;  (* $PRNTSYSD *)
| 
| 
|    BEGIN   (* SNAPSHOT *)
|   "PAR2.I := DMPKIND MOD 10;"
|    I := ORD('A');
|    VARTARY(/0/) := ARY;       VARTARY(/ORD('B')-I/) := BOL;
|    VARTARY(/ORD('C')-I/) := CHA;
|    VARTARY(/ORD('D')-I/) := REC;
|    VARTARY(/ORD('I')-I/) := INT;
|    VARTARY(/ORD('R')-I/) := RL;
|    VARTARY(/ORD('P')-I/) := PTR;
|    VARTARY(/ORD('S')-I/) := PSET;
|    VARTARY(/ORD('L')-I/) := SCL;
|    VARTARY(/ORD('F')-I/) := FIL;
| 
|    TOPSTK := DMARRAY(/-16/);  (* SAVED R1 IN RUNTIME STACK *)
|    BOTSTK := DMARRAY(/-5/);   (* SAVED R12 IN RUNTIME STACK *)
|    TMPSTK := TOPSTK@.BAK_LNK;
|    REWRITE(OUTPUT) ;    (* IN CASE "OUTPUT" IS NOT OPEN *)
|    WRITELN(OUTPUT, '     ****  SNAPSHOT DUMP OF PROGRAM  ****');
|    WRITELN(OUTPUT) ;
|    WRITE(OUTPUT, '0    ****  ''SNAPSHOT'' was called by --> ');
| 
|    IF LEVEL < 0
|       THEN BEGIN
|       WRITELN(OUTPUT, '''PASCAL_MONITOR''');
|       PAR2.I := DMPKIND ;
|       ARRYLSTF := FALSE;
|       $PRNTSYSD(PAR2.P,TMPSTK@.EPA);
|       LEVEL := -1;  PAR2.C := FULL;
|       END
| 
|    ELSE BEGIN
|       PAR2.I := DMPKIND MOD 10 ;
|       ARRYLSTF := ((DMPKIND DIV 10) MOD 10) = 1;
|       $GETPNAME(TMPSTK@.EPA,UID,PLEN,CPROCN);
|       WRITELN(OUTPUT, '''', CPROCN: $IDLEN(CPROCN), '''  from line: ',
|             $FROMLIN(TMPSTK@.EPA,TOPSTK@.RET MOD ADDRC):1);
|       END;
| 
| 
|    DEPTH := 1;
|    IF LEVEL = -1 THEN MAXDEPTH := DEFLEV
|       ELSE IF LEVEL = 0  THEN MAXDEPTH := ADDRC
|               ELSE MAXDEPTH := LEVEL;
| 
| 
| #  IF (PAR2.C = FULL) OR (PAR2.C =STKTRACE) THEN
| #
| #     REPEAT
| #     DONE :=  (TMPSTK = BOTSTK) OR (DEPTH > MAXDEPTH) ;
| #
| #     IF PAR2.C = FULL THEN    (* DUMP VARIABLES AS WELL AS CALL TRACE *)
| #        BEGIN
| #        $GETPNAME(TMPSTK@.EPA, UID, PLEN, CPROCN);
| #        IF (PLEN > 0) AND (PLEN < PROCSIZE)
| #           THEN  $PRNTVAR(TMPSTK, CPROCN, UID);
| #        END ; (* FULL DUMP *)
| #
| #     IF TMPSTK <> BOTSTK THEN
| #        $PRNTLNK(TMPSTK, TMPSTK@.BAK_LNK, CPROCN, UID, PLEN);
| #     TMPSTK := TMPSTK@.BAK_LNK;
| #     DEPTH := DEPTH+1;
| #     UNTIL DONE ;
| #
| #  WRITELN(OUTPUT, '0    ****  END OF DUMP  ****') ;
|    PAGE(OUTPUT);
| 
|    END; (* SNAPSHOT *)
| 
| BEGIN
| END.
> Member SOMA
| (*$M-*)
| PROGRAM SOMA(OUTPUT);
| 
| 
|    (*************************************************************************
|    *                                                                        *
|    *               SOLUTIONS TO THE SOMA CUBE PROBLEM                       *
|    *                                                                        *
|    *                     A PASCAL PROGRAM                                   *
|    *                     BY RANCE DELONG                                    *
|    *                     MORAVIAN COLLEGE                                   *
|    *                                                                        *
|    *                     PUBLISHED IN ACM SIGPLAN NOTICES                   *
|    *                     VOL. 9 NO. 10 (OCTOBER 1974)                       *
|    *                                                                        *
|    *************************************************************************)
| 
| 
| 
| TYPE
|    CUBE_SET = SET OF 1..27;
|    WHERE = (TOP, BOTTOM, RIGHT, LEFT, FRONT, BACK, NOWHERE);
|    PIECE_DESCRIPTION = ARRAY (/1..3/) OF WHERE;
|    AXES = (TBAXIS, RLAXIS, FBAXIS);
|    HASH_VALUE = 0..58;
|    PLIST_PTR = @ POSN_LIST_ELEMENT;
|    WHERE_SET = SET OF WHERE;
|    PIECE_RANGE = 1..7;
|    POSN_LIST_ELEMENT = RECORD
|                           PC_POSITION : CUBE_SET;
|                           NEXT_POSN : PLIST_PTR
|                        END;
| 
| VAR
|    THE_CUBE : CUBE_SET;
|    PIECE : ARRAY (/1..7/) OF PIECE_DESCRIPTION;
|    MAJOR_ROTATIONS : ARRAY (/0..1/) OF AXES;
|    ROTATED : ARRAY (/AXES,WHERE/) OF WHERE;
|    SHIFT : ARRAY (/WHERE/) OF INTEGER;
|    HASH : ARRAY (/WHERE,1..2/) OF INTEGER;
|    POSN_LSTHEAD, SOLTION_PTR : ARRAY (/1..7/) OF PLIST_PTR;
|    THOSE_CONSIDERED : SET OF HASH_VALUE;
|    P, I, SOLUTIONS : INTEGER;
|    NUMBER_USED : INTEGER;
| 
| 
| 
| FUNCTION ORD1(S:WHERE_SET) : INTEGER;
|    VAR I,J : INTEGER;   W : WHERE;
|    BEGIN
|       I := 0; J := 1;
|       FOR W := TOP TO NOWHERE DO
|          BEGIN
|             IF W IN S THEN I := I + J;
|             J := 2*J
|          END;
|       ORD1 := I
|    END (**** ORD1 ****) ;
| 
| 
| PROCEDURE INITIALIZE;
|    BEGIN
|       PIECE(/1,1/) := RIGHT; PIECE(/1,2/) := FRONT; PIECE(/1,3/) := NOWHERE;
|       PIECE(/2,1/) := RIGHT; PIECE(/2,2/) := FRONT; PIECE(/2,3/) := FRONT;
|       PIECE(/3,1/) := RIGHT; PIECE(/3,2/) := FRONT; PIECE(/3,3/) := RIGHT;
|       PIECE(/4,1/) := RIGHT; PIECE(/4,2/) := FRONT; PIECE(/4,3/) := RIGHT;
|       PIECE(/5,1/) := RIGHT; PIECE(/5,2/) := TOP;   PIECE(/5,3/) := FRONT;
|       PIECE(/6,1/) := RIGHT; PIECE(/6,2/) := FRONT; PIECE(/6,3/) := TOP;
|       PIECE(/7,1/) := RIGHT; PIECE(/7,2/) := TOP;   PIECE(/7,3/) := FRONT;
|       MAJOR_ROTATIONS(/0/) := FBAXIS; MAJOR_ROTATIONS(/1/) := RLAXIS;
|       ROTATED(/TBAXIS,TOP/) := TOP; ROTATED(/TBAXIS,BOTTOM/) := BOTTOM;
|       ROTATED(/TBAXIS,RIGHT/) := BACK; ROTATED(/TBAXIS,LEFT/) := FRONT;
|       ROTATED(/TBAXIS,FRONT/) := RIGHT; ROTATED(/TBAXIS,BACK/) := LEFT;
|       ROTATED(/TBAXIS,NOWHERE/) := NOWHERE;
|       ROTATED(/RLAXIS,TOP/) := FRONT; ROTATED(/RLAXIS,BOTTOM/) := BACK;
|       ROTATED(/RLAXIS,RIGHT/) := RIGHT; ROTATED(/RLAXIS,LEFT/) := LEFT;
|       ROTATED(/RLAXIS,FRONT/) := BOTTOM; ROTATED(/RLAXIS,BACK/) := TOP;
|       ROTATED(/RLAXIS,NOWHERE/) := NOWHERE;
|       ROTATED(/FBAXIS,TOP/) := LEFT; ROTATED(/FBAXIS,BOTTOM/) := RIGHT;
|       ROTATED(/FBAXIS,RIGHT/) := TOP; ROTATED(/FBAXIS,LEFT/) := BOTTOM;
|       ROTATED(/FBAXIS,FRONT/) := FRONT; ROTATED(/FBAXIS,BACK/) := BACK;
|       ROTATED(/FBAXIS,NOWHERE/) := NOWHERE;
|       SHIFT(/TOP/) := 9; SHIFT(/BOTTOM/) := -9; SHIFT(/RIGHT/) := 1;
|       SHIFT(/LEFT/) := -1; SHIFT(/FRONT/) := 3; SHIFT(/BACK/) := -3;
|       SHIFT(/NOWHERE/) := 0;
|       HASH(/TOP,1/) := 1; HASH(/TOP,2/) := 6; HASH(/BOTTOM,1/) := -1;
|       HASH(/BOTTOM,2/) := -6; HASH(/RIGHT,1/) := 2; HASH(/RIGHT,2/) := 19;
|       HASH(/LEFT,1/) := -2; HASH(/LEFT,2/) := -19; HASH(/FRONT,1/) := 3;
|       HASH(/FRONT,2/) := 32; HASH(/BACK,1/) := -3; HASH(/BACK,2/) := -32;
|       HASH(/NOWHERE,1/) := 0; HASH(/NOWHERE,2/) := 0;
|       THE_CUBE := (//);
|       (* INTFIELDSIZE := 3; *)
|       NUMBER_USED := 0;
|       SOLUTIONS := 0
|    END (**** INITIALIZE ****) ;
| 
| 
| PROCEDURE RECORD_SOLUTION;
|    BEGIN
|       SOLUTIONS := SOLUTIONS + 1;
|       WRITELN(' SOLUTION ', SOLUTIONS);
|       FOR (* PIECES *) P := 1 TO 7 DO
|          BEGIN
|             WRITE(P, '   ');
|             WITH SOLTION_PTR(/P/)@ DO
|                FOR I := 1 TO 27 DO IF I IN PC_POSITION THEN WRITE(I);
|             WRITELN()
|          END;
|       WRITELN()
|    END (**** RECORD_SOLUTION ****) ;
| 
| 
| FUNCTION ORIENTATION(PIECE:PIECE_DESCRIPTION) : HASH_VALUE;
|    VAR PC : SET OF WHERE;
|    BEGIN   (* SYMMETRIC ORIENTATIONS RECEIVE SAME VALUE *)
|       IF P IN (/1,2,7/) THEN
|          IF ODD(ORD(PIECE(/1/))) THEN
|                PC := (/PRED(PIECE(/1/)),PIECE(/2/)/)
|             ELSE PC := (/SUCC(PIECE(/1/)),PIECE(/2/)/);
|       CASE P OF
|          1,2   : ORIENTATION := ORD1(PC) DIV 2
|                           + 32*ORD(ORD(PIECE(/1/)) > ORD(PIECE(/3/)));
|          3     : ORIENTATION := ABS(ABS(HASH(/PIECE(/1/),1/)
|                           + HASH(/PIECE(/3/),1/)) + HASH(/PIECE(/2/),2/));
|          4,5,6 : ORIENTATION := ABS(HASH(/PIECE(/1/),1/)
|                           + HASH(/PIECE(/2/),2/) + HASH(/PIECE(/3/),1/));
|          7     : ORIENTATION := ORD1(PC + (/PIECE(/3/)/))
|       END
|    END (**** ORIENTATION ****) ;
| 
| 
| PROCEDURE ROTATE(VAR PIECE : PIECE_DESCRIPTION; AXIS : AXES);
|    BEGIN
|       FOR I := 1 TO 3 DO
|          PIECE(/I/) := ROTATED(/AXIS,PIECE(/I/)/)
|    END (**** ROTATE ****) ;
| 
| 
| PROCEDURE GEN_TRANSLATIONS(PIECE : PIECE_DESCRIPTION;
|                                 ORIENTATION : HASH_VALUE);
|    VAR RLDISP, FBDISP, DISP, J : INTEGER;
|        SIZE, PART : ARRAY (/0..3/) OF INTEGER;
|        CUBICLE : 1..27;
|    BEGIN RLDISP := 1; FBDISP := 3; PART(/0/) := 1;
|       FOR I := 0 TO 3 DO SIZE(/I/) := 3;
|       THOSE_CONSIDERED := THOSE_CONSIDERED + (/ORIENTATION/);
|       FOR I := 1 TO 3 DO
|          BEGIN
|             PART(/0/) := PART(/0/) + ORD(PIECE(/I/)) MOD 2
|                         * (-SHIFT(/PIECE(/I/)/));
|             SIZE(/ORD(PIECE(/I/)) DIV 2/) := SIZE(/ORD(PIECE(/I/)) DIV 2/) - 1;
|          END;
|       IF (* PIECE *) P IN (/3,7/) THEN
|          FOR I := 1 TO 3 DO
|             PART(/I/) := PART(/I DIV 2/) + SHIFT(/PIECE(/I/)/)
|       ELSE
|          FOR I := 1 TO 3 DO
|             PART(/I/) := PART(/I-1/) + SHIFT(/PIECE(/I/)/);
|       FOR I := 1 TO SIZE(/0/)*SIZE(/1/)*SIZE(/2/) DO
|          BEGIN
|             WITH SOLTION_PTR(/P/)@ DO (* ADD POSITION TO LIST *)
|                BEGIN
|                   PC_POSITION := (//);
|                   FOR J := 0 TO 3 DO
|                      BEGIN
|                         CUBICLE := PART(/J/);
|                         PC_POSITION := PC_POSITION + (/CUBICLE/)
|                      END;
|                   NEW(NEXT_POSN);
|                   SOLTION_PTR(/P/) := NEXT_POSN;
|                   NEXT_POSN@.NEXT_POSN := NIL
|                END;
|             IF I MOD SIZE(/1/) = 0 THEN (* SHIFT TO NEW POSITION *)
|                BEGIN (* FORWARD, BACKWARD OR UPWARD MOVEMENT *)
|                   RLDISP := -RLDISP;
|                   IF I MOD (SIZE(/1/)*SIZE(/2/)) = 0 THEN
|                      BEGIN
|                         FBDISP := -FBDISP;
|                         DISP := 9;
|                      END
|                   ELSE DISP := FBDISP
|                END
|             ELSE DISP := RLDISP  (* RIGHT OR LEFT *) ;
|            FOR J := 0 TO 3 DO PART(/J/) := PART(/J/) + DISP
|          END
|    END (**** GEN_TRANSLATIONS ****) ;
| 
| 
| PROCEDURE GEN_PIECE_POSITIONS;
|    VAR M, MINOR_ROTATIONS : INTEGER; THIS_ORIENTATION : HASH_VALUE;
|    BEGIN
|       FOR (* PIECES *) P := 1 TO 7 DO
|          BEGIN
|             THOSE_CONSIDERED := (//);
|             NEW(POSN_LSTHEAD(/P/)); SOLTION_PTR(/P/) := POSN_LSTHEAD(/P/);
|             FOR (* MAJOR_ROTATIONS *) M := 1 TO 6 DO
|                BEGIN
|                   FOR MINOR_ROTATIONS := 1 TO 4 DO
|                      BEGIN
|                         THIS_ORIENTATION := ORIENTATION(PIECE(/P/));
|                         IF NOT(THIS_ORIENTATION IN THOSE_CONSIDERED) THEN
|                            GEN_TRANSLATIONS(PIECE(/P/),THIS_ORIENTATION)
|                         ELSE
|                            REPEAT
|                               ROTATE(PIECE(/P/),TBAXIS);
|                               MINOR_ROTATIONS := MINOR_ROTATIONS + 1
|                            UNTIL MINOR_ROTATIONS > 3;
|                         ROTATE(PIECE(/P/),TBAXIS);
|                      END;
|                   ROTATE(PIECE(/P/),MAJOR_ROTATIONS(/M MOD 3 DIV 2/))
|                END
|          END;
|       POSN_LSTHEAD(/2/)@.NEXT_POSN@.NEXT_POSN@.NEXT_POSN := NIL
|    END (**** GEN_PIECE_POSITIONS ****) ;
| 
| 
| PROCEDURE GEN_SOLUTIONS(PC_NUM : PIECE_RANGE);
|    BEGIN
|       NUMBER_USED := NUMBER_USED + 1;
|       SOLTION_PTR(/PC_NUM/) := POSN_LSTHEAD(/PC_NUM/);
|       WHILE SOLTION_PTR(/PC_NUM/)@.NEXT_POSN <> NIL DO
|          WITH SOLTION_PTR(/PC_NUM/)@ DO
|          BEGIN
|             IF THE_CUBE * PC_POSITION = (//) THEN
|                BEGIN
|                   THE_CUBE := THE_CUBE + PC_POSITION;
|                   IF NUMBER_USED = 7 THEN RECORD_SOLUTION
|                      ELSE GEN_SOLUTIONS(PC_NUM MOD 7 + 1);
|                   THE_CUBE := THE_CUBE - PC_POSITION
|                END;
|             SOLTION_PTR(/PC_NUM/) := NEXT_POSN
|          END;
|       NUMBER_USED := NUMBER_USED - 1
|    END (**** GEN_SOLUTIONS ****) ;
| 
| 
| BEGIN
|    INITIALIZE;
|    GEN_PIECE_POSITIONS;
|    GEN_SOLUTIONS(2)
| END (**** SOMA ****) .
